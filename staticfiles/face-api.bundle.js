var faceapi=(()=>{var Ky=Object.defineProperty;var JR=Object.getOwnPropertyDescriptor;var YR=Object.getOwnPropertyNames;var QR=Object.prototype.hasOwnProperty;var Ss=(e=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(e,{get:(t,n)=>(typeof require!="undefined"?require:t)[n]}):e)(function(e){if(typeof require!="undefined")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')});var eD=(e,t)=>{for(var n in t)Ky(e,n,{get:t[n],enumerable:!0})},tD=(e,t,n,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let a of YR(t))!QR.call(e,a)&&a!==n&&Ky(e,a,{get:()=>t[a],enumerable:!(r=JR(t,a))||r.enumerable});return e};var nD=e=>tD(Ky({},"__esModule",{value:!0}),e);var uye={};eD(uye,{AgeGenderNet:()=>XF,BoundingBox:()=>y1,Box:()=>Zr,ComposableTask:()=>Ku,ComputeAllFaceDescriptorsTask:()=>cf,ComputeFaceDescriptorsTaskBase:()=>X1,ComputeSingleFaceDescriptorTask:()=>mf,DetectAllFaceLandmarksTask:()=>dR,DetectAllFacesTask:()=>Y1,DetectFaceLandmarksTaskBase:()=>Z1,DetectFacesTaskBase:()=>J1,DetectSingleFaceLandmarksTask:()=>hR,DetectSingleFaceTask:()=>cR,Dimensions:()=>Ua,FACE_EXPRESSION_LABELS:()=>kx,FaceDetection:()=>lr,FaceDetectionNet:()=>Tge,FaceExpressionNet:()=>UF,FaceExpressions:()=>lf,FaceLandmark68Net:()=>A1,FaceLandmark68TinyNet:()=>JF,FaceLandmarkNet:()=>tge,FaceLandmarks:()=>si,FaceLandmarks5:()=>Tfe,FaceLandmarks68:()=>v1,FaceMatch:()=>yx,FaceMatcher:()=>iye,FaceRecognitionNet:()=>R1,Gender:()=>KF,LabeledBox:()=>bx,LabeledFaceDescriptors:()=>bp,NetInput:()=>Gp,NeuralNetwork:()=>Ia,ObjectDetection:()=>b1,Point:()=>tt,PredictedBox:()=>Cfe,Rect:()=>x1,SsdMobilenetv1:()=>df,SsdMobilenetv1Options:()=>zo,TinyFaceDetector:()=>B1,TinyFaceDetectorOptions:()=>sR,TinyYolov2:()=>z1,TinyYolov2Options:()=>Xd,allFaces:()=>sye,allFacesSsdMobilenetv1:()=>mR,allFacesTinyYolov2:()=>aye,awaitMediaLoaded:()=>_F,bufferToImage:()=>EF,computeFaceDescriptor:()=>Gge,createCanvas:()=>Up,createCanvasFromMedia:()=>T1,createFaceDetectionNet:()=>Nge,createFaceRecognitionNet:()=>lge,createSsdMobilenetv1:()=>eR,createTinyFaceDetector:()=>oye,createTinyYolov2:()=>Lge,detectAllFaces:()=>Q1,detectFaceLandmarks:()=>oR,detectFaceLandmarksTiny:()=>Uge,detectLandmarks:()=>nye,detectSingleFace:()=>rye,draw:()=>oF,env:()=>sn,euclideanDistance:()=>fR,extendWithAge:()=>M1,extendWithFaceDescriptor:()=>D1,extendWithFaceDetection:()=>Vp,extendWithFaceExpressions:()=>$1,extendWithFaceLandmarks:()=>pf,extendWithGender:()=>O1,extractFaceTensors:()=>of,extractFaces:()=>sf,fetchImage:()=>Afe,fetchJson:()=>FF,fetchNetWeights:()=>Ffe,fetchOrThrow:()=>Kd,fetchVideo:()=>Dfe,getContext2dOrThrow:()=>ma,getMediaDimensions:()=>af,imageTensorToCanvas:()=>$F,imageToSquare:()=>AF,inverseSigmoid:()=>kfe,iou:()=>fF,isMediaElement:()=>vx,isMediaLoaded:()=>N1,isWithAge:()=>uge,isWithFaceDetection:()=>kl,isWithFaceExpressions:()=>GF,isWithFaceLandmarks:()=>uf,isWithGender:()=>pge,loadAgeGenderModel:()=>Qge,loadFaceDetectionModel:()=>eye,loadFaceExpressionModel:()=>Yge,loadFaceLandmarkModel:()=>Xge,loadFaceLandmarkTinyModel:()=>Zge,loadFaceRecognitionModel:()=>Jge,loadSsdMobilenetv1Model:()=>lR,loadTinyFaceDetectorModel:()=>qge,loadTinyYolov2Model:()=>Kge,loadWeightMap:()=>DF,locateFaces:()=>tye,matchDimensions:()=>Mfe,minBbox:()=>gF,nets:()=>ht,nonMaxSuppression:()=>yF,normalize:()=>qu,padToSquare:()=>bF,predictAgeAndGender:()=>jge,recognizeFaceExpressions:()=>Hge,resizeResults:()=>yR,resolveInput:()=>rf,shuffleArray:()=>wfe,sigmoid:()=>Zh,ssdMobilenetv1:()=>iR,tf:()=>JI,tinyFaceDetector:()=>Wge,tinyYolov2:()=>Vge,toNetInput:()=>dn,utils:()=>lF,validateConfig:()=>tR,version:()=>lye});var rD=Object.defineProperty,aD=(e=>typeof Ss!="undefined"?Ss:typeof Proxy!="undefined"?new Proxy(e,{get:(t,n)=>(typeof Ss!="undefined"?Ss:t)[n]}):e)(function(e){if(typeof Ss!="undefined")return Ss.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')}),Ix=(e,t)=>{for(var n in t)rD(e,n,{get:t[n],enumerable:!0})},JI={};Ix(JI,{Abs:()=>Sl,Acos:()=>oi,Acosh:()=>li,AdadeltaOptimizer:()=>Gv,AdagradOptimizer:()=>Hv,AdamOptimizer:()=>jv,AdamaxOptimizer:()=>qv,Add:()=>is,AddN:()=>ui,All:()=>Nl,Any:()=>Tl,ArgMax:()=>Cl,ArgMin:()=>_l,Asin:()=>pi,Asinh:()=>di,Atan:()=>hi,Atan2:()=>mi,Atanh:()=>ci,AvgPool:()=>fi,AvgPool3D:()=>El,AvgPool3DGrad:()=>Kp,AvgPoolGrad:()=>qp,BackendWasm:()=>sF,BatchMatMul:()=>gi,BatchToSpaceND:()=>$l,Bincount:()=>Al,BitwiseAnd:()=>Fl,BroadcastArgs:()=>Xp,BroadcastTo:()=>hS,Callback:()=>aC,CallbackList:()=>J2,Cast:()=>yi,Ceil:()=>bi,ClipByValue:()=>os,Complex:()=>Ac,ComplexAbs:()=>Zp,Concat:()=>Rl,Conv2D:()=>xi,Conv2DBackpropFilter:()=>Fc,Conv2DBackpropInput:()=>vi,Conv3D:()=>wi,Conv3DBackpropFilterV2:()=>Dl,Conv3DBackpropInputV2:()=>Ml,Cos:()=>ki,Cosh:()=>Ii,CropAndResize:()=>Ll,Cumprod:()=>Ol,Cumsum:()=>Si,CustomCallback:()=>Q2,DataStorage:()=>_c,DenseBincount:()=>Jp,DepthToSpace:()=>zl,DepthwiseConv2dNative:()=>Ni,DepthwiseConv2dNativeBackpropFilter:()=>Rc,DepthwiseConv2dNativeBackpropInput:()=>Dc,Diag:()=>Yp,Dilation2D:()=>Ti,Dilation2DBackpropFilter:()=>il,Dilation2DBackpropInput:()=>sl,Draw:()=>Mc,ENV:()=>_x,EarlyStopping:()=>sC,Einsum:()=>Oc,Elu:()=>_i,EluGrad:()=>Pl,Environment:()=>pS,Equal:()=>Bl,Erf:()=>Ei,Exp:()=>$i,ExpandDims:()=>Wl,Expm1:()=>Ai,FFT:()=>Lc,Fill:()=>Qp,FlipLeftRight:()=>Vl,Floor:()=>Fi,FloorDiv:()=>Ri,FromPixels:()=>ec,FusedBatchNorm:()=>Di,FusedConv2D:()=>Ws,FusedDepthwiseConv2D:()=>Vs,GPGPUContext:()=>Kh,GatherNd:()=>Gl,GatherV2:()=>Ul,GraphModel:()=>R0,Greater:()=>Hl,GreaterEqual:()=>Mi,History:()=>Y2,IFFT:()=>zc,Identity:()=>Oi,Imag:()=>Pc,InputSpec:()=>Ft,IsFinite:()=>Li,IsInf:()=>zi,IsNan:()=>Pi,KernelBackend:()=>Hp,LRN:()=>Ui,LRNGrad:()=>Yl,LayerVariable:()=>U2,LayersModel:()=>pa,LeakyRelu:()=>Bi,Less:()=>jl,LessEqual:()=>ql,LinSpace:()=>Kl,Log:()=>Wi,Log1p:()=>Vi,LogSoftmax:()=>mS,LogicalAnd:()=>Xl,LogicalNot:()=>Zl,LogicalOr:()=>Jl,LogicalXor:()=>cS,LowerBound:()=>XD,MathBackendCPU:()=>O0,MathBackendWebGL:()=>p1,MatrixBandPart:()=>ZD,Max:()=>Gi,MaxPool:()=>ji,MaxPool3D:()=>Ql,MaxPool3DGrad:()=>td,MaxPoolGrad:()=>ed,MaxPoolWithArgmax:()=>nd,Maximum:()=>Hi,Mean:()=>qi,Min:()=>Ki,Minimum:()=>Xi,MirrorPad:()=>Zi,Mod:()=>Ji,MomentumOptimizer:()=>Kv,Multinomial:()=>eu,Multiply:()=>Yi,Neg:()=>tu,NonMaxSuppressionV3:()=>ru,NonMaxSuppressionV4:()=>au,NonMaxSuppressionV5:()=>su,NotEqual:()=>nu,OP_SCOPE_SUFFIX:()=>Rx,OneHot:()=>Qi,OnesLike:()=>iu,Optimizer:()=>va,OptimizerConstructors:()=>k2,Pack:()=>ou,PadV2:()=>eo,Pool:()=>JD,Pow:()=>to,Prelu:()=>no,Prod:()=>ro,RMSPropOptimizer:()=>Xv,RNN:()=>wa,RaggedGather:()=>Bc,RaggedRange:()=>Wc,RaggedTensorToTensor:()=>Vc,Range:()=>rd,Rank:()=>fb,Real:()=>Uc,RealDiv:()=>Ci,Reciprocal:()=>ao,Reduction:()=>fn,Relu:()=>so,Relu6:()=>lo,Reshape:()=>lu,ResizeBilinear:()=>oo,ResizeBilinearGrad:()=>pu,ResizeNearestNeighbor:()=>io,ResizeNearestNeighborGrad:()=>uu,Reverse:()=>uo,RotateWithOffset:()=>Nu,Round:()=>po,Rsqrt:()=>ho,SGDOptimizer:()=>Nm,ScatterNd:()=>du,SearchSorted:()=>cu,Select:()=>mu,Selu:()=>co,Sequential:()=>zm,Sigmoid:()=>yo,Sign:()=>go,Sin:()=>mo,Sinh:()=>fo,Slice:()=>fu,Softmax:()=>wo,Softplus:()=>bo,SpaceToBatchND:()=>gu,SparseFillEmptyRows:()=>ad,SparseReshape:()=>bu,SparseSegmentMean:()=>sd,SparseSegmentSum:()=>id,SparseToDense:()=>xu,SplitV:()=>yu,Sqrt:()=>xo,Square:()=>od,SquaredDifference:()=>ko,StaticRegexReplace:()=>ld,Step:()=>us,StridedSlice:()=>vu,StringNGrams:()=>ud,StringSplit:()=>pd,StringToHashBucketFast:()=>dd,Sub:()=>Io,Sum:()=>vo,SymbolicTensor:()=>Er,Tan:()=>So,Tanh:()=>No,Tensor:()=>Re,TensorBuffer:()=>Rt,TensorScatterUpdate:()=>hu,Tile:()=>ls,TopK:()=>wu,Transform:()=>ku,Transpose:()=>ua,Unique:()=>hd,Unpack:()=>Iu,UnsortedSegmentSum:()=>cd,UpperBound:()=>YD,Variable:()=>Us,ZerosLike:()=>Su,_FusedMatMul:()=>Bs,abs:()=>At,acos:()=>Px,acosh:()=>Bx,add:()=>Z,addN:()=>WS,all:()=>Kc,any:()=>Ep,argMax:()=>qs,argMin:()=>Wx,asin:()=>Vx,asinh:()=>Ux,atan:()=>Gx,atan2:()=>Hx,atanh:()=>jx,avgPool:()=>ya,avgPool3d:()=>Kx,backend:()=>Mx,backend_util:()=>T,basicLSTMCell:()=>HS,batchNorm:()=>To,batchNorm2d:()=>Xx,batchNorm3d:()=>Zx,batchNorm4d:()=>Jx,batchToSpaceND:()=>vd,bincount:()=>Yx,bitwiseAnd:()=>jS,booleanMaskAsync:()=>MN,broadcastArgs:()=>qS,broadcastTo:()=>Ls,broadcast_util:()=>Tu,browser:()=>Rd,buffer:()=>Oe,callbacks:()=>Xj,cast:()=>oe,ceil:()=>Qx,clipByValue:()=>un,clone:()=>Ur,complex:()=>ha,concat:()=>ot,concat1d:()=>ev,concat2d:()=>tv,concat3d:()=>nv,concat4d:()=>rv,constraints:()=>q2,conv1d:()=>Xc,conv2d:()=>bn,conv2dTranspose:()=>Zc,conv3d:()=>sv,conv3dTranspose:()=>iv,copyRegisteredKernels:()=>nM,cos:()=>wd,cosh:()=>Jc,cosineWindow:()=>vm,cumprod:()=>Fp,cumsum:()=>Yc,customGrad:()=>Kr,data:()=>EC,denseBincount:()=>ac,deprecationWarn:()=>Dx,depthToSpace:()=>ov,depthwiseConv2d:()=>Co,deregisterOp:()=>Yj,device_util:()=>yd,diag:()=>XS,dilation2d:()=>lv,disableDeprecationWarnings:()=>DM,dispose:()=>Ce,disposeVariables:()=>MM,div:()=>ce,divNoNan:()=>uv,dot:()=>pv,dropout:()=>Pv,einsum:()=>As,elu:()=>Cu,enableDebugMode:()=>RM,enableProdMode:()=>FM,enclosingPowerOfTwo:()=>Bv,engine:()=>cr,ensureShape:()=>JS,env:()=>G,equal:()=>Gn,erf:()=>Qc,euclideanNorm:()=>cv,exp:()=>pn,expandDims:()=>Xt,expm1:()=>mv,eye:()=>em,fft:()=>Ad,fill:()=>Un,findBackend:()=>WM,findBackendFactory:()=>VM,floor:()=>Eu,floorDiv:()=>qc,forceHalfFloat:()=>QE,fused:()=>ml,gather:()=>$u,gatherND:()=>PN,gather_util:()=>Yv,getBackend:()=>_S,getGradient:()=>cb,getKernel:()=>Tp,getKernelsForBackend:()=>tc,getThreadsCount:()=>hfe,gpgpu_util:()=>$E,grad:()=>vL,grads:()=>wL,greater:()=>kn,greaterEqual:()=>ba,ifft:()=>cl,imag:()=>kd,image:()=>er,inTopKAsync:()=>BN,initializers:()=>K2,input:()=>cT,io:()=>an,irfft:()=>cm,isFinite:()=>fv,isInf:()=>gv,isNaN:()=>yv,keep:()=>zt,kernel_impls:()=>Qr,layers:()=>X2,leakyRelu:()=>Id,less:()=>ul,lessEqual:()=>ds,linalg:()=>Uv,linspace:()=>nN,loadGraphModel:()=>a5,loadGraphModelSync:()=>s5,loadLayersModel:()=>GH,localResponseNormalization:()=>bv,log:()=>Hn,log1p:()=>Sd,logSigmoid:()=>xv,logSoftmax:()=>nm,logSumExp:()=>Nd,logicalAnd:()=>gr,logicalNot:()=>Td,logicalOr:()=>rm,logicalXor:()=>vv,losses:()=>YN,lowerBound:()=>aN,matMul:()=>De,math:()=>u2,max:()=>ar,maxPool:()=>jt,maxPool3d:()=>wv,maxPoolWithArgmax:()=>sN,maximum:()=>Yr,mean:()=>kt,memory:()=>rc,meshgrid:()=>iN,metrics:()=>tC,min:()=>ll,minimum:()=>Ja,mirrorPad:()=>kv,mod:()=>Iv,model:()=>qH,models:()=>nC,moments:()=>Cd,movingAverage:()=>ON,mul:()=>z,multiRNNCell:()=>oN,multinomial:()=>lN,neg:()=>ft,nextFrame:()=>Qv,norm:()=>_u,notEqual:()=>Zs,oneHot:()=>pl,ones:()=>En,onesLike:()=>jn,op:()=>L,outerProduct:()=>uN,pad:()=>Ar,pad1d:()=>pN,pad2d:()=>dN,pad3d:()=>hN,pad4d:()=>cN,pool:()=>Sv,pow:()=>qr,prelu:()=>Ed,print:()=>zx,prod:()=>Nv,profile:()=>OM,raggedGather:()=>mN,raggedRange:()=>fN,raggedTensorToTensor:()=>gN,rand:()=>yN,randomGamma:()=>wN,randomNormal:()=>sm,randomStandardNormal:()=>kN,randomUniform:()=>hs,randomUniformInt:()=>IN,range:()=>Js,ready:()=>PM,real:()=>dl,reciprocal:()=>$v,registerBackend:()=>jc,registerCallbackConstructor:()=>XH,registerGradient:()=>fS,registerKernel:()=>md,registerOp:()=>Jj,regularizers:()=>rC,relu:()=>nt,relu6:()=>im,removeBackend:()=>BM,reshape:()=>P,reverse:()=>or,reverse1d:()=>SN,reverse2d:()=>NN,reverse3d:()=>TN,reverse4d:()=>CN,rfft:()=>Fd,round:()=>om,rsqrt:()=>lm,scalar:()=>ve,scatterND:()=>LN,scatter_util:()=>gm,searchSorted:()=>am,selu:()=>um,separableConv2d:()=>Au,sequential:()=>KH,serialization:()=>ne,setBackend:()=>zM,setPlatform:()=>UM,setThreadsCount:()=>dfe,setWasmPath:()=>ufe,setWasmPaths:()=>pfe,setWebGLContext:()=>eE,setdiff1dAsync:()=>_N,shared:()=>L0,sigmoid:()=>fr,sign:()=>Av,signal:()=>JN,sin:()=>pm,sinh:()=>dm,slice:()=>Ue,slice1d:()=>$d,slice2d:()=>hm,slice3d:()=>Fu,slice4d:()=>hl,slice_util:()=>Bt,softmax:()=>cs,softplus:()=>_o,spaceToBatchND:()=>_d,sparse:()=>QN,sparseToDense:()=>zN,spectral:()=>ZN,split:()=>$n,sqrt:()=>Yt,square:()=>it,squaredDifference:()=>mm,squeeze:()=>ms,stack:()=>Dt,step:()=>Eo,stridedSlice:()=>Fv,string:()=>e2,sub:()=>he,sum:()=>fe,sumOutType:()=>Hc,tan:()=>Rv,tanh:()=>Za,tensor:()=>yn,tensor1d:()=>Qe,tensor2d:()=>Gr,tensor3d:()=>fm,tensor4d:()=>Ya,tensor5d:()=>EN,tensor6d:()=>$N,tensorScatterUpdate:()=>FN,tensor_util:()=>Sr,test_util:()=>bN,tidy:()=>B,tile:()=>Vn,time:()=>LM,topk:()=>Mv,train:()=>_s,transpose:()=>Me,truncatedNormal:()=>bm,unique:()=>Ov,unregisterGradient:()=>tM,unregisterKernel:()=>eM,unsortedSegmentSum:()=>xm,unstack:()=>Tt,upcastType:()=>sr,upperBound:()=>RN,util:()=>w,valueAndGrad:()=>kL,valueAndGrads:()=>IL,variable:()=>Lv,variableGrads:()=>rN,version:()=>xfe,version_converter:()=>o5,version_core:()=>qW,version_cpu:()=>l8,version_layers:()=>kw,version_wasm:()=>cfe,version_webgl:()=>JQ,webgl:()=>YQ,webgl_util:()=>Q_,where:()=>Jt,whereAsync:()=>zv,zeros:()=>It,zerosLike:()=>Ge});var sD=Object.create,Sx=Object.defineProperty,iD=Object.getOwnPropertyDescriptor,oD=Object.getOwnPropertyNames,lD=Object.getPrototypeOf,uD=Object.prototype.hasOwnProperty,Ot=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),_e=(e,t)=>{for(var n in t)Sx(e,n,{get:t[n],enumerable:!0})},pD=(e,t,n,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let a of oD(t))!uD.call(e,a)&&a!==n&&Sx(e,a,{get:()=>t[a],enumerable:!(r=iD(t,a))||r.enumerable});return e},ss=(e,t,n)=>(n=e!=null?sD(lD(e)):{},pD(t||!e||!e.__esModule?Sx(n,"default",{value:e,enumerable:!0}):n,e)),dD=Ot((e,t)=>{t.exports=r;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function r(S,M,W){this.low=S|0,this.high=M|0,this.unsigned=!!W}r.prototype.__isLong__,Object.defineProperty(r.prototype,"__isLong__",{value:!0});function a(S){return(S&&S.__isLong__)===!0}r.isLong=a;var s={},i={};function o(S,M){var W,U,H;return M?(S>>>=0,(H=0<=S&&S<256)&&(U=i[S],U)?U:(W=u(S,(S|0)<0?-1:0,!0),H&&(i[S]=W),W)):(S|=0,(H=-128<=S&&S<128)&&(U=s[S],U)?U:(W=u(S,S<0?-1:0,!1),H&&(s[S]=W),W))}r.fromInt=o;function l(S,M){if(isNaN(S))return M?v:x;if(M){if(S<0)return v;if(S>=g)return A}else{if(S<=-y)return R;if(S+1>=y)return E}return S<0?l(-S,M).neg():u(S%f|0,S/f|0,M)}r.fromNumber=l;function u(S,M,W){return new r(S,M,W)}r.fromBits=u;var p=Math.pow;function h(S,M,W){if(S.length===0)throw Error("empty string");if(S==="NaN"||S==="Infinity"||S==="+Infinity"||S==="-Infinity")return x;if(typeof M=="number"?(W=M,M=!1):M=!!M,W=W||10,W<2||36<W)throw RangeError("radix");var U;if((U=S.indexOf("-"))>0)throw Error("interior hyphen");if(U===0)return h(S.substring(1),M,W).neg();for(var H=l(p(W,8)),q=x,K=0;K<S.length;K+=8){var J=Math.min(8,S.length-K),Y=parseInt(S.substring(K,K+J),W);if(J<8){var ee=l(p(W,J));q=q.mul(ee).add(l(Y))}else q=q.mul(H),q=q.add(l(Y))}return q.unsigned=M,q}r.fromString=h;function d(S,M){return typeof S=="number"?l(S,M):typeof S=="string"?h(S,M):u(S.low,S.high,typeof M=="boolean"?M:S.unsigned)}r.fromValue=d;var c=65536,m=1<<24,f=c*c,g=f*f,y=g/2,b=o(m),x=o(0);r.ZERO=x;var v=o(0,!0);r.UZERO=v;var I=o(1);r.ONE=I;var N=o(1,!0);r.UONE=N;var C=o(-1);r.NEG_ONE=C;var E=u(-1,2147483647,!1);r.MAX_VALUE=E;var A=u(-1,-1,!0);r.MAX_UNSIGNED_VALUE=A;var R=u(0,-2147483648,!1);r.MIN_VALUE=R;var F=r.prototype;F.toInt=function(){return this.unsigned?this.low>>>0:this.low},F.toNumber=function(){return this.unsigned?(this.high>>>0)*f+(this.low>>>0):this.high*f+(this.low>>>0)},F.toString=function(S){if(S=S||10,S<2||36<S)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(R)){var M=l(S),W=this.div(M),U=W.mul(M).sub(this);return W.toString(S)+U.toInt().toString(S)}else return"-"+this.neg().toString(S);for(var H=l(p(S,6),this.unsigned),q=this,K="";;){var J=q.div(H),Y=q.sub(J.mul(H)).toInt()>>>0,ee=Y.toString(S);if(q=J,q.isZero())return ee+K;for(;ee.length<6;)ee="0"+ee;K=""+ee+K}},F.getHighBits=function(){return this.high},F.getHighBitsUnsigned=function(){return this.high>>>0},F.getLowBits=function(){return this.low},F.getLowBitsUnsigned=function(){return this.low>>>0},F.getNumBitsAbs=function(){if(this.isNegative())return this.eq(R)?64:this.neg().getNumBitsAbs();for(var S=this.high!=0?this.high:this.low,M=31;M>0&&!(S&1<<M);M--);return this.high!=0?M+33:M+1},F.isZero=function(){return this.high===0&&this.low===0},F.eqz=F.isZero,F.isNegative=function(){return!this.unsigned&&this.high<0},F.isPositive=function(){return this.unsigned||this.high>=0},F.isOdd=function(){return(this.low&1)===1},F.isEven=function(){return(this.low&1)===0},F.equals=function(S){return a(S)||(S=d(S)),this.unsigned!==S.unsigned&&this.high>>>31===1&&S.high>>>31===1?!1:this.high===S.high&&this.low===S.low},F.eq=F.equals,F.notEquals=function(S){return!this.eq(S)},F.neq=F.notEquals,F.ne=F.notEquals,F.lessThan=function(S){return this.comp(S)<0},F.lt=F.lessThan,F.lessThanOrEqual=function(S){return this.comp(S)<=0},F.lte=F.lessThanOrEqual,F.le=F.lessThanOrEqual,F.greaterThan=function(S){return this.comp(S)>0},F.gt=F.greaterThan,F.greaterThanOrEqual=function(S){return this.comp(S)>=0},F.gte=F.greaterThanOrEqual,F.ge=F.greaterThanOrEqual,F.compare=function(S){if(a(S)||(S=d(S)),this.eq(S))return 0;var M=this.isNegative(),W=S.isNegative();return M&&!W?-1:!M&&W?1:this.unsigned?S.high>>>0>this.high>>>0||S.high===this.high&&S.low>>>0>this.low>>>0?-1:1:this.sub(S).isNegative()?-1:1},F.comp=F.compare,F.negate=function(){return!this.unsigned&&this.eq(R)?R:this.not().add(I)},F.neg=F.negate,F.add=function(S){a(S)||(S=d(S));var M=this.high>>>16,W=this.high&65535,U=this.low>>>16,H=this.low&65535,q=S.high>>>16,K=S.high&65535,J=S.low>>>16,Y=S.low&65535,ee=0,re=0,te=0,ae=0;return ae+=H+Y,te+=ae>>>16,ae&=65535,te+=U+J,re+=te>>>16,te&=65535,re+=W+K,ee+=re>>>16,re&=65535,ee+=M+q,ee&=65535,u(te<<16|ae,ee<<16|re,this.unsigned)},F.subtract=function(S){return a(S)||(S=d(S)),this.add(S.neg())},F.sub=F.subtract,F.multiply=function(S){if(this.isZero())return x;if(a(S)||(S=d(S)),n){var M=n.mul(this.low,this.high,S.low,S.high);return u(M,n.get_high(),this.unsigned)}if(S.isZero())return x;if(this.eq(R))return S.isOdd()?R:x;if(S.eq(R))return this.isOdd()?R:x;if(this.isNegative())return S.isNegative()?this.neg().mul(S.neg()):this.neg().mul(S).neg();if(S.isNegative())return this.mul(S.neg()).neg();if(this.lt(b)&&S.lt(b))return l(this.toNumber()*S.toNumber(),this.unsigned);var W=this.high>>>16,U=this.high&65535,H=this.low>>>16,q=this.low&65535,K=S.high>>>16,J=S.high&65535,Y=S.low>>>16,ee=S.low&65535,re=0,te=0,ae=0,se=0;return se+=q*ee,ae+=se>>>16,se&=65535,ae+=H*ee,te+=ae>>>16,ae&=65535,ae+=q*Y,te+=ae>>>16,ae&=65535,te+=U*ee,re+=te>>>16,te&=65535,te+=H*Y,re+=te>>>16,te&=65535,te+=q*J,re+=te>>>16,te&=65535,re+=W*ee+U*Y+H*J+q*K,re&=65535,u(ae<<16|se,re<<16|te,this.unsigned)},F.mul=F.multiply,F.divide=function(S){if(a(S)||(S=d(S)),S.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&S.low===-1&&S.high===-1)return this;var M=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,S.low,S.high);return u(M,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?v:x;var W,U,H;if(this.unsigned){if(S.unsigned||(S=S.toUnsigned()),S.gt(this))return v;if(S.gt(this.shru(1)))return N;H=v}else{if(this.eq(R)){if(S.eq(I)||S.eq(C))return R;if(S.eq(R))return I;var q=this.shr(1);return W=q.div(S).shl(1),W.eq(x)?S.isNegative()?I:C:(U=this.sub(S.mul(W)),H=W.add(U.div(S)),H)}else if(S.eq(R))return this.unsigned?v:x;if(this.isNegative())return S.isNegative()?this.neg().div(S.neg()):this.neg().div(S).neg();if(S.isNegative())return this.div(S.neg()).neg();H=x}for(U=this;U.gte(S);){W=Math.max(1,Math.floor(U.toNumber()/S.toNumber()));for(var K=Math.ceil(Math.log(W)/Math.LN2),J=K<=48?1:p(2,K-48),Y=l(W),ee=Y.mul(S);ee.isNegative()||ee.gt(U);)W-=J,Y=l(W,this.unsigned),ee=Y.mul(S);Y.isZero()&&(Y=I),H=H.add(Y),U=U.sub(ee)}return H},F.div=F.divide,F.modulo=function(S){if(a(S)||(S=d(S)),n){var M=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,S.low,S.high);return u(M,n.get_high(),this.unsigned)}return this.sub(this.div(S).mul(S))},F.mod=F.modulo,F.rem=F.modulo,F.not=function(){return u(~this.low,~this.high,this.unsigned)},F.and=function(S){return a(S)||(S=d(S)),u(this.low&S.low,this.high&S.high,this.unsigned)},F.or=function(S){return a(S)||(S=d(S)),u(this.low|S.low,this.high|S.high,this.unsigned)},F.xor=function(S){return a(S)||(S=d(S)),u(this.low^S.low,this.high^S.high,this.unsigned)},F.shiftLeft=function(S){return a(S)&&(S=S.toInt()),(S&=63)===0?this:S<32?u(this.low<<S,this.high<<S|this.low>>>32-S,this.unsigned):u(0,this.low<<S-32,this.unsigned)},F.shl=F.shiftLeft,F.shiftRight=function(S){return a(S)&&(S=S.toInt()),(S&=63)===0?this:S<32?u(this.low>>>S|this.high<<32-S,this.high>>S,this.unsigned):u(this.high>>S-32,this.high>=0?0:-1,this.unsigned)},F.shr=F.shiftRight,F.shiftRightUnsigned=function(S){if(a(S)&&(S=S.toInt()),S&=63,S===0)return this;var M=this.high;if(S<32){var W=this.low;return u(W>>>S|M<<32-S,M>>>S,this.unsigned)}else return S===32?u(M,0,this.unsigned):u(M>>>S-32,0,this.unsigned)},F.shru=F.shiftRightUnsigned,F.shr_u=F.shiftRightUnsigned,F.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},F.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},F.toBytes=function(S){return S?this.toBytesLE():this.toBytesBE()},F.toBytesLE=function(){var S=this.high,M=this.low;return[M&255,M>>>8&255,M>>>16&255,M>>>24,S&255,S>>>8&255,S>>>16&255,S>>>24]},F.toBytesBE=function(){var S=this.high,M=this.low;return[S>>>24,S>>>16&255,S>>>8&255,S&255,M>>>24,M>>>16&255,M>>>8&255,M&255]},r.fromBytes=function(S,M,W){return W?r.fromBytesLE(S,M):r.fromBytesBE(S,M)},r.fromBytesLE=function(S,M){return new r(S[0]|S[1]<<8|S[2]<<16|S[3]<<24,S[4]|S[5]<<8|S[6]<<16|S[7]<<24,M)},r.fromBytesBE=function(S,M){return new r(S[4]<<24|S[5]<<16|S[6]<<8|S[7],S[0]<<24|S[1]<<16|S[2]<<8|S[3],M)}}),hD=Ot(()=>{}),cD=Ot(()=>{}),mD=Ot((e,t)=>{(function(n,r,a){function s(u){var p=this,h=l();p.next=function(){var d=2091639*p.s0+p.c*23283064365386963e-26;return p.s0=p.s1,p.s1=p.s2,p.s2=d-(p.c=d|0)},p.c=1,p.s0=h(" "),p.s1=h(" "),p.s2=h(" "),p.s0-=h(u),p.s0<0&&(p.s0+=1),p.s1-=h(u),p.s1<0&&(p.s1+=1),p.s2-=h(u),p.s2<0&&(p.s2+=1),h=null}function i(u,p){return p.c=u.c,p.s0=u.s0,p.s1=u.s1,p.s2=u.s2,p}function o(u,p){var h=new s(u),d=p&&p.state,c=h.next;return c.int32=function(){return h.next()*4294967296|0},c.double=function(){return c()+(c()*2097152|0)*11102230246251565e-32},c.quick=c,d&&(typeof d=="object"&&i(d,h),c.state=function(){return i(h,{})}),c}function l(){var u=4022871197,p=function(h){h=String(h);for(var d=0;d<h.length;d++){u+=h.charCodeAt(d);var c=.02519603282416938*u;u=c>>>0,c-=u,c*=u,u=c>>>0,c-=u,u+=c*4294967296}return(u>>>0)*23283064365386963e-26};return p}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.alea=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),fD=Ot((e,t)=>{(function(n,r,a){function s(l){var u=this,p="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var d=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^d^d>>>8},l===(l|0)?u.x=l:p+=l;for(var h=0;h<p.length+64;h++)u.x^=p.charCodeAt(h)|0,u.next()}function i(l,u){return u.x=l.x,u.y=l.y,u.z=l.z,u.w=l.w,u}function o(l,u){var p=new s(l),h=u&&u.state,d=function(){return(p.next()>>>0)/4294967296};return d.double=function(){do var c=p.next()>>>11,m=(p.next()>>>0)/4294967296,f=(c+m)/(1<<21);while(f===0);return f},d.int32=p.next,d.quick=d,h&&(typeof h=="object"&&i(h,p),d.state=function(){return i(p,{})}),d}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.xor128=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),gD=Ot((e,t)=>{(function(n,r,a){function s(l){var u=this,p="";u.next=function(){var d=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(d^d<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,l===(l|0)?u.x=l:p+=l;for(var h=0;h<p.length+64;h++)u.x^=p.charCodeAt(h)|0,h==p.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function i(l,u){return u.x=l.x,u.y=l.y,u.z=l.z,u.w=l.w,u.v=l.v,u.d=l.d,u}function o(l,u){var p=new s(l),h=u&&u.state,d=function(){return(p.next()>>>0)/4294967296};return d.double=function(){do var c=p.next()>>>11,m=(p.next()>>>0)/4294967296,f=(c+m)/(1<<21);while(f===0);return f},d.int32=p.next,d.quick=d,h&&(typeof h=="object"&&i(h,p),d.state=function(){return i(p,{})}),d}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.xorwow=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),yD=Ot((e,t)=>{(function(n,r,a){function s(l){var u=this;u.next=function(){var h=u.x,d=u.i,c,m,f;return c=h[d],c^=c>>>7,m=c^c<<24,c=h[d+1&7],m^=c^c>>>10,c=h[d+3&7],m^=c^c>>>3,c=h[d+4&7],m^=c^c<<7,c=h[d+7&7],c=c^c<<13,m^=c^c<<9,h[d]=m,u.i=d+1&7,m};function p(h,d){var c,m,f=[];if(d===(d|0))m=f[0]=d;else for(d=""+d,c=0;c<d.length;++c)f[c&7]=f[c&7]<<15^d.charCodeAt(c)+f[c+1&7]<<13;for(;f.length<8;)f.push(0);for(c=0;c<8&&f[c]===0;++c);for(c==8?m=f[7]=-1:m=f[c],h.x=f,h.i=0,c=256;c>0;--c)h.next()}p(u,l)}function i(l,u){return u.x=l.x.slice(),u.i=l.i,u}function o(l,u){l==null&&(l=+new Date);var p=new s(l),h=u&&u.state,d=function(){return(p.next()>>>0)/4294967296};return d.double=function(){do var c=p.next()>>>11,m=(p.next()>>>0)/4294967296,f=(c+m)/(1<<21);while(f===0);return f},d.int32=p.next,d.quick=d,h&&(h.x&&i(h,p),d.state=function(){return i(p,{})}),d}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.xorshift7=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),bD=Ot((e,t)=>{(function(n,r,a){function s(l){var u=this;u.next=function(){var h=u.w,d=u.X,c=u.i,m,f;return u.w=h=h+1640531527|0,f=d[c+34&127],m=d[c=c+1&127],f^=f<<13,m^=m<<17,f^=f>>>15,m^=m>>>12,f=d[c]=f^m,u.i=c,f+(h^h>>>16)|0};function p(h,d){var c,m,f,g,y,b=[],x=128;for(d===(d|0)?(m=d,d=null):(d=d+"\0",m=0,x=Math.max(x,d.length)),f=0,g=-32;g<x;++g)d&&(m^=d.charCodeAt((g+32)%d.length)),g===0&&(y=m),m^=m<<10,m^=m>>>15,m^=m<<4,m^=m>>>13,g>=0&&(y=y+1640531527|0,c=b[g&127]^=m+y,f=c==0?f+1:0);for(f>=128&&(b[(d&&d.length||0)&127]=-1),f=127,g=4*128;g>0;--g)m=b[f+34&127],c=b[f=f+1&127],m^=m<<13,c^=c<<17,m^=m>>>15,c^=c>>>12,b[f]=m^c;h.w=y,h.X=b,h.i=f}p(u,l)}function i(l,u){return u.i=l.i,u.w=l.w,u.X=l.X.slice(),u}function o(l,u){l==null&&(l=+new Date);var p=new s(l),h=u&&u.state,d=function(){return(p.next()>>>0)/4294967296};return d.double=function(){do var c=p.next()>>>11,m=(p.next()>>>0)/4294967296,f=(c+m)/(1<<21);while(f===0);return f},d.int32=p.next,d.quick=d,h&&(h.X&&i(h,p),d.state=function(){return i(p,{})}),d}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.xor4096=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),xD=Ot((e,t)=>{(function(n,r,a){function s(l){var u=this,p="";u.next=function(){var d=u.b,c=u.c,m=u.d,f=u.a;return d=d<<25^d>>>7^c,c=c-m|0,m=m<<24^m>>>8^f,f=f-d|0,u.b=d=d<<20^d>>>12^c,u.c=c=c-m|0,u.d=m<<16^c>>>16^f,u.a=f-d|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,l===Math.floor(l)?(u.a=l/4294967296|0,u.b=l|0):p+=l;for(var h=0;h<p.length+20;h++)u.b^=p.charCodeAt(h)|0,u.next()}function i(l,u){return u.a=l.a,u.b=l.b,u.c=l.c,u.d=l.d,u}function o(l,u){var p=new s(l),h=u&&u.state,d=function(){return(p.next()>>>0)/4294967296};return d.double=function(){do var c=p.next()>>>11,m=(p.next()>>>0)/4294967296,f=(c+m)/(1<<21);while(f===0);return f},d.int32=p.next,d.quick=d,h&&(typeof h=="object"&&i(h,p),d.state=function(){return i(p,{})}),d}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.tychei=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),vD=Ot(()=>{}),wD=Ot((e,t)=>{(function(n,r,a){var s=256,i=6,o=52,l="random",u=a.pow(s,i),p=a.pow(2,o),h=p*2,d=s-1,c;function m(I,N,C){var E=[];N=N==!0?{entropy:!0}:N||{};var A=b(y(N.entropy?[I,v(r)]:I==null?x():I,3),E),R=new f(E),F=function(){for(var S=R.g(i),M=u,W=0;S<p;)S=(S+W)*s,M*=s,W=R.g(1);for(;S>=h;)S/=2,M/=2,W>>>=1;return(S+W)/M};return F.int32=function(){return R.g(4)|0},F.quick=function(){return R.g(4)/4294967296},F.double=F,b(v(R.S),r),(N.pass||C||function(S,M,W,U){return U&&(U.S&&g(U,R),S.state=function(){return g(R,{})}),W?(a[l]=S,M):S})(F,A,"global"in N?N.global:this==a,N.state)}function f(I){var N,C=I.length,E=this,A=0,R=E.i=E.j=0,F=E.S=[];for(C||(I=[C++]);A<s;)F[A]=A++;for(A=0;A<s;A++)F[A]=F[R=d&R+I[A%C]+(N=F[A])],F[R]=N;(E.g=function(S){for(var M,W=0,U=E.i,H=E.j,q=E.S;S--;)M=q[U=d&U+1],W=W*s+q[d&(q[U]=q[H=d&H+M])+(q[H]=M)];return E.i=U,E.j=H,W})(s)}function g(I,N){return N.i=I.i,N.j=I.j,N.S=I.S.slice(),N}function y(I,N){var C=[],E=typeof I,A;if(N&&E=="object")for(A in I)try{C.push(y(I[A],N-1))}catch{}return C.length?C:E=="string"?I:I+"\0"}function b(I,N){for(var C=I+"",E,A=0;A<C.length;)N[d&A]=d&(E^=N[d&A]*19)+C.charCodeAt(A++);return v(N)}function x(){try{var I;return c&&(I=c.randomBytes)?I=I(s):(I=new Uint8Array(s),(n.crypto||n.msCrypto).getRandomValues(I)),v(I)}catch{var N=n.navigator,C=N&&N.plugins;return[+new Date,n,C,n.screen,v(r)]}}function v(I){return String.fromCharCode.apply(0,I)}if(b(a.random(),r),typeof t=="object"&&t.exports){t.exports=m;try{c=vD()}catch{}}else typeof define=="function"&&define.amd?define(function(){return m}):a["seed"+l]=m})(typeof self!="undefined"?self:e,[],Math)}),Cc=Ot((e,t)=>{var n=mD(),r=fD(),a=gD(),s=yD(),i=bD(),o=xD(),l=wD();l.alea=n,l.xor128=r,l.xorwow=a,l.xorshift7=s,l.xor4096=i,l.tychei=o,t.exports=l}),YI=Ot(()=>{}),Nx=Ot(()=>{}),QI=Ot(()=>{}),kD=Ot(()=>{}),ID=Ot(()=>{}),SD=Ot(()=>{}),ND=Ot((e,t)=>{var n=(()=>{var r=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename!="undefined"&&(r=r||__filename),function(a){a=a||{};function s(){return ue.buffer!=Ae&&st(ue.buffer),ct}function i(){return ue.buffer!=Ae&&st(ue.buffer),Mn}function o(){return ue.buffer!=Ae&&st(ue.buffer),Et}function l(){return ue.buffer!=Ae&&st(ue.buffer),tn}function u(){return ue.buffer!=Ae&&st(ue.buffer),Sn}function p(){return ue.buffer!=Ae&&st(ue.buffer),Zn}function h(){return ue.buffer!=Ae&&st(ue.buffer),Nn}var d=typeof a!="undefined"?a:{},c,m;d.ready=new Promise(function(D,j){c=D,m=j});var f;typeof process!="undefined"&&process.listeners&&(f={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var g=Object.assign({},d),y=[],b="./this.program",x=(D,j)=>{throw j},v=typeof window=="object",I=typeof importScripts=="function",N=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",C=d.ENVIRONMENT_IS_PTHREAD||!1,E="";function A(D){return d.locateFile?d.locateFile(D,E):E+D}var R,F,S,M;function W(D){D instanceof ks||Y("exiting due to exception: "+D)}if(N){var U=Nx(),H=QI();I?E=H.dirname(E)+"/":E=__dirname+"/",R=(j,le)=>(j=Wo(j)?new URL(j):H.normalize(j),U.readFileSync(j,le?void 0:"utf8")),S=j=>{var le=R(j,!0);return le.buffer||(le=new Uint8Array(le)),le},F=(j,le,Ne)=>{j=Wo(j)?new URL(j):H.normalize(j),U.readFile(j,function(Fe,$e){Fe?Ne(Fe):le($e.buffer)})},process.argv.length>1&&(b=process.argv[1].replace(/\\/g,"/")),y=process.argv.slice(2),process.on("uncaughtException",function(j){if(!(j instanceof ks))throw j}),process.on("unhandledRejection",function(j){throw j}),x=(j,le)=>{if(pr())throw process.exitCode=j,le;W(le),process.exit(j)},d.inspect=function(){return"[Emscripten Module object]"};let D;try{D=kD()}catch(j){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),j}global.Worker=D.Worker}else(v||I)&&(I?E=self.location.href:typeof document!="undefined"&&document.currentScript&&(E=document.currentScript.src),typeof r!="undefined"&&r&&(E=r),E.indexOf("blob:")!==0?E=E.substr(0,E.replace(/[?#].*/,"").lastIndexOf("/")+1):E="",N||(R=D=>{var j=new XMLHttpRequest;return j.open("GET",D,!1),j.send(null),j.responseText},I&&(S=D=>{var j=new XMLHttpRequest;return j.open("GET",D,!1),j.responseType="arraybuffer",j.send(null),new Uint8Array(j.response)}),F=(D,j,le)=>{var Ne=new XMLHttpRequest;Ne.open("GET",D,!0),Ne.responseType="arraybuffer",Ne.onload=()=>{if(Ne.status==200||Ne.status==0&&Ne.response){j(Ne.response);return}le()},Ne.onerror=le,Ne.send(null)}),M=D=>document.title=D);N&&typeof performance=="undefined"&&(global.performance=ID().performance);var q=console.log.bind(console),K=console.warn.bind(console);N&&(q=D=>U.writeSync(1,D+`
`),K=D=>U.writeSync(2,D+`
`));var J=d.print||q,Y=d.printErr||K;Object.assign(d,g),g=null,d.arguments&&(y=d.arguments),d.thisProgram&&(b=d.thisProgram),d.quit&&(x=d.quit);var ee=4,re=Atomics.load,te=Atomics.store,ae=Atomics.compareExchange,se;d.wasmBinary&&(se=d.wasmBinary);var xe=d.noExitRuntime||!0;typeof WebAssembly!="object"&&ws("no native wasm support detected");var ue,be,ke=!1,Se;function Le(D,j){D||ws(j)}var We=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):void 0;function pt(D,j,le){j>>>=0;for(var Ne=j+le,Fe=j;D[Fe]&&!(Fe>=Ne);)++Fe;if(Fe-j>16&&D.buffer&&We)return We.decode(D.buffer instanceof SharedArrayBuffer?D.slice(j,Fe):D.subarray(j,Fe));for(var $e="";j<Fe;){var me=D[j++];if(!(me&128)){$e+=String.fromCharCode(me);continue}var we=D[j++]&63;if((me&224)==192){$e+=String.fromCharCode((me&31)<<6|we);continue}var wt=D[j++]&63;if((me&240)==224?me=(me&15)<<12|we<<6|wt:me=(me&7)<<18|we<<12|wt<<6|D[j++]&63,me<65536)$e+=String.fromCharCode(me);else{var Yn=me-65536;$e+=String.fromCharCode(55296|Yn>>10,56320|Yn&1023)}}return $e}function Ye(D,j){return D>>>=0,D?pt(i(),D,j):""}function Ze(D,j,le,Ne){if(le>>>=0,!(Ne>0))return 0;for(var Fe=le,$e=le+Ne-1,me=0;me<D.length;++me){var we=D.charCodeAt(me);if(we>=55296&&we<=57343){var wt=D.charCodeAt(++me);we=65536+((we&1023)<<10)|wt&1023}if(we<=127){if(le>=$e)break;j[le++>>>0]=we}else if(we<=2047){if(le+1>=$e)break;j[le++>>>0]=192|we>>6,j[le++>>>0]=128|we&63}else if(we<=65535){if(le+2>=$e)break;j[le++>>>0]=224|we>>12,j[le++>>>0]=128|we>>6&63,j[le++>>>0]=128|we&63}else{if(le+3>=$e)break;j[le++>>>0]=240|we>>18,j[le++>>>0]=128|we>>12&63,j[le++>>>0]=128|we>>6&63,j[le++>>>0]=128|we&63}}return j[le>>>0]=0,le-Fe}function Je(D,j,le){return Ze(D,i(),j,le)}var Ae,ct,Mn,Et,Xn,tn,Sn,Zn,Nn;C&&(Ae=d.buffer);function st(D){Ae=D,d.HEAP8=ct=new Int8Array(D),d.HEAP16=Et=new Int16Array(D),d.HEAP32=tn=new Int32Array(D),d.HEAPU8=Mn=new Uint8Array(D),d.HEAPU16=Xn=new Uint16Array(D),d.HEAPU32=Sn=new Uint32Array(D),d.HEAPF32=Zn=new Float32Array(D),d.HEAPF64=Nn=new Float64Array(D)}var Tn=d.INITIAL_MEMORY||16777216;if(C)ue=d.wasmMemory,Ae=d.buffer;else if(d.wasmMemory)ue=d.wasmMemory;else if(ue=new WebAssembly.Memory({initial:Tn/65536,maximum:65536,shared:!0}),!(ue.buffer instanceof SharedArrayBuffer))throw Y("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),N&&Y("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");ue&&(Ae=ue.buffer),Tn=Ae.byteLength,st(Ae);var On,ta=[],Po=[],Rr=[],Xu=!1;function pr(){return xe}function Sa(){if(d.preRun)for(typeof d.preRun=="function"&&(d.preRun=[d.preRun]);d.preRun.length;)ff(d.preRun.shift());Ju(ta)}function Gt(){Xu=!0,!C&&Ju(Po)}function Zd(){if(!C){if(d.postRun)for(typeof d.postRun=="function"&&(d.postRun=[d.postRun]);d.postRun.length;)ek(d.postRun.shift());Ju(Rr)}}function ff(D){ta.unshift(D)}function gf(D){Po.unshift(D)}function ek(D){Rr.unshift(D)}var Na=0,Bo=null,na=null;function yf(D){Na++,d.monitorRunDependencies&&d.monitorRunDependencies(Na)}function Jd(D){if(Na--,d.monitorRunDependencies&&d.monitorRunDependencies(Na),Na==0&&(Bo!==null&&(clearInterval(Bo),Bo=null),na)){var j=na;na=null,j()}}function ws(D){d.onAbort&&d.onAbort(D),D="Aborted("+D+")",Y(D),ke=!0,Se=1,D+=". Build with -sASSERTIONS for more info.";var j=new WebAssembly.RuntimeError(D);throw m(j),j}var bf="data:application/octet-stream;base64,";function Yd(D){return D.startsWith(bf)}function Wo(D){return D.startsWith("file://")}var ln;ln="tfjs-backend-wasm-threaded-simd.wasm",Yd(ln)||(ln=A(ln));function Qd(D){try{if(D==ln&&se)return new Uint8Array(se);if(S)return S(D);throw"both async and sync fetching of the wasm failed"}catch(j){ws(j)}}function xf(){if(!se&&(v||I)){if(typeof fetch=="function"&&!Wo(ln))return fetch(ln,{credentials:"same-origin"}).then(function(D){if(!D.ok)throw"failed to load wasm binary file at '"+ln+"'";return D.arrayBuffer()}).catch(function(){return Qd(ln)});if(F)return new Promise(function(D,j){F(ln,function(le){D(new Uint8Array(le))},j)})}return Promise.resolve().then(function(){return Qd(ln)})}function vf(){var D={env:hh,wasi_snapshot_preview1:hh};function j(me,we){var wt=me.exports;if(d.asm=wt,Ef(d.asm._emscripten_tls_init),On=d.asm.__indirect_function_table,gf(d.asm.__wasm_call_ctors),be=we,!C){var Yn=Ee.unusedWorkers.length;Ee.unusedWorkers.forEach(function(aa){Ee.loadWasmModuleToWorker(aa,function(){--Yn||Jd("wasm-instantiate")})})}}C||yf("wasm-instantiate");function le(me){j(me.instance,me.module)}function Ne(me){return xf().then(function(we){return WebAssembly.instantiate(we,D)}).then(function(we){return we}).then(me,function(we){Y("failed to asynchronously prepare wasm: "+we),ws(we)})}function Fe(){return!se&&typeof WebAssembly.instantiateStreaming=="function"&&!Yd(ln)&&!Wo(ln)&&!N&&typeof fetch=="function"?fetch(ln,{credentials:"same-origin"}).then(function(me){var we=WebAssembly.instantiateStreaming(me,D);return we.then(le,function(wt){return Y("wasm streaming compile failed: "+wt),Y("falling back to ArrayBuffer instantiation"),Ne(le)})}):Ne(le)}if(d.instantiateWasm)try{var $e=d.instantiateWasm(D,j);return $e}catch(me){Y("Module.instantiateWasm callback failed with error: "+me),m(me)}return Fe().catch(m),{}}var tk,nk,eh={};function ks(D){this.name="ExitStatus",this.message="Program terminated with exit("+D+")",this.status=D}function wf(D){var j=Ee.pthreads[D];delete Ee.pthreads[D],j.terminate(),Hy(D),Ee.runningWorkers.splice(Ee.runningWorkers.indexOf(j),1),j.pthread_ptr=0}function kf(D){var j=Ee.pthreads[D];j.postMessage({cmd:"cancel"})}function Zu(D){var j=Ee.pthreads[D];Le(j),Ee.returnWorkerToPool(j)}function If(D){var j=Ee.getNewWorker();if(!j)return 6;Ee.runningWorkers.push(j),Ee.pthreads[D.pthread_ptr]=j,j.pthread_ptr=D.pthread_ptr;var le={cmd:"run",start_routine:D.startRoutine,arg:D.arg,pthread_ptr:D.pthread_ptr};return j.runPthread=()=>{N&&j.ref(),j.postMessage(le,D.transferList),delete j.runPthread},j.loaded&&j.runPthread(),0}var th={varargs:void 0,get:function(){th.varargs+=4;var D=l()[th.varargs-4>>>2];return D},getStr:function(D){var j=Ye(D);return j}};function nh(D){if(C)return Ta(1,1,D);Se=D,pr()||(Ee.terminateAllThreads(),d.onExit&&d.onExit(D),ke=!0),x(D,new ks(D))}function Sf(D,j){if(Se=D,!j&&C)throw ah(D),"unwind";nh(D)}var rh=Sf;function Nf(D){if(D instanceof ks||D=="unwind")return Se;x(1,D)}var Ee={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){C?Ee.initWorker():Ee.initMainThread()},initMainThread:function(){for(var D=8;D--;)Ee.allocateUnusedWorker()},initWorker:function(){xe=!1},setExitStatus:function(D){Se=D},terminateAllThreads:function(){for(var D of Object.values(Ee.pthreads))Ee.returnWorkerToPool(D);for(var D of Ee.unusedWorkers)D.terminate();Ee.unusedWorkers=[]},returnWorkerToPool:function(D){var j=D.pthread_ptr;delete Ee.pthreads[j],Ee.unusedWorkers.push(D),Ee.runningWorkers.splice(Ee.runningWorkers.indexOf(D),1),D.pthread_ptr=0,N&&D.unref(),Hy(j)},receiveObjectTransfer:function(D){},threadInitTLS:function(){Ee.tlsInitFunctions.forEach(D=>D())},loadWasmModuleToWorker:function(D,j){D.onmessage=$e=>{var me=$e.data,we=me.cmd;if(D.pthread_ptr&&(Ee.currentProxiedOperationCallerThread=D.pthread_ptr),me.targetThread&&me.targetThread!=bh()){var wt=Ee.pthreads[me.targetThread];wt?wt.postMessage(me,me.transferList):Y('Internal error! Worker sent a message "'+we+'" to target pthread '+me.targetThread+", but that thread no longer exists!"),Ee.currentProxiedOperationCallerThread=void 0;return}we==="processProxyingQueue"?Yu(me.queue):we==="spawnThread"?If(me):we==="cleanupThread"?Zu(me.thread):we==="killThread"?wf(me.thread):we==="cancelThread"?kf(me.thread):we==="loaded"?(D.loaded=!0,N&&D.unref(),j&&j(D),D.runPthread&&D.runPthread()):we==="print"?J("Thread "+me.threadId+": "+me.text):we==="printErr"?Y("Thread "+me.threadId+": "+me.text):we==="alert"?alert("Thread "+me.threadId+": "+me.text):me.target==="setimmediate"?D.postMessage(me):we==="callHandler"?d[me.handler](...me.args):we&&Y("worker sent an unknown command "+we),Ee.currentProxiedOperationCallerThread=void 0},D.onerror=$e=>{var me="worker sent an error!";throw Y(me+" "+$e.filename+":"+$e.lineno+": "+$e.message),$e},N&&(D.on("message",function($e){D.onmessage({data:$e})}),D.on("error",function($e){D.onerror($e)}),D.on("detachedExit",function(){}));var le=[],Ne=["onExit","onAbort","print","printErr"];for(var Fe of Ne)d.hasOwnProperty(Fe)&&le.push(Fe);D.postMessage({cmd:"load",handlers:le,urlOrBlob:d.mainScriptUrlOrBlob||r,wasmMemory:ue,wasmModule:be})},allocateUnusedWorker:function(){var D,j=A("tfjs-backend-wasm-threaded-simd.worker.js");D=new Worker(j),Ee.unusedWorkers.push(D)},getNewWorker:function(){return Ee.unusedWorkers.length==0&&(Ee.allocateUnusedWorker(),Ee.loadWasmModuleToWorker(Ee.unusedWorkers[0])),Ee.unusedWorkers.pop()}};d.PThread=Ee;function Ju(D){for(;D.length>0;)D.shift()(d)}function Tf(){var D=bh(),j=l()[D+52>>>2],le=l()[D+56>>>2],Ne=j-le;lk(j,Ne),xh(j)}d.establishStackSpace=Tf;function ah(D){if(C)return Ta(2,0,D);try{rh(D)}catch(j){Nf(j)}}var Vo=[];function Cf(D){var j=Vo[D];return j||(D>=Vo.length&&(Vo.length=D+1),Vo[D]=j=On.get(D)),j}function _f(D,j){var le=Cf(D)(j);pr()?Ee.setExitStatus(le):ok(le)}d.invokeEntryPoint=_f;function Ef(D){Ee.tlsInitFunctions.push(D)}function $f(D){ak(D,!I,1,!v),Ee.threadInitTLS()}function Af(D){C?postMessage({cmd:"cleanupThread",thread:D}):Zu(D)}function sh(D,j,le,Ne){return C?Ta(3,1,D,j,le,Ne):ih(D,j,le,Ne)}function ih(D,j,le,Ne){if(typeof SharedArrayBuffer=="undefined")return Y("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var Fe=[],$e=0;if(C&&(Fe.length===0||$e))return sh(D,j,le,Ne);if($e)return $e;var me={startRoutine:le,pthread_ptr:D,arg:Ne,transferList:Fe};return C?(me.cmd="spawnThread",postMessage(me,Fe),0):If(me)}function Ff(){return 65536}var Rf=!0;function Df(){return Rf}function Yu(D){Atomics.store(l(),D>>2,1),bh()&&ik(D),Atomics.compareExchange(l(),D>>2,1,0)}d.executeNotifiedProxyingQueue=Yu;function Mf(D,j,le,Ne){if(D==j)setTimeout(()=>Yu(Ne));else if(C)postMessage({targetThread:D,cmd:"processProxyingQueue",queue:Ne});else{var Fe=Ee.pthreads[D];if(!Fe)return;Fe.postMessage({cmd:"processProxyingQueue",queue:Ne})}return 1}function Of(D,j,le){return-1}function Lf(){ws("")}function Is(D){Is.shown||(Is.shown={}),Is.shown[D]||(Is.shown[D]=1,N&&(D="warning: "+D),Y(D))}function zf(){N||I||Is("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function Pf(){return Date.now()}function oh(){return 4294901760}function Bf(){return oh()}var Qu;N?Qu=()=>{var D=process.hrtime();return D[0]*1e3+D[1]/1e6}:Qu=()=>performance.timeOrigin+performance.now();function Wf(D,j,le){i().copyWithin(D>>>0,j>>>0,j+le>>>0)}function Vf(){return N?SD().cpus().length:navigator.hardwareConcurrency}function Uf(D){var j=jy(),le=D();return xh(j),le}function Ta(D,j){var le=arguments.length-2,Ne=arguments;return Uf(()=>{for(var Fe=le,$e=vh(Fe*8),me=$e>>3,we=0;we<le;we++){var wt=Ne[2+we];h()[me+we>>>0]=wt}return sk(D,Fe,$e,j)})}var ep=[];function Gf(D,j,le){ep.length=j;for(var Ne=le>>3,Fe=0;Fe<j;Fe++)ep[Fe]=h()[Ne+Fe>>>0];var $e=D<0,me=$e?eh[-D-1]:Qf[D];return me.apply(null,ep)}function Hf(D){try{return ue.grow(D-Ae.byteLength+65535>>>16),st(ue.buffer),1}catch{}}function jf(D){var j=i().length;if(D=D>>>0,D<=j)return!1;var le=oh();if(D>le)return!1;let Ne=(wt,Yn)=>wt+(Yn-wt%Yn)%Yn;for(var Fe=1;Fe<=4;Fe*=2){var $e=j*(1+.2/Fe);$e=Math.min($e,D+100663296);var me=Math.min(le,Ne(Math.max(D,$e),65536)),we=Hf(me);if(we)return!0}return!1}function qf(){throw"unwind"}function lh(D){return C?Ta(4,1,D):52}function uh(D,j,le,Ne,Fe){return C?Ta(5,1,D,j,le,Ne,Fe):70}var Kf=[null,[],[]];function Xf(D,j){var le=Kf[D];j===0||j===10?((D===1?J:Y)(pt(le,0)),le.length=0):le.push(j)}function ph(D,j,le,Ne){if(C)return Ta(6,1,D,j,le,Ne);for(var Fe=0,$e=0;$e<le;$e++){var me=u()[j>>>2],we=u()[j+4>>>2];j+=8;for(var wt=0;wt<we;wt++)Xf(D,i()[me+wt>>>0]);Fe+=we}return u()[Ne>>>2]=Fe,0}function dh(D){var j=d["_"+D];return j}function Zf(D,j){s().set(D,j>>>0)}function Jf(D,j,le,Ne,Fe){var $e={string:Qn=>{var jo=0;if(Qn!=null&&Qn!==0){var dk=(Qn.length<<2)+1;jo=vh(dk),Je(Qn,jo,dk)}return jo},array:Qn=>{var jo=vh(Qn.length);return Zf(Qn,jo),jo}};function me(Qn){return j==="string"?Ye(Qn):j==="boolean"?!!Qn:Qn}var we=dh(D),wt=[],Yn=0;if(Ne)for(var aa=0;aa<Ne.length;aa++){var pk=$e[le[aa]];pk?(Yn===0&&(Yn=jy()),wt[aa]=pk(Ne[aa])):wt[aa]=Ne[aa]}var qy=we.apply(null,wt);function ZR(Qn){return Yn!==0&&xh(Yn),me(Qn)}return qy=ZR(qy),qy}function Yf(D,j,le,Ne){le=le||[];var Fe=le.every(me=>me==="number"||me==="boolean"),$e=j!=="string";return $e&&Fe&&!Ne?dh(D):function(){return Jf(D,j,le,arguments,Ne)}}Ee.init();var Qf=[null,nh,ah,sh,lh,uh,ph],hh={__emscripten_init_main_thread_js:$f,__emscripten_thread_cleanup:Af,__pthread_create_js:ih,_emscripten_default_pthread_stack_size:Ff,_emscripten_get_now_is_monotonic:Df,_emscripten_notify_task_queue:Mf,_emscripten_set_offscreencanvas_size:Of,abort:Lf,emscripten_check_blocking_allowed:zf,emscripten_date_now:Pf,emscripten_get_heap_max:Bf,emscripten_get_now:Qu,emscripten_memcpy_big:Wf,emscripten_num_logical_cores:Vf,emscripten_receive_on_main_thread_js:Gf,emscripten_resize_heap:jf,emscripten_unwind_to_js_event_loop:qf,exit:rh,fd_close:lh,fd_seek:uh,fd_write:ph,memory:ue||d.wasmMemory},rk=vf(),eg=d.___wasm_call_ctors=function(){return(eg=d.___wasm_call_ctors=d.asm.__wasm_call_ctors).apply(null,arguments)},tg=d._init=function(){return(tg=d._init=d.asm.init).apply(null,arguments)},ng=d._init_with_threads_count=function(){return(ng=d._init_with_threads_count=d.asm.init_with_threads_count).apply(null,arguments)},rg=d._get_threads_count=function(){return(rg=d._get_threads_count=d.asm.get_threads_count).apply(null,arguments)},ag=d._register_tensor=function(){return(ag=d._register_tensor=d.asm.register_tensor).apply(null,arguments)},sg=d._dispose_data=function(){return(sg=d._dispose_data=d.asm.dispose_data).apply(null,arguments)},ig=d._dispose=function(){return(ig=d._dispose=d.asm.dispose).apply(null,arguments)},og=d._Abs=function(){return(og=d._Abs=d.asm.Abs).apply(null,arguments)},lg=d._Acos=function(){return(lg=d._Acos=d.asm.Acos).apply(null,arguments)},ug=d._Acosh=function(){return(ug=d._Acosh=d.asm.Acosh).apply(null,arguments)},pg=d._Add=function(){return(pg=d._Add=d.asm.Add).apply(null,arguments)},dg=d._AddN=function(){return(dg=d._AddN=d.asm.AddN).apply(null,arguments)},hg=d._All=function(){return(hg=d._All=d.asm.All).apply(null,arguments)},cg=d._Any=function(){return(cg=d._Any=d.asm.Any).apply(null,arguments)},mg=d._ArgMax=function(){return(mg=d._ArgMax=d.asm.ArgMax).apply(null,arguments)},fg=d._ArgMin=function(){return(fg=d._ArgMin=d.asm.ArgMin).apply(null,arguments)},gg=d._Asin=function(){return(gg=d._Asin=d.asm.Asin).apply(null,arguments)},yg=d._Asinh=function(){return(yg=d._Asinh=d.asm.Asinh).apply(null,arguments)},bg=d._Atan=function(){return(bg=d._Atan=d.asm.Atan).apply(null,arguments)},xg=d._Atan2=function(){return(xg=d._Atan2=d.asm.Atan2).apply(null,arguments)},vg=d._Atanh=function(){return(vg=d._Atanh=d.asm.Atanh).apply(null,arguments)},wg=d._AvgPool=function(){return(wg=d._AvgPool=d.asm.AvgPool).apply(null,arguments)},kg=d._AvgPool3D=function(){return(kg=d._AvgPool3D=d.asm.AvgPool3D).apply(null,arguments)},Ig=d._AvgPool3DGrad=function(){return(Ig=d._AvgPool3DGrad=d.asm.AvgPool3DGrad).apply(null,arguments)},Sg=d._AvgPoolGrad=function(){return(Sg=d._AvgPoolGrad=d.asm.AvgPoolGrad).apply(null,arguments)},Ng=d._BatchMatMul=function(){return(Ng=d._BatchMatMul=d.asm.BatchMatMul).apply(null,arguments)},Tg=d._Bincount=function(){return(Tg=d._Bincount=d.asm.Bincount).apply(null,arguments)},Cg=d._BitwiseAnd=function(){return(Cg=d._BitwiseAnd=d.asm.BitwiseAnd).apply(null,arguments)},_g=d._Ceil=function(){return(_g=d._Ceil=d.asm.Ceil).apply(null,arguments)},Eg=d._ClipByValue=function(){return(Eg=d._ClipByValue=d.asm.ClipByValue).apply(null,arguments)},$g=d._Conv2D=function(){return($g=d._Conv2D=d.asm.Conv2D).apply(null,arguments)},Ag=d._Conv2DBackpropInput=function(){return(Ag=d._Conv2DBackpropInput=d.asm.Conv2DBackpropInput).apply(null,arguments)},Fg=d._Conv3D=function(){return(Fg=d._Conv3D=d.asm.Conv3D).apply(null,arguments)},Rg=d._Conv3DBackpropFilterV2=function(){return(Rg=d._Conv3DBackpropFilterV2=d.asm.Conv3DBackpropFilterV2).apply(null,arguments)},Dg=d._Conv3DBackpropInputV2=function(){return(Dg=d._Conv3DBackpropInputV2=d.asm.Conv3DBackpropInputV2).apply(null,arguments)},Mg=d._Cos=function(){return(Mg=d._Cos=d.asm.Cos).apply(null,arguments)},Og=d._Cosh=function(){return(Og=d._Cosh=d.asm.Cosh).apply(null,arguments)},Lg=d._CropAndResize=function(){return(Lg=d._CropAndResize=d.asm.CropAndResize).apply(null,arguments)},zg=d._Cumprod=function(){return(zg=d._Cumprod=d.asm.Cumprod).apply(null,arguments)},Pg=d._Cumsum=function(){return(Pg=d._Cumsum=d.asm.Cumsum).apply(null,arguments)},Bg=d._DenseBincount=function(){return(Bg=d._DenseBincount=d.asm.DenseBincount).apply(null,arguments)},Wg=d._DepthToSpace=function(){return(Wg=d._DepthToSpace=d.asm.DepthToSpace).apply(null,arguments)},Vg=d._DepthwiseConv2dNative=function(){return(Vg=d._DepthwiseConv2dNative=d.asm.DepthwiseConv2dNative).apply(null,arguments)},Ug=d._Diag=function(){return(Ug=d._Diag=d.asm.Diag).apply(null,arguments)},Gg=d._Dilation2D=function(){return(Gg=d._Dilation2D=d.asm.Dilation2D).apply(null,arguments)},Hg=d._Dilation2DBackpropFilter=function(){return(Hg=d._Dilation2DBackpropFilter=d.asm.Dilation2DBackpropFilter).apply(null,arguments)},jg=d._Dilation2DBackpropInput=function(){return(jg=d._Dilation2DBackpropInput=d.asm.Dilation2DBackpropInput).apply(null,arguments)},qg=d._Elu=function(){return(qg=d._Elu=d.asm.Elu).apply(null,arguments)},Kg=d._EluGrad=function(){return(Kg=d._EluGrad=d.asm.EluGrad).apply(null,arguments)},Xg=d._Equal=function(){return(Xg=d._Equal=d.asm.Equal).apply(null,arguments)},Zg=d._Erf=function(){return(Zg=d._Erf=d.asm.Erf).apply(null,arguments)},Jg=d._Exp=function(){return(Jg=d._Exp=d.asm.Exp).apply(null,arguments)},Yg=d._Expm1=function(){return(Yg=d._Expm1=d.asm.Expm1).apply(null,arguments)},Qg=d._FlipLeftRight=function(){return(Qg=d._FlipLeftRight=d.asm.FlipLeftRight).apply(null,arguments)},ey=d._Floor=function(){return(ey=d._Floor=d.asm.Floor).apply(null,arguments)},ty=d._FloorDiv=function(){return(ty=d._FloorDiv=d.asm.FloorDiv).apply(null,arguments)},ny=d._FusedBatchNorm=function(){return(ny=d._FusedBatchNorm=d.asm.FusedBatchNorm).apply(null,arguments)},ry=d._FusedConv2D=function(){return(ry=d._FusedConv2D=d.asm.FusedConv2D).apply(null,arguments)},ay=d._FusedDepthwiseConv2D=function(){return(ay=d._FusedDepthwiseConv2D=d.asm.FusedDepthwiseConv2D).apply(null,arguments)},sy=d._Gather=function(){return(sy=d._Gather=d.asm.Gather).apply(null,arguments)},iy=d._GatherNd=function(){return(iy=d._GatherNd=d.asm.GatherNd).apply(null,arguments)},oy=d._Greater=function(){return(oy=d._Greater=d.asm.Greater).apply(null,arguments)},ly=d._GreaterEqual=function(){return(ly=d._GreaterEqual=d.asm.GreaterEqual).apply(null,arguments)},uy=d._IsFinite=function(){return(uy=d._IsFinite=d.asm.IsFinite).apply(null,arguments)},py=d._IsInf=function(){return(py=d._IsInf=d.asm.IsInf).apply(null,arguments)},dy=d._IsNan=function(){return(dy=d._IsNan=d.asm.IsNan).apply(null,arguments)},hy=d._LRN=function(){return(hy=d._LRN=d.asm.LRN).apply(null,arguments)},cy=d._LRNGrad=function(){return(cy=d._LRNGrad=d.asm.LRNGrad).apply(null,arguments)},my=d._LeakyRelu=function(){return(my=d._LeakyRelu=d.asm.LeakyRelu).apply(null,arguments)},fy=d._Less=function(){return(fy=d._Less=d.asm.Less).apply(null,arguments)},gy=d._LessEqual=function(){return(gy=d._LessEqual=d.asm.LessEqual).apply(null,arguments)},yy=d._LinSpace=function(){return(yy=d._LinSpace=d.asm.LinSpace).apply(null,arguments)},by=d._Log=function(){return(by=d._Log=d.asm.Log).apply(null,arguments)},xy=d._Log1p=function(){return(xy=d._Log1p=d.asm.Log1p).apply(null,arguments)},vy=d._LogicalAnd=function(){return(vy=d._LogicalAnd=d.asm.LogicalAnd).apply(null,arguments)},wy=d._LogicalNot=function(){return(wy=d._LogicalNot=d.asm.LogicalNot).apply(null,arguments)},ky=d._LogicalOr=function(){return(ky=d._LogicalOr=d.asm.LogicalOr).apply(null,arguments)},Iy=d._LogicalXor=function(){return(Iy=d._LogicalXor=d.asm.LogicalXor).apply(null,arguments)},Sy=d._Max=function(){return(Sy=d._Max=d.asm.Max).apply(null,arguments)},Ny=d._MaxPool=function(){return(Ny=d._MaxPool=d.asm.MaxPool).apply(null,arguments)},Ty=d._MaxPool3D=function(){return(Ty=d._MaxPool3D=d.asm.MaxPool3D).apply(null,arguments)},Cy=d._MaxPool3DGrad=function(){return(Cy=d._MaxPool3DGrad=d.asm.MaxPool3DGrad).apply(null,arguments)},_y=d._MaxPoolGrad=function(){return(_y=d._MaxPoolGrad=d.asm.MaxPoolGrad).apply(null,arguments)},Ey=d._MaxPoolWithArgmax=function(){return(Ey=d._MaxPoolWithArgmax=d.asm.MaxPoolWithArgmax).apply(null,arguments)},$y=d._Maximum=function(){return($y=d._Maximum=d.asm.Maximum).apply(null,arguments)},Ay=d._Mean=function(){return(Ay=d._Mean=d.asm.Mean).apply(null,arguments)},Fy=d._Min=function(){return(Fy=d._Min=d.asm.Min).apply(null,arguments)},Ry=d._Minimum=function(){return(Ry=d._Minimum=d.asm.Minimum).apply(null,arguments)},Dy=d._MirrorPad=function(){return(Dy=d._MirrorPad=d.asm.MirrorPad).apply(null,arguments)},My=d._Mod=function(){return(My=d._Mod=d.asm.Mod).apply(null,arguments)},Oy=d._Multinomial=function(){return(Oy=d._Multinomial=d.asm.Multinomial).apply(null,arguments)},Ly=d._Multiply=function(){return(Ly=d._Multiply=d.asm.Multiply).apply(null,arguments)},zy=d._Neg=function(){return(zy=d._Neg=d.asm.Neg).apply(null,arguments)},Py=d._NonMaxSuppressionV3=function(){return(Py=d._NonMaxSuppressionV3=d.asm.NonMaxSuppressionV3).apply(null,arguments)},By=d._NonMaxSuppressionV4=function(){return(By=d._NonMaxSuppressionV4=d.asm.NonMaxSuppressionV4).apply(null,arguments)},ch=d._NonMaxSuppressionV5=function(){return(ch=d._NonMaxSuppressionV5=d.asm.NonMaxSuppressionV5).apply(null,arguments)},mh=d._NotEqual=function(){return(mh=d._NotEqual=d.asm.NotEqual).apply(null,arguments)},tp=d._OneHot=function(){return(tp=d._OneHot=d.asm.OneHot).apply(null,arguments)},Wy=d._PadV2=function(){return(Wy=d._PadV2=d.asm.PadV2).apply(null,arguments)},Vy=d._Pow=function(){return(Vy=d._Pow=d.asm.Pow).apply(null,arguments)},Uo=d._Prelu=function(){return(Uo=d._Prelu=d.asm.Prelu).apply(null,arguments)},fh=d._Prod=function(){return(fh=d._Prod=d.asm.Prod).apply(null,arguments)},Go=d._RealDiv=function(){return(Go=d._RealDiv=d.asm.RealDiv).apply(null,arguments)},Ho=d._Reciprocal=function(){return(Ho=d._Reciprocal=d.asm.Reciprocal).apply(null,arguments)},Uy=d._Relu=function(){return(Uy=d._Relu=d.asm.Relu).apply(null,arguments)},X=d._Relu6=function(){return(X=d._Relu6=d.asm.Relu6).apply(null,arguments)},ie=d._ResizeBilinear=function(){return(ie=d._ResizeBilinear=d.asm.ResizeBilinear).apply(null,arguments)},Ie=d._ResizeBilinearGrad=function(){return(Ie=d._ResizeBilinearGrad=d.asm.ResizeBilinearGrad).apply(null,arguments)},je=d._ResizeNearestNeighbor=function(){return(je=d._ResizeNearestNeighbor=d.asm.ResizeNearestNeighbor).apply(null,arguments)},yt=d._ResizeNearestNeighborGrad=function(){return(yt=d._ResizeNearestNeighborGrad=d.asm.ResizeNearestNeighborGrad).apply(null,arguments)},bt=d._Reverse=function(){return(bt=d._Reverse=d.asm.Reverse).apply(null,arguments)},Ve=d._RotateWithOffset=function(){return(Ve=d._RotateWithOffset=d.asm.RotateWithOffset).apply(null,arguments)},Be=d._Round=function(){return(Be=d._Round=d.asm.Round).apply(null,arguments)},$t=d._Rsqrt=function(){return($t=d._Rsqrt=d.asm.Rsqrt).apply(null,arguments)},Jn=d._ScatterNd=function(){return(Jn=d._ScatterNd=d.asm.ScatterNd).apply(null,arguments)},ra=d._SearchSorted=function(){return(ra=d._SearchSorted=d.asm.SearchSorted).apply(null,arguments)},gh=d._SelectV2=function(){return(gh=d._SelectV2=d.asm.SelectV2).apply(null,arguments)},np=d._Selu=function(){return(np=d._Selu=d.asm.Selu).apply(null,arguments)},Gy=d._Sigmoid=function(){return(Gy=d._Sigmoid=d.asm.Sigmoid).apply(null,arguments)},Cn=d._Sign=function(){return(Cn=d._Sign=d.asm.Sign).apply(null,arguments)},Ca=d._Sin=function(){return(Ca=d._Sin=d.asm.Sin).apply(null,arguments)},yh=d._Sinh=function(){return(yh=d._Sinh=d.asm.Sinh).apply(null,arguments)},bR=d._Softmax=function(){return(bR=d._Softmax=d.asm.Softmax).apply(null,arguments)},xR=d._Softplus=function(){return(xR=d._Softplus=d.asm.Softplus).apply(null,arguments)},vR=d._SparseFillEmptyRows=function(){return(vR=d._SparseFillEmptyRows=d.asm.SparseFillEmptyRows).apply(null,arguments)},wR=d._SparseReshape=function(){return(wR=d._SparseReshape=d.asm.SparseReshape).apply(null,arguments)},kR=d._SparseSegmentReduction=function(){return(kR=d._SparseSegmentReduction=d.asm.SparseSegmentReduction).apply(null,arguments)},IR=d._SparseToDense=function(){return(IR=d._SparseToDense=d.asm.SparseToDense).apply(null,arguments)},SR=d._Sqrt=function(){return(SR=d._Sqrt=d.asm.Sqrt).apply(null,arguments)},NR=d._Square=function(){return(NR=d._Square=d.asm.Square).apply(null,arguments)},TR=d._SquaredDifference=function(){return(TR=d._SquaredDifference=d.asm.SquaredDifference).apply(null,arguments)},CR=d._Step=function(){return(CR=d._Step=d.asm.Step).apply(null,arguments)},_R=d._StridedSlice=function(){return(_R=d._StridedSlice=d.asm.StridedSlice).apply(null,arguments)},ER=d._Sub=function(){return(ER=d._Sub=d.asm.Sub).apply(null,arguments)},$R=d._Sum=function(){return($R=d._Sum=d.asm.Sum).apply(null,arguments)},AR=d._Tan=function(){return(AR=d._Tan=d.asm.Tan).apply(null,arguments)},FR=d._Tanh=function(){return(FR=d._Tanh=d.asm.Tanh).apply(null,arguments)},RR=d._TensorScatterUpdate=function(){return(RR=d._TensorScatterUpdate=d.asm.TensorScatterUpdate).apply(null,arguments)},DR=d._Tile=function(){return(DR=d._Tile=d.asm.Tile).apply(null,arguments)},MR=d._TopK=function(){return(MR=d._TopK=d.asm.TopK).apply(null,arguments)},OR=d._Transform=function(){return(OR=d._Transform=d.asm.Transform).apply(null,arguments)},LR=d._Transpose=function(){return(LR=d._Transpose=d.asm.Transpose).apply(null,arguments)},zR=d.__FusedMatMul=function(){return(zR=d.__FusedMatMul=d.asm._FusedMatMul).apply(null,arguments)},PR=d._malloc=function(){return(PR=d._malloc=d.asm.malloc).apply(null,arguments)},BR=d._free=function(){return(BR=d._free=d.asm.free).apply(null,arguments)},WR=d.__emscripten_tls_init=function(){return(WR=d.__emscripten_tls_init=d.asm._emscripten_tls_init).apply(null,arguments)},bh=d._pthread_self=function(){return(bh=d._pthread_self=d.asm.pthread_self).apply(null,arguments)},VR=d.___errno_location=function(){return(VR=d.___errno_location=d.asm.__errno_location).apply(null,arguments)},ak=d.__emscripten_thread_init=function(){return(ak=d.__emscripten_thread_init=d.asm._emscripten_thread_init).apply(null,arguments)},UR=d.__emscripten_thread_crashed=function(){return(UR=d.__emscripten_thread_crashed=d.asm._emscripten_thread_crashed).apply(null,arguments)},GR=d._emscripten_main_thread_process_queued_calls=function(){return(GR=d._emscripten_main_thread_process_queued_calls=d.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},HR=d._emscripten_main_browser_thread_id=function(){return(HR=d._emscripten_main_browser_thread_id=d.asm.emscripten_main_browser_thread_id).apply(null,arguments)},sk=d._emscripten_run_in_main_runtime_thread_js=function(){return(sk=d._emscripten_run_in_main_runtime_thread_js=d.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)},jR=d._emscripten_dispatch_to_thread_=function(){return(jR=d._emscripten_dispatch_to_thread_=d.asm.emscripten_dispatch_to_thread_).apply(null,arguments)},ik=d.__emscripten_proxy_execute_task_queue=function(){return(ik=d.__emscripten_proxy_execute_task_queue=d.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)},Hy=d.__emscripten_thread_free_data=function(){return(Hy=d.__emscripten_thread_free_data=d.asm._emscripten_thread_free_data).apply(null,arguments)},ok=d.__emscripten_thread_exit=function(){return(ok=d.__emscripten_thread_exit=d.asm._emscripten_thread_exit).apply(null,arguments)},lk=d._emscripten_stack_set_limits=function(){return(lk=d._emscripten_stack_set_limits=d.asm.emscripten_stack_set_limits).apply(null,arguments)},jy=d.stackSave=function(){return(jy=d.stackSave=d.asm.stackSave).apply(null,arguments)},xh=d.stackRestore=function(){return(xh=d.stackRestore=d.asm.stackRestore).apply(null,arguments)},vh=d.stackAlloc=function(){return(vh=d.stackAlloc=d.asm.stackAlloc).apply(null,arguments)},qR=d.dynCall_iijjiiii=function(){return(qR=d.dynCall_iijjiiii=d.asm.dynCall_iijjiiii).apply(null,arguments)},KR=d.dynCall_jiji=function(){return(KR=d.dynCall_jiji=d.asm.dynCall_jiji).apply(null,arguments)};d.keepRuntimeAlive=pr,d.wasmMemory=ue,d.cwrap=Yf,d.ExitStatus=ks,d.PThread=Ee;var wh;na=function D(){wh||uk(),wh||(na=D)};function uk(D){if(D=D||y,Na>0)return;if(C){c(d),Gt(),startWorker(d);return}if(Sa(),Na>0)return;function j(){wh||(wh=!0,d.calledRun=!0,!ke&&(Gt(),c(d),d.onRuntimeInitialized&&d.onRuntimeInitialized(),Zd()))}d.setStatus?(d.setStatus("Running..."),setTimeout(function(){setTimeout(function(){d.setStatus("")},1),j()},1)):j()}if(d.preInit)for(typeof d.preInit=="function"&&(d.preInit=[d.preInit]);d.preInit.length>0;)d.preInit.pop()();uk();var kh;f&&(kh={uncaughtException:process.listeners("uncaughtException").filter(function(D){return!f.uncaughtException.indexOf(D)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(D){return!f.unhandledRejection.indexOf(D)>-1})});var Ih;if(typeof WasmBackendModule!="undefined")Ih=WasmBackendModule;else if(typeof a!="undefined")Ih=a;else throw new Error("Could not find wasm module in post.js");if(kh){var XR=Ih._dispose;Ih._dispose=function(){XR(),kh.uncaughtException.forEach(function(D){process.removeListener("uncaughtException",D)}),kh.unhandledRejection.forEach(function(D){process.removeListener("unhandledRejection",D)})}}return a.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModuleThreadedSimd=n)}),TD=Ot((e,t)=>{t.exports.wasmWorkerContents=`"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};`}),CD=Ot((e,t)=>{var n=(()=>{var r=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename!="undefined"&&(r=r||__filename),function(a){a=a||{};var s=typeof a!="undefined"?a:{},i,o;s.ready=new Promise(function(X,ie){i=X,o=ie});var l;typeof process!="undefined"&&process.listeners&&(l={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var u=Object.assign({},s),p=[],h="./this.program",d=(X,ie)=>{throw ie},c=typeof window=="object",m=typeof importScripts=="function",f=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",g="";function y(X){return s.locateFile?s.locateFile(X,g):g+X}var b,x,v,I;function N(X){X instanceof Bo||R("exiting due to exception: "+X)}if(f){var C=Nx(),E=QI();m?g=E.dirname(g)+"/":g=__dirname+"/",b=(X,ie)=>(X=Sa(X)?new URL(X):E.normalize(X),C.readFileSync(X,ie?void 0:"utf8")),v=X=>{var ie=b(X,!0);return ie.buffer||(ie=new Uint8Array(ie)),ie},x=(X,ie,Ie)=>{X=Sa(X)?new URL(X):E.normalize(X),C.readFile(X,function(je,yt){je?Ie(je):ie(yt.buffer)})},process.argv.length>1&&(h=process.argv[1].replace(/\\/g,"/")),p=process.argv.slice(2),process.on("uncaughtException",function(X){if(!(X instanceof Bo))throw X}),process.on("unhandledRejection",function(X){throw X}),d=(X,ie)=>{if(Mn())throw process.exitCode=X,ie;N(ie),process.exit(X)},s.inspect=function(){return"[Emscripten Module object]"}}else(c||m)&&(m?g=self.location.href:typeof document!="undefined"&&document.currentScript&&(g=document.currentScript.src),r&&(g=r),g.indexOf("blob:")!==0?g=g.substr(0,g.replace(/[?#].*/,"").lastIndexOf("/")+1):g="",b=X=>{var ie=new XMLHttpRequest;return ie.open("GET",X,!1),ie.send(null),ie.responseText},m&&(v=X=>{var ie=new XMLHttpRequest;return ie.open("GET",X,!1),ie.responseType="arraybuffer",ie.send(null),new Uint8Array(ie.response)}),x=(X,ie,Ie)=>{var je=new XMLHttpRequest;je.open("GET",X,!0),je.responseType="arraybuffer",je.onload=()=>{if(je.status==200||je.status==0&&je.response){ie(je.response);return}Ie()},je.onerror=Ie,je.send(null)},I=X=>document.title=X);var A=s.print||console.log.bind(console),R=s.printErr||console.warn.bind(console);Object.assign(s,u),u=null,s.arguments&&(p=s.arguments),s.thisProgram&&(h=s.thisProgram),s.quit&&(d=s.quit);var F=4,S;s.wasmBinary&&(S=s.wasmBinary);var M=s.noExitRuntime||!0;typeof WebAssembly!="object"&&Rr("no native wasm support detected");var W,U=!1,H;function q(X,ie){X||Rr(ie)}var K=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):void 0;function J(X,ie,Ie){ie>>>=0;for(var je=ie+Ie,yt=ie;X[yt]&&!(yt>=je);)++yt;if(yt-ie>16&&X.buffer&&K)return K.decode(X.subarray(ie,yt));for(var bt="";ie<yt;){var Ve=X[ie++];if(!(Ve&128)){bt+=String.fromCharCode(Ve);continue}var Be=X[ie++]&63;if((Ve&224)==192){bt+=String.fromCharCode((Ve&31)<<6|Be);continue}var $t=X[ie++]&63;if((Ve&240)==224?Ve=(Ve&15)<<12|Be<<6|$t:Ve=(Ve&7)<<18|Be<<12|$t<<6|X[ie++]&63,Ve<65536)bt+=String.fromCharCode(Ve);else{var Jn=Ve-65536;bt+=String.fromCharCode(55296|Jn>>10,56320|Jn&1023)}}return bt}function Y(X,ie){return X>>>=0,X?J(se,X,ie):""}function ee(X,ie,Ie,je){if(Ie>>>=0,!(je>0))return 0;for(var yt=Ie,bt=Ie+je-1,Ve=0;Ve<X.length;++Ve){var Be=X.charCodeAt(Ve);if(Be>=55296&&Be<=57343){var $t=X.charCodeAt(++Ve);Be=65536+((Be&1023)<<10)|$t&1023}if(Be<=127){if(Ie>=bt)break;ie[Ie++>>>0]=Be}else if(Be<=2047){if(Ie+1>=bt)break;ie[Ie++>>>0]=192|Be>>6,ie[Ie++>>>0]=128|Be&63}else if(Be<=65535){if(Ie+2>=bt)break;ie[Ie++>>>0]=224|Be>>12,ie[Ie++>>>0]=128|Be>>6&63,ie[Ie++>>>0]=128|Be&63}else{if(Ie+3>=bt)break;ie[Ie++>>>0]=240|Be>>18,ie[Ie++>>>0]=128|Be>>12&63,ie[Ie++>>>0]=128|Be>>6&63,ie[Ie++>>>0]=128|Be&63}}return ie[Ie>>>0]=0,Ie-yt}function re(X,ie,Ie){return ee(X,se,ie,Ie)}var te,ae,se,xe,ue,be,ke,Se,Le;function We(X){te=X,s.HEAP8=ae=new Int8Array(X),s.HEAP16=xe=new Int16Array(X),s.HEAP32=be=new Int32Array(X),s.HEAPU8=se=new Uint8Array(X),s.HEAPU16=ue=new Uint16Array(X),s.HEAPU32=ke=new Uint32Array(X),s.HEAPF32=Se=new Float32Array(X),s.HEAPF64=Le=new Float64Array(X)}var pt=s.INITIAL_MEMORY||16777216,Ye,Ze=[],Je=[],Ae=[],ct=!1;function Mn(){return M}function Et(){if(s.preRun)for(typeof s.preRun=="function"&&(s.preRun=[s.preRun]);s.preRun.length;)Sn(s.preRun.shift());na(Ze)}function Xn(){ct=!0,na(Je)}function tn(){if(s.postRun)for(typeof s.postRun=="function"&&(s.postRun=[s.postRun]);s.postRun.length;)Nn(s.postRun.shift());na(Ae)}function Sn(X){Ze.unshift(X)}function Zn(X){Je.unshift(X)}function Nn(X){Ae.unshift(X)}var st=0,Tn=null,On=null;function ta(X){st++,s.monitorRunDependencies&&s.monitorRunDependencies(st)}function Po(X){if(st--,s.monitorRunDependencies&&s.monitorRunDependencies(st),st==0&&(Tn!==null&&(clearInterval(Tn),Tn=null),On)){var ie=On;On=null,ie()}}function Rr(X){s.onAbort&&s.onAbort(X),X="Aborted("+X+")",R(X),U=!0,H=1,X+=". Build with -sASSERTIONS for more info.";var ie=new WebAssembly.RuntimeError(X);throw o(ie),ie}var Xu="data:application/octet-stream;base64,";function pr(X){return X.startsWith(Xu)}function Sa(X){return X.startsWith("file://")}var Gt;Gt="tfjs-backend-wasm.wasm",pr(Gt)||(Gt=y(Gt));function Zd(X){try{if(X==Gt&&S)return new Uint8Array(S);if(v)return v(X);throw"both async and sync fetching of the wasm failed"}catch(ie){Rr(ie)}}function ff(){if(!S&&(c||m)){if(typeof fetch=="function"&&!Sa(Gt))return fetch(Gt,{credentials:"same-origin"}).then(function(X){if(!X.ok)throw"failed to load wasm binary file at '"+Gt+"'";return X.arrayBuffer()}).catch(function(){return Zd(Gt)});if(x)return new Promise(function(X,ie){x(Gt,function(Ie){X(new Uint8Array(Ie))},ie)})}return Promise.resolve().then(function(){return Zd(Gt)})}function gf(){var X={env:Zu,wasi_snapshot_preview1:Zu};function ie(Ve,Be){var $t=Ve.exports;s.asm=$t,W=s.asm.memory,We(W.buffer),Ye=s.asm.__indirect_function_table,Zn(s.asm.__wasm_call_ctors),Po("wasm-instantiate")}ta("wasm-instantiate");function Ie(Ve){ie(Ve.instance)}function je(Ve){return ff().then(function(Be){return WebAssembly.instantiate(Be,X)}).then(function(Be){return Be}).then(Ve,function(Be){R("failed to asynchronously prepare wasm: "+Be),Rr(Be)})}function yt(){return!S&&typeof WebAssembly.instantiateStreaming=="function"&&!pr(Gt)&&!Sa(Gt)&&!f&&typeof fetch=="function"?fetch(Gt,{credentials:"same-origin"}).then(function(Ve){var Be=WebAssembly.instantiateStreaming(Ve,X);return Be.then(Ie,function($t){return R("wasm streaming compile failed: "+$t),R("falling back to ArrayBuffer instantiation"),je(Ie)})}):je(Ie)}if(s.instantiateWasm)try{var bt=s.instantiateWasm(X,ie);return bt}catch(Ve){R("Module.instantiateWasm callback failed with error: "+Ve),o(Ve)}return yt().catch(o),{}}var ek,Na;function Bo(X){this.name="ExitStatus",this.message="Program terminated with exit("+X+")",this.status=X}function na(X){for(;X.length>0;)X.shift()(s)}function yf(){Rr("")}function Jd(){return 4294901760}function ws(){return Jd()}function bf(X,ie,Ie){se.copyWithin(X>>>0,ie>>>0,ie+Ie>>>0)}function Yd(X){try{return W.grow(X-te.byteLength+65535>>>16),We(W.buffer),1}catch{}}function Wo(X){var ie=se.length;X=X>>>0;var Ie=Jd();if(X>Ie)return!1;let je=($t,Jn)=>$t+(Jn-$t%Jn)%Jn;for(var yt=1;yt<=4;yt*=2){var bt=ie*(1+.2/yt);bt=Math.min(bt,X+100663296);var Ve=Math.min(Ie,je(Math.max(X,bt),65536)),Be=Yd(Ve);if(Be)return!0}return!1}var ln={varargs:void 0,get:function(){ln.varargs+=4;var X=be[ln.varargs-4>>>2];return X},getStr:function(X){var ie=Y(X);return ie}};function Qd(X){return 52}function xf(X,ie,Ie,je,yt){return 70}var vf=[null,[],[]];function tk(X,ie){var Ie=vf[X];ie===0||ie===10?((X===1?A:R)(J(Ie,0)),Ie.length=0):Ie.push(ie)}function nk(X,ie,Ie,je){for(var yt=0,bt=0;bt<Ie;bt++){var Ve=ke[ie>>>2],Be=ke[ie+4>>>2];ie+=8;for(var $t=0;$t<Be;$t++)tk(X,se[Ve+$t>>>0]);yt+=Be}return ke[je>>>2]=yt,0}function eh(X){var ie=s["_"+X];return ie}function ks(X,ie){ae.set(X,ie>>>0)}function wf(X,ie,Ie,je,yt){var bt={string:Cn=>{var Ca=0;if(Cn!=null&&Cn!==0){var yh=(Cn.length<<2)+1;Ca=tp(yh),re(Cn,Ca,yh)}return Ca},array:Cn=>{var Ca=tp(Cn.length);return ks(Cn,Ca),Ca}};function Ve(Cn){return ie==="string"?Y(Cn):ie==="boolean"?!!Cn:Cn}var Be=eh(X),$t=[],Jn=0;if(je)for(var ra=0;ra<je.length;ra++){var gh=bt[Ie[ra]];gh?(Jn===0&&(Jn=ch()),$t[ra]=gh(je[ra])):$t[ra]=je[ra]}var np=Be.apply(null,$t);function Gy(Cn){return Jn!==0&&mh(Jn),Ve(Cn)}return np=Gy(np),np}function kf(X,ie,Ie,je){Ie=Ie||[];var yt=Ie.every(Ve=>Ve==="number"||Ve==="boolean"),bt=ie!=="string";return bt&&yt&&!je?eh(X):function(){return wf(X,ie,Ie,arguments,je)}}var Zu={abort:yf,emscripten_get_heap_max:ws,emscripten_memcpy_big:bf,emscripten_resize_heap:Wo,fd_close:Qd,fd_seek:xf,fd_write:nk},If=gf(),th=s.___wasm_call_ctors=function(){return(th=s.___wasm_call_ctors=s.asm.__wasm_call_ctors).apply(null,arguments)},nh=s._init=function(){return(nh=s._init=s.asm.init).apply(null,arguments)},Sf=s._init_with_threads_count=function(){return(Sf=s._init_with_threads_count=s.asm.init_with_threads_count).apply(null,arguments)},rh=s._get_threads_count=function(){return(rh=s._get_threads_count=s.asm.get_threads_count).apply(null,arguments)},Nf=s._register_tensor=function(){return(Nf=s._register_tensor=s.asm.register_tensor).apply(null,arguments)},Ee=s._dispose_data=function(){return(Ee=s._dispose_data=s.asm.dispose_data).apply(null,arguments)},Ju=s._dispose=function(){return(Ju=s._dispose=s.asm.dispose).apply(null,arguments)},Tf=s._Abs=function(){return(Tf=s._Abs=s.asm.Abs).apply(null,arguments)},ah=s._Acos=function(){return(ah=s._Acos=s.asm.Acos).apply(null,arguments)},Vo=s._Acosh=function(){return(Vo=s._Acosh=s.asm.Acosh).apply(null,arguments)},Cf=s._Add=function(){return(Cf=s._Add=s.asm.Add).apply(null,arguments)},_f=s._AddN=function(){return(_f=s._AddN=s.asm.AddN).apply(null,arguments)},Ef=s._All=function(){return(Ef=s._All=s.asm.All).apply(null,arguments)},$f=s._Any=function(){return($f=s._Any=s.asm.Any).apply(null,arguments)},Af=s._ArgMax=function(){return(Af=s._ArgMax=s.asm.ArgMax).apply(null,arguments)},sh=s._ArgMin=function(){return(sh=s._ArgMin=s.asm.ArgMin).apply(null,arguments)},ih=s._Asin=function(){return(ih=s._Asin=s.asm.Asin).apply(null,arguments)},Ff=s._Asinh=function(){return(Ff=s._Asinh=s.asm.Asinh).apply(null,arguments)},Rf=s._Atan=function(){return(Rf=s._Atan=s.asm.Atan).apply(null,arguments)},Df=s._Atan2=function(){return(Df=s._Atan2=s.asm.Atan2).apply(null,arguments)},Yu=s._Atanh=function(){return(Yu=s._Atanh=s.asm.Atanh).apply(null,arguments)},Mf=s._AvgPool=function(){return(Mf=s._AvgPool=s.asm.AvgPool).apply(null,arguments)},Of=s._AvgPool3D=function(){return(Of=s._AvgPool3D=s.asm.AvgPool3D).apply(null,arguments)},Lf=s._AvgPool3DGrad=function(){return(Lf=s._AvgPool3DGrad=s.asm.AvgPool3DGrad).apply(null,arguments)},Is=s._AvgPoolGrad=function(){return(Is=s._AvgPoolGrad=s.asm.AvgPoolGrad).apply(null,arguments)},zf=s._BatchMatMul=function(){return(zf=s._BatchMatMul=s.asm.BatchMatMul).apply(null,arguments)},Pf=s._Bincount=function(){return(Pf=s._Bincount=s.asm.Bincount).apply(null,arguments)},oh=s._BitwiseAnd=function(){return(oh=s._BitwiseAnd=s.asm.BitwiseAnd).apply(null,arguments)},Bf=s._Ceil=function(){return(Bf=s._Ceil=s.asm.Ceil).apply(null,arguments)},Qu=s._ClipByValue=function(){return(Qu=s._ClipByValue=s.asm.ClipByValue).apply(null,arguments)},Wf=s._Conv2D=function(){return(Wf=s._Conv2D=s.asm.Conv2D).apply(null,arguments)},Vf=s._Conv2DBackpropInput=function(){return(Vf=s._Conv2DBackpropInput=s.asm.Conv2DBackpropInput).apply(null,arguments)},Uf=s._Conv3D=function(){return(Uf=s._Conv3D=s.asm.Conv3D).apply(null,arguments)},Ta=s._Conv3DBackpropFilterV2=function(){return(Ta=s._Conv3DBackpropFilterV2=s.asm.Conv3DBackpropFilterV2).apply(null,arguments)},ep=s._Conv3DBackpropInputV2=function(){return(ep=s._Conv3DBackpropInputV2=s.asm.Conv3DBackpropInputV2).apply(null,arguments)},Gf=s._Cos=function(){return(Gf=s._Cos=s.asm.Cos).apply(null,arguments)},Hf=s._Cosh=function(){return(Hf=s._Cosh=s.asm.Cosh).apply(null,arguments)},jf=s._CropAndResize=function(){return(jf=s._CropAndResize=s.asm.CropAndResize).apply(null,arguments)},qf=s._Cumprod=function(){return(qf=s._Cumprod=s.asm.Cumprod).apply(null,arguments)},lh=s._Cumsum=function(){return(lh=s._Cumsum=s.asm.Cumsum).apply(null,arguments)},uh=s._DenseBincount=function(){return(uh=s._DenseBincount=s.asm.DenseBincount).apply(null,arguments)},Kf=s._DepthToSpace=function(){return(Kf=s._DepthToSpace=s.asm.DepthToSpace).apply(null,arguments)},Xf=s._DepthwiseConv2dNative=function(){return(Xf=s._DepthwiseConv2dNative=s.asm.DepthwiseConv2dNative).apply(null,arguments)},ph=s._Diag=function(){return(ph=s._Diag=s.asm.Diag).apply(null,arguments)},dh=s._Dilation2D=function(){return(dh=s._Dilation2D=s.asm.Dilation2D).apply(null,arguments)},Zf=s._Dilation2DBackpropFilter=function(){return(Zf=s._Dilation2DBackpropFilter=s.asm.Dilation2DBackpropFilter).apply(null,arguments)},Jf=s._Dilation2DBackpropInput=function(){return(Jf=s._Dilation2DBackpropInput=s.asm.Dilation2DBackpropInput).apply(null,arguments)},Yf=s._Elu=function(){return(Yf=s._Elu=s.asm.Elu).apply(null,arguments)},Qf=s._EluGrad=function(){return(Qf=s._EluGrad=s.asm.EluGrad).apply(null,arguments)},hh=s._Equal=function(){return(hh=s._Equal=s.asm.Equal).apply(null,arguments)},rk=s._Erf=function(){return(rk=s._Erf=s.asm.Erf).apply(null,arguments)},eg=s._Exp=function(){return(eg=s._Exp=s.asm.Exp).apply(null,arguments)},tg=s._Expm1=function(){return(tg=s._Expm1=s.asm.Expm1).apply(null,arguments)},ng=s._FlipLeftRight=function(){return(ng=s._FlipLeftRight=s.asm.FlipLeftRight).apply(null,arguments)},rg=s._Floor=function(){return(rg=s._Floor=s.asm.Floor).apply(null,arguments)},ag=s._FloorDiv=function(){return(ag=s._FloorDiv=s.asm.FloorDiv).apply(null,arguments)},sg=s._FusedBatchNorm=function(){return(sg=s._FusedBatchNorm=s.asm.FusedBatchNorm).apply(null,arguments)},ig=s._FusedConv2D=function(){return(ig=s._FusedConv2D=s.asm.FusedConv2D).apply(null,arguments)},og=s._FusedDepthwiseConv2D=function(){return(og=s._FusedDepthwiseConv2D=s.asm.FusedDepthwiseConv2D).apply(null,arguments)},lg=s._Gather=function(){return(lg=s._Gather=s.asm.Gather).apply(null,arguments)},ug=s._GatherNd=function(){return(ug=s._GatherNd=s.asm.GatherNd).apply(null,arguments)},pg=s._Greater=function(){return(pg=s._Greater=s.asm.Greater).apply(null,arguments)},dg=s._GreaterEqual=function(){return(dg=s._GreaterEqual=s.asm.GreaterEqual).apply(null,arguments)},hg=s._IsFinite=function(){return(hg=s._IsFinite=s.asm.IsFinite).apply(null,arguments)},cg=s._IsInf=function(){return(cg=s._IsInf=s.asm.IsInf).apply(null,arguments)},mg=s._IsNan=function(){return(mg=s._IsNan=s.asm.IsNan).apply(null,arguments)},fg=s._LRN=function(){return(fg=s._LRN=s.asm.LRN).apply(null,arguments)},gg=s._LRNGrad=function(){return(gg=s._LRNGrad=s.asm.LRNGrad).apply(null,arguments)},yg=s._LeakyRelu=function(){return(yg=s._LeakyRelu=s.asm.LeakyRelu).apply(null,arguments)},bg=s._Less=function(){return(bg=s._Less=s.asm.Less).apply(null,arguments)},xg=s._LessEqual=function(){return(xg=s._LessEqual=s.asm.LessEqual).apply(null,arguments)},vg=s._LinSpace=function(){return(vg=s._LinSpace=s.asm.LinSpace).apply(null,arguments)},wg=s._Log=function(){return(wg=s._Log=s.asm.Log).apply(null,arguments)},kg=s._Log1p=function(){return(kg=s._Log1p=s.asm.Log1p).apply(null,arguments)},Ig=s._LogicalAnd=function(){return(Ig=s._LogicalAnd=s.asm.LogicalAnd).apply(null,arguments)},Sg=s._LogicalNot=function(){return(Sg=s._LogicalNot=s.asm.LogicalNot).apply(null,arguments)},Ng=s._LogicalOr=function(){return(Ng=s._LogicalOr=s.asm.LogicalOr).apply(null,arguments)},Tg=s._LogicalXor=function(){return(Tg=s._LogicalXor=s.asm.LogicalXor).apply(null,arguments)},Cg=s._Max=function(){return(Cg=s._Max=s.asm.Max).apply(null,arguments)},_g=s._MaxPool=function(){return(_g=s._MaxPool=s.asm.MaxPool).apply(null,arguments)},Eg=s._MaxPool3D=function(){return(Eg=s._MaxPool3D=s.asm.MaxPool3D).apply(null,arguments)},$g=s._MaxPool3DGrad=function(){return($g=s._MaxPool3DGrad=s.asm.MaxPool3DGrad).apply(null,arguments)},Ag=s._MaxPoolGrad=function(){return(Ag=s._MaxPoolGrad=s.asm.MaxPoolGrad).apply(null,arguments)},Fg=s._MaxPoolWithArgmax=function(){return(Fg=s._MaxPoolWithArgmax=s.asm.MaxPoolWithArgmax).apply(null,arguments)},Rg=s._Maximum=function(){return(Rg=s._Maximum=s.asm.Maximum).apply(null,arguments)},Dg=s._Mean=function(){return(Dg=s._Mean=s.asm.Mean).apply(null,arguments)},Mg=s._Min=function(){return(Mg=s._Min=s.asm.Min).apply(null,arguments)},Og=s._Minimum=function(){return(Og=s._Minimum=s.asm.Minimum).apply(null,arguments)},Lg=s._MirrorPad=function(){return(Lg=s._MirrorPad=s.asm.MirrorPad).apply(null,arguments)},zg=s._Mod=function(){return(zg=s._Mod=s.asm.Mod).apply(null,arguments)},Pg=s._Multinomial=function(){return(Pg=s._Multinomial=s.asm.Multinomial).apply(null,arguments)},Bg=s._Multiply=function(){return(Bg=s._Multiply=s.asm.Multiply).apply(null,arguments)},Wg=s._Neg=function(){return(Wg=s._Neg=s.asm.Neg).apply(null,arguments)},Vg=s._NonMaxSuppressionV3=function(){return(Vg=s._NonMaxSuppressionV3=s.asm.NonMaxSuppressionV3).apply(null,arguments)},Ug=s._NonMaxSuppressionV4=function(){return(Ug=s._NonMaxSuppressionV4=s.asm.NonMaxSuppressionV4).apply(null,arguments)},Gg=s._NonMaxSuppressionV5=function(){return(Gg=s._NonMaxSuppressionV5=s.asm.NonMaxSuppressionV5).apply(null,arguments)},Hg=s._NotEqual=function(){return(Hg=s._NotEqual=s.asm.NotEqual).apply(null,arguments)},jg=s._OneHot=function(){return(jg=s._OneHot=s.asm.OneHot).apply(null,arguments)},qg=s._PadV2=function(){return(qg=s._PadV2=s.asm.PadV2).apply(null,arguments)},Kg=s._Pow=function(){return(Kg=s._Pow=s.asm.Pow).apply(null,arguments)},Xg=s._Prelu=function(){return(Xg=s._Prelu=s.asm.Prelu).apply(null,arguments)},Zg=s._Prod=function(){return(Zg=s._Prod=s.asm.Prod).apply(null,arguments)},Jg=s._RealDiv=function(){return(Jg=s._RealDiv=s.asm.RealDiv).apply(null,arguments)},Yg=s._Reciprocal=function(){return(Yg=s._Reciprocal=s.asm.Reciprocal).apply(null,arguments)},Qg=s._Relu=function(){return(Qg=s._Relu=s.asm.Relu).apply(null,arguments)},ey=s._Relu6=function(){return(ey=s._Relu6=s.asm.Relu6).apply(null,arguments)},ty=s._ResizeBilinear=function(){return(ty=s._ResizeBilinear=s.asm.ResizeBilinear).apply(null,arguments)},ny=s._ResizeBilinearGrad=function(){return(ny=s._ResizeBilinearGrad=s.asm.ResizeBilinearGrad).apply(null,arguments)},ry=s._ResizeNearestNeighbor=function(){return(ry=s._ResizeNearestNeighbor=s.asm.ResizeNearestNeighbor).apply(null,arguments)},ay=s._ResizeNearestNeighborGrad=function(){return(ay=s._ResizeNearestNeighborGrad=s.asm.ResizeNearestNeighborGrad).apply(null,arguments)},sy=s._Reverse=function(){return(sy=s._Reverse=s.asm.Reverse).apply(null,arguments)},iy=s._RotateWithOffset=function(){return(iy=s._RotateWithOffset=s.asm.RotateWithOffset).apply(null,arguments)},oy=s._Round=function(){return(oy=s._Round=s.asm.Round).apply(null,arguments)},ly=s._Rsqrt=function(){return(ly=s._Rsqrt=s.asm.Rsqrt).apply(null,arguments)},uy=s._ScatterNd=function(){return(uy=s._ScatterNd=s.asm.ScatterNd).apply(null,arguments)},py=s._SearchSorted=function(){return(py=s._SearchSorted=s.asm.SearchSorted).apply(null,arguments)},dy=s._SelectV2=function(){return(dy=s._SelectV2=s.asm.SelectV2).apply(null,arguments)},hy=s._Selu=function(){return(hy=s._Selu=s.asm.Selu).apply(null,arguments)},cy=s._Sigmoid=function(){return(cy=s._Sigmoid=s.asm.Sigmoid).apply(null,arguments)},my=s._Sign=function(){return(my=s._Sign=s.asm.Sign).apply(null,arguments)},fy=s._Sin=function(){return(fy=s._Sin=s.asm.Sin).apply(null,arguments)},gy=s._Sinh=function(){return(gy=s._Sinh=s.asm.Sinh).apply(null,arguments)},yy=s._Softmax=function(){return(yy=s._Softmax=s.asm.Softmax).apply(null,arguments)},by=s._Softplus=function(){return(by=s._Softplus=s.asm.Softplus).apply(null,arguments)},xy=s._SparseFillEmptyRows=function(){return(xy=s._SparseFillEmptyRows=s.asm.SparseFillEmptyRows).apply(null,arguments)},vy=s._SparseReshape=function(){return(vy=s._SparseReshape=s.asm.SparseReshape).apply(null,arguments)},wy=s._SparseSegmentReduction=function(){return(wy=s._SparseSegmentReduction=s.asm.SparseSegmentReduction).apply(null,arguments)},ky=s._SparseToDense=function(){return(ky=s._SparseToDense=s.asm.SparseToDense).apply(null,arguments)},Iy=s._Sqrt=function(){return(Iy=s._Sqrt=s.asm.Sqrt).apply(null,arguments)},Sy=s._Square=function(){return(Sy=s._Square=s.asm.Square).apply(null,arguments)},Ny=s._SquaredDifference=function(){return(Ny=s._SquaredDifference=s.asm.SquaredDifference).apply(null,arguments)},Ty=s._Step=function(){return(Ty=s._Step=s.asm.Step).apply(null,arguments)},Cy=s._StridedSlice=function(){return(Cy=s._StridedSlice=s.asm.StridedSlice).apply(null,arguments)},_y=s._Sub=function(){return(_y=s._Sub=s.asm.Sub).apply(null,arguments)},Ey=s._Sum=function(){return(Ey=s._Sum=s.asm.Sum).apply(null,arguments)},$y=s._Tan=function(){return($y=s._Tan=s.asm.Tan).apply(null,arguments)},Ay=s._Tanh=function(){return(Ay=s._Tanh=s.asm.Tanh).apply(null,arguments)},Fy=s._TensorScatterUpdate=function(){return(Fy=s._TensorScatterUpdate=s.asm.TensorScatterUpdate).apply(null,arguments)},Ry=s._Tile=function(){return(Ry=s._Tile=s.asm.Tile).apply(null,arguments)},Dy=s._TopK=function(){return(Dy=s._TopK=s.asm.TopK).apply(null,arguments)},My=s._Transform=function(){return(My=s._Transform=s.asm.Transform).apply(null,arguments)},Oy=s._Transpose=function(){return(Oy=s._Transpose=s.asm.Transpose).apply(null,arguments)},Ly=s.__FusedMatMul=function(){return(Ly=s.__FusedMatMul=s.asm._FusedMatMul).apply(null,arguments)},zy=s._malloc=function(){return(zy=s._malloc=s.asm.malloc).apply(null,arguments)},Py=s._free=function(){return(Py=s._free=s.asm.free).apply(null,arguments)},By=s.___errno_location=function(){return(By=s.___errno_location=s.asm.__errno_location).apply(null,arguments)},ch=s.stackSave=function(){return(ch=s.stackSave=s.asm.stackSave).apply(null,arguments)},mh=s.stackRestore=function(){return(mh=s.stackRestore=s.asm.stackRestore).apply(null,arguments)},tp=s.stackAlloc=function(){return(tp=s.stackAlloc=s.asm.stackAlloc).apply(null,arguments)},Wy=s.dynCall_iijjiiii=function(){return(Wy=s.dynCall_iijjiiii=s.asm.dynCall_iijjiiii).apply(null,arguments)},Vy=s.dynCall_jiji=function(){return(Vy=s.dynCall_jiji=s.asm.dynCall_jiji).apply(null,arguments)};s.cwrap=kf;var Uo;On=function X(){Uo||fh(),Uo||(On=X)};function fh(X){if(X=X||p,st>0||(Et(),st>0))return;function ie(){Uo||(Uo=!0,s.calledRun=!0,!U&&(Xn(),i(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),tn()))}s.setStatus?(s.setStatus("Running..."),setTimeout(function(){setTimeout(function(){s.setStatus("")},1),ie()},1)):ie()}if(s.preInit)for(typeof s.preInit=="function"&&(s.preInit=[s.preInit]);s.preInit.length>0;)s.preInit.pop()();fh();var Go;l&&(Go={uncaughtException:process.listeners("uncaughtException").filter(function(X){return!l.uncaughtException.indexOf(X)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(X){return!l.unhandledRejection.indexOf(X)>-1})});var Ho;if(typeof a!="undefined")Ho=a;else if(typeof WasmBackendModuleThreadedSimd!="undefined")Ho=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(Go){var Uy=Ho._dispose;Ho._dispose=function(){Uy(),Go.uncaughtException.forEach(function(X){process.removeListener("uncaughtException",X)}),Go.unhandledRejection.forEach(function(X){process.removeListener("unhandledRejection",X)})}}return a.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModule=n)}),_c=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},Hp=class{refCount(e){return Ln("refCount")}incRef(e){return Ln("incRef")}timerAvailable(){return!0}time(e){return Ln("time")}read(e){return Ln("read")}readSync(e){return Ln("readSync")}readToGPU(e,t){return Ln("readToGPU")}numDataIds(){return Ln("numDataIds")}disposeData(e,t){return Ln("disposeData")}write(e,t,n){return Ln("write")}move(e,t,n,r,a){return Ln("move")}createTensorFromGPUData(e,t,n){return Ln("createTensorFromGPUData")}memory(){return Ln("memory")}floatPrecision(){return Ln("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return Ln("dispose")}};function Ln(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function eS(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,Jh(e,t,n)}function _D(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,Jh(e,n,r),Jh(t,n,r)}function Sp(e,t,n){return Math.max(e,Math.min(t,n))}function ED(e){return e%2===0?e:e+1}function Jh(e,t,n){let r=e[t];e[t]=e[n],e[n]=r}function $D(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function AD(e,t){let n=Math.random();return t*n+(1-n)*e}function FD(e,t){let n=0;for(let r=0;r<e.length;r++){let a=Number(e[r])-Number(t[r]);n+=a*a}return n}function $(e,t){if(!e)throw new Error(typeof t=="string"?t:t())}function vn(e,t,n=""){$(fa(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function ii(e){$(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function rt(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function RD(e){return e.length===0}function tS(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==null&&t[n]!==null&&e[n]!==t[n])return!1;return!0}function fa(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function al(e){return e%1===0}function DD(e){if(Math.tanh!=null)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function MD(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function OD(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return eS(t),t}function xp(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function LD(e,t=a=>0,n,r){return new Promise((a,s)=>{let i=0,o=()=>{if(e()){a();return}i++;let l=t(i);if(n!=null&&i>=n){s();return}r!=null?r(o,l):setTimeout(o,l)};o()})}function zD(e,t){let n=1,r=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)n*=e[s];else if(e[s]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);r=s}else if(e[s]<0)throw Error(`Shapes can not be < 0. Found ${e[s]} at dim ${s}`);if(r===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(n===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let a=e.slice();return a[r]=t/n,a}function yr(e,t){let n=t.length;return e=e==null?t.map((r,a)=>a):[].concat(e),$(e.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),$(e.every(r=>al(r)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(r=>r<0?n+r:r)}function nS(e,t){let n=[],r=[],a=t!=null&&Array.isArray(t)&&t.length===0,s=t==null||a?null:yr(t,e).sort(),i=0;for(let o=0;o<e.length;++o){if(s!=null){if(s[i]===o&&e[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(s[i]==null||s[i]>o)&&e[o]===1&&(n.push(e[o]),r.push(o)),s[i]<=o&&i++}e[o]!==1&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function rS(e,t){return Tx(e,t)}function Tx(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else if(e==="string")n=new Array(t);else throw new Error(`Unknown data type ${e}`);return n}function aS(e,t){for(let n=0;n<e.length;n++){let r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function sS(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function PD(e,t){return!(t==="complex64"||t==="float32"&&e!=="complex64"||t==="int32"&&e!=="float32"&&e!=="complex64"||t==="bool"&&e==="bool")}function Yh(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function iS(e){if(e==null)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function Oa(e){return typeof e=="string"||e instanceof String}function oS(e){return typeof e=="boolean"}function lS(e){return typeof e=="number"}function jp(e){return Array.isArray(e)?jp(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":lS(e)?"float32":Oa(e)?"string":oS(e)?"bool":"float32"}function Ha(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Qh(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function Il(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function uS(e,t,n,r=!1){let a=new Array;if(t.length===1){let s=t[0]*(r?2:1);for(let i=0;i<s;i++)a[i]=n[e+i]}else{let s=t[0],i=t.slice(1),o=i.reduce((l,u)=>l*u)*(r?2:1);for(let l=0;l<s;l++)a[l]=uS(e+l*o,i,n,r)}return a}function el(e,t,n=!1){if(e.length===0)return t[0];let r=e.reduce((a,s)=>a*s)*(n?2:1);if(r===0)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return uS(0,e,t,n)}function BD(e,t){if(Array.isArray(e))return e;if(t==="float32")return e instanceof Float32Array?e:new Float32Array(e);if(t==="int32")return e instanceof Int32Array?e:new Int32Array(e);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function Cx(e,t){let n=Ec(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function Ec(e,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function WD(e,t){let n=e.reduce((r,a)=>r*a,1);if(t==null||t==="float32")return el(e,new Float32Array(n));if(t==="int32")return el(e,new Int32Array(n));if(t==="bool")return el(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function Kn(e){e.forEach(t=>{$(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function VD(e,t,n){if(t===0)return 0;if(t===1)return e[0];let r=e[e.length-1];for(let a=0;a<e.length-1;++a)r+=n[a]*e[a];return r}function UD(e,t,n){if(t===0)return[];if(t===1)return[e];let r=new Array(t);for(let a=0;a<r.length-1;++a)r[a]=Math.floor(e/n[a]),e-=r[a]*n[a];return r[r.length-1]=e,r}function $c(e){return e&&e.then&&typeof e.then=="function"}var hk="tfjsflags",pS=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=GD,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(G().getBool("IS_TEST")||G().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){let r=this.urlFlags[e];G().getBool("IS_TEST")||G().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if($c(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;let e=this.getQueryParams(this.global.location.search);hk in e&&e[hk].split(",").forEach(t=>{let[n,r]=t.split(":");this.urlFlags[n]=jD(n,r)})}};function GD(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(HD(t,r[0],r[1]),r.join("="))),t}function HD(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function jD(e,t){let n=t.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:t}function G(){return _x}var _x=null;function qD(e){_x=e}var Xy;function dS(){if(Xy==null){let e;if(typeof window!="undefined")e=window;else if(typeof global!="undefined")e=global;else if(typeof process!="undefined")e=process;else if(typeof self!="undefined")e=self;else throw new Error("Could not find a global object");Xy=e}return Xy}function KD(){let e=dS();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function Ex(e,t){let n=KD();if(n.has(e))return n.get(e);{let r=t();return n.set(e,r),n.get(e)}}var Sl="Abs",oi="Acos",li="Acosh",is="Add",ui="AddN",Nl="All",Tl="Any",Cl="ArgMax",_l="ArgMin",pi="Asin",di="Asinh",hi="Atan",ci="Atanh",mi="Atan2",fi="AvgPool",qp="AvgPoolGrad",El="AvgPool3D",Kp="AvgPool3DGrad",gi="BatchMatMul",$l="BatchToSpaceND",Al="Bincount",Fl="BitwiseAnd",hS="BroadcastTo",Xp="BroadcastArgs",yi="Cast",bi="Ceil",os="ClipByValue",Ac="Complex",Zp="ComplexAbs",Rl="Concat",xi="Conv2D",Fc="Conv2DBackpropFilter",vi="Conv2DBackpropInput",wi="Conv3D",Dl="Conv3DBackpropFilterV2",Ml="Conv3DBackpropInputV2",ki="Cos",Ii="Cosh",Ol="Cumprod",Si="Cumsum",Ll="CropAndResize",Jp="DenseBincount",zl="DepthToSpace",Ni="DepthwiseConv2dNative",Rc="DepthwiseConv2dNativeBackpropFilter",Dc="DepthwiseConv2dNativeBackpropInput",Yp="Diag",Ti="Dilation2D",sl="Dilation2DBackpropInput",il="Dilation2DBackpropFilter",Mc="Draw",Ci="RealDiv",Oc="Einsum",_i="Elu",Pl="EluGrad",Ei="Erf",Bl="Equal",$i="Exp",Wl="ExpandDims",Ai="Expm1",Lc="FFT",Qp="Fill",Vl="FlipLeftRight",Fi="Floor",Ri="FloorDiv",Di="FusedBatchNorm",Ul="GatherV2",Gl="GatherNd",Hl="Greater",Mi="GreaterEqual",Oi="Identity",zc="IFFT",Pc="Imag",Li="IsFinite",zi="IsInf",Pi="IsNan",Bi="LeakyRelu",jl="Less",ql="LessEqual",Kl="LinSpace",Wi="Log",Vi="Log1p",Xl="LogicalAnd",Zl="LogicalNot",Jl="LogicalOr",cS="LogicalXor",mS="LogSoftmax",XD="LowerBound",Ui="LRN",Yl="LRNGrad",ZD="MatrixBandPart",Gi="Max",Hi="Maximum",ji="MaxPool",ed="MaxPoolGrad",Ql="MaxPool3D",td="MaxPool3DGrad",nd="MaxPoolWithArgmax",qi="Mean",Ki="Min",Xi="Minimum",Zi="MirrorPad",Ji="Mod",eu="Multinomial",Yi="Multiply",tu="Neg",nu="NotEqual",ru="NonMaxSuppressionV3",au="NonMaxSuppressionV4",su="NonMaxSuppressionV5",iu="OnesLike",Qi="OneHot",ou="Pack",eo="PadV2",JD="Pool",to="Pow",no="Prelu",ro="Prod",Bc="RaggedGather",Wc="RaggedRange",Vc="RaggedTensorToTensor",rd="Range",Uc="Real",ao="Reciprocal",so="Relu",lu="Reshape",io="ResizeNearestNeighbor",uu="ResizeNearestNeighborGrad",oo="ResizeBilinear",pu="ResizeBilinearGrad",lo="Relu6",uo="Reverse",po="Round",ho="Rsqrt",du="ScatterNd",hu="TensorScatterUpdate",cu="SearchSorted",mu="Select",co="Selu",fu="Slice",mo="Sin",fo="Sinh",go="Sign",yo="Sigmoid",bo="Softplus",xo="Sqrt",vo="Sum",gu="SpaceToBatchND",yu="SplitV",wo="Softmax",ad="SparseFillEmptyRows",bu="SparseReshape",sd="SparseSegmentMean",id="SparseSegmentSum",xu="SparseToDense",ko="SquaredDifference",od="Square",ld="StaticRegexReplace",vu="StridedSlice",ud="StringNGrams",pd="StringSplit",dd="StringToHashBucketFast",Io="Sub",So="Tan",No="Tanh",ls="Tile",wu="TopK",ku="Transform",ua="Transpose",hd="Unique",Iu="Unpack",cd="UnsortedSegmentSum",YD="UpperBound",Su="ZerosLike",us="Step",ec="FromPixels",Nu="RotateWithOffset",Bs="_FusedMatMul",Ws="FusedConv2D",Vs="FusedDepthwiseConv2D";function Ma(...e){G().getBool("IS_TEST")||G().getBool("PROD")||console.warn(...e)}function QD(...e){G().getBool("IS_TEST")||G().getBool("PROD")||console.log(...e)}var ol=Ex("kernelRegistry",()=>new Map),Np=Ex("gradRegistry",()=>new Map);function Tp(e,t){let n=$x(e,t);return ol.get(n)}function cb(e){return Np.get(e)}function tc(e){let t=ol.entries(),n=[];for(;;){let{done:r,value:a}=t.next();if(r)break;let[s,i]=a,[o]=s.split("_");o===e&&n.push(i)}return n}function md(e){let{kernelName:t,backendName:n}=e,r=$x(t,n);ol.has(r)&&Ma(`The kernel '${t}' for backend '${n}' is already registered`),ol.set(r,e)}function fS(e){let{kernelName:t}=e;Np.has(t)&&G().getBool("DEBUG")&&Ma(`Overriding the gradient for '${t}'`),Np.set(t,e)}function eM(e,t){let n=$x(e,t);if(!ol.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);ol.delete(n)}function tM(e){if(!Np.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);Np.delete(e)}function nM(e,t){tc(e).forEach(n=>{let r=Object.assign({},n,{backendName:t});md(r)})}function $x(e,t){return`${t}_${e}`}var w={};_e(w,{arraysEqual:()=>fa,arraysEqualWithNull:()=>tS,assert:()=>$,assertNonNegativeIntegerDimensions:()=>Kn,assertNonNull:()=>ii,assertShapesMatch:()=>vn,bytesFromStringArray:()=>iS,bytesPerElement:()=>Yh,checkConversionForErrors:()=>aS,clamp:()=>Sp,computeStrides:()=>Il,convertBackendValuesAndArrayBuffer:()=>BD,createScalarValue:()=>lM,createShuffledIndices:()=>OD,decodeString:()=>nc,distSquared:()=>FD,encodeString:()=>gd,fetch:()=>pM,fingerPrint64:()=>oM,flatten:()=>ja,getArrayFromDType:()=>Tx,getTypedArrayFromDType:()=>rS,hasEncodingLoss:()=>PD,hexToLong:()=>fd,indexToLoc:()=>UD,inferDtype:()=>jp,inferFromImplicitShape:()=>zD,isBoolean:()=>oS,isFunction:()=>Ha,isInt:()=>al,isNumber:()=>lS,isPromise:()=>$c,isScalarShape:()=>RD,isString:()=>Oa,isTypedArray:()=>Kt,isValidDtype:()=>sS,locToIndex:()=>VD,makeOnesTypedArray:()=>Cx,makeZerosNestedTypedArray:()=>WD,makeZerosTypedArray:()=>Ec,nearestDivisor:()=>Qh,nearestLargerEven:()=>ED,now:()=>Cp,parseAxisParam:()=>yr,randUniform:()=>AD,repeatedTry:()=>LD,rightPad:()=>xp,shuffle:()=>eS,shuffleCombo:()=>_D,sizeFromShape:()=>rt,sizeToSquarishShape:()=>MD,squeezeShape:()=>nS,sum:()=>$D,swap:()=>Jh,tanh:()=>DD,toNestedArray:()=>el,toTypedArray:()=>Gc});function gS(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var ck=ss(dD()),$s=ck.default||ck;function fd(e){return $s.fromString(e,!0,16)}var yS=fd("c3a5c85c97cb3127"),Cs=fd("b492b66fbe98f273"),mn=fd("9ae16a3b2f90404f");function mb(e){return e.xor(e.shru(47))}function bS(e,t,n){let r=e.slice(t,t+n);return $s.fromBytes(Array.from(r),!0,!0)}function mt(e,t){return bS(e,t,8)}function mk(e,t){return bS(e,t,4)}function qt(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function Ba(e,t,n=fd("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let a=t.xor(r).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function rM(e,t,n,r,a,s){a=a.add(e),s=qt(s.add(a).add(r),21);let i=a;return a=a.add(t),a=a.add(n),s=s.add(qt(a,44)),[a.add(r),s.add(i)]}function Sh(e,t,n,r){return rM(mt(e,t),mt(e,t+8),mt(e,t+16),mt(e,t+24),n,r)}function aM(e,t=e.length){if(t>=8){let n=mn.add(t*2),r=mt(e,0).add(mn),a=mt(e,t-8),s=qt(a,37).mul(n).add(r),i=qt(r,25).add(a).mul(n);return Ba(s,i,n)}if(t>=4){let n=mn.add(t*2),r=mk(e,0);return Ba(r.shl(3).add(t),mk(e,t-4),n)}if(t>0){let n=e[0],r=e[t>>1],a=e[t-1],s=n+(r<<8),i=t+(a<<2);return mb(mn.mul(s).xor(yS.mul(i))).mul(mn)}return mn}function sM(e,t=e.length){let n=mn.add(t*2),r=mt(e,0).mul(Cs),a=mt(e,8),s=mt(e,t-8).mul(n),i=mt(e,t-16).mul(mn);return Ba(qt(r.add(a),43).add(qt(s,30)).add(i),r.add(qt(a.add(mn),18)).add(s),n)}function iM(e,t=e.length){let n=mn.add(t*2),r=mt(e,0).mul(mn),a=mt(e,8),s=mt(e,t-8).mul(n),i=mt(e,t-16).mul(mn),o=qt(r.add(a),43).add(qt(s,30)).add(i),l=Ba(o,r.add(qt(a.add(mn),18)).add(s),n),u=mt(e,16).mul(n),p=mt(e,24),h=o.add(mt(e,t-32)).mul(n),d=l.add(mt(e,t-24)).mul(n);return Ba(qt(u.add(p),43).add(qt(h,30)).add(d),u.add(qt(p.add(r),18)).add(h),n)}function oM(e,t=e.length){let n=$s.fromNumber(81,!0);if(t<=32)return t<=16?aM(e,t):sM(e,t);if(t<=64)return iM(e,t);let r=n,a=n.mul(Cs).add(113),s=mb(a.mul(mn).add(113)).mul(mn),i=[$s.UZERO,$s.UZERO],o=[$s.UZERO,$s.UZERO];r=r.mul(mn).add(mt(e,0));let l=0,u=(t-1>>6)*64,p=u+(t-1&63)-63;do r=qt(r.add(a).add(i[0]).add(mt(e,l+8)),37).mul(Cs),a=qt(a.add(i[1]).add(mt(e,l+48)),42).mul(Cs),r=r.xor(o[1]),a=a.add(i[0]).add(mt(e,l+40)),s=qt(s.add(o[0]),33).mul(Cs),i=Sh(e,l,i[1].mul(Cs),r.add(o[0])),o=Sh(e,l+32,s.add(o[1]),a.add(mt(e,l+16))),[s,r]=[r,s],l+=64;while(l!==u);let h=Cs.add(s.and(255).shl(1));return l=p,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=qt(r.add(a).add(i[0]).add(mt(e,l+8)),37).mul(h),a=qt(a.add(i[1]).add(mt(e,l+48)),42).mul(h),r=r.xor(o[1].mul(9)),a=a.add(i[0].mul(9).add(mt(e,l+40))),s=qt(s.add(o[0]),33).mul(h),i=Sh(e,l,i[1].mul(h),r.add(o[0])),o=Sh(e,l+32,s.add(o[1]),a.add(mt(e,l+16))),[s,r]=[r,s],Ba(Ba(i[0],o[0],h).add(mb(a).mul(yS)).add(s),Ba(i[1],o[1],h).add(r),h)}function lM(e,t){return t==="string"?gd(e):Gc([e],t)}function uM(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function Gc(e,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=ja(e)),G().getBool("DEBUG")&&aS(e,t),uM(e,t))return e;if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"){let n=new Uint8Array(e.length);for(let r=0;r<n.length;++r)Math.round(e[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${t}`)}function Cp(){return G().platform.now()}function pM(e,t){return G().platform.fetch(e,t)}function gd(e,t="utf-8"){return t=t||"utf-8",G().platform.encode(e,t)}function nc(e,t="utf-8"){return t=t||"utf-8",G().platform.decode(e,t)}function Kt(e){return G().platform.isTypedArray!=null?G().platform.isTypedArray(e):gS(e)}function ja(e,t=[],n=!1){if(t==null&&(t=[]),typeof e=="boolean"||typeof e=="number"||typeof e=="string"||$c(e)||e==null||Kt(e)&&n)t.push(e);else if(Array.isArray(e)||Kt(e))for(let r=0;r<e.length;++r)ja(e[r],t,n);else{let r=-1;for(let a of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(a)&&(r=Math.max(r,Number(a)));for(let a=0;a<=r;a++)ja(e[a],t,n)}return t}var dM=class{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new cM)}profileKernel(e,t,n){let r,a=()=>{r=n()},s,i=Cp();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(a);else{a();for(let o of r)o.dataSync();s=Promise.resolve({kernelMs:Cp()-i})}if(G().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<r.length;o++){let l=r[o];l.data().then(u=>{hM(u,l.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:s.then(o=>o.kernelMs),extraInfo:s.then(o=>o.getExtraProfileInfo!=null?o.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:r,inputs:a,extraInfo:s}=e;n.forEach(i=>{Promise.all([i.data(),r,s]).then(o=>{this.logger.logKernelProfile(t,i,o[0],o[1],a,o[2])})})}};function hM(e,t,n){if(t!=="float32")return!1;for(let r=0;r<e.length;r++){let a=e[r];if(isNaN(a)||!isFinite(a))return console.warn(`Found ${a} in the result of '${n}'`),!0}return!1}var cM=class{logKernelProfile(e,t,n,r,a,s){let i=typeof r=="number"?xp(`${r}ms`,9):r.error,o=xp(e,25),l=t.rank,u=t.size,p=xp(t.shape.toString(),14),h="";for(let d in a){let c=a[d];if(c!=null){let m=c.shape||t.shape,f=m.length;h+=`${d}: ${f}D ${f>0?m:""} `}}console.log(`%c${o}	%c${i}	%c${l}D ${p}	%c${u}	%c${h}	%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function mM(e,t,n){let r={},a={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){let u=e[l],p=u.inputs;for(let h in p){let d=p[h],c=!1;for(let m=0;m<t.length;m++)if(r[d.id]){u.outputs.forEach(f=>r[f.id]=!0),c=!0,a[u.id]=!0;break}if(c)break}}let s={};s[n.id]=!0;let i={};for(let l=e.length-1;l>=0;l--){let u=e[l],p=u.inputs;for(let h=0;h<u.outputs.length;h++)if(s[u.outputs[h].id]){for(let d in p)s[p[d].id]=!0,i[u.id]=!0;break}}let o=[];for(let l=0;l<e.length;l++){let u=e[l];if(a[u.id]&&i[u.id]){let p={};for(let d in u.inputs){let c=u.inputs[d];r[c.id]&&(p[d]=c)}let h=Object.assign({},u);h.inputs=p,h.outputs=u.outputs,o.push(h)}}return o}function fM(e,t,n,r){for(let a=t.length-1;a>=0;a--){let s=t[a],i=[];if(s.outputs.forEach(l=>{let u=e[l.id];u!=null?i.push(u):i.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let o=s.gradient(i);for(let l in s.inputs){if(!(l in o))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);let u=n(()=>o[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);let p=s.inputs[l];if(!fa(u.shape,p.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${p.shape}'`);if(e[p.id]==null)e[p.id]=u;else{let h=e[p.id];e[p.id]=r(h,u),h.dispose()}}}}var fk=20,rp=3,Zy=7;function gM(e,t,n,r){let a=Il(t),s=yM(e,t,n,a),i=t.length,o=Wh(e,t,n,a,s),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map(u=>"    "+u).join(`
`)),l.join(`
`)}function yM(e,t,n,r){let a=rt(t),s=r[r.length-1],i=new Array(s).fill(0),o=t.length,l=n==="complex64"?up(e):e;if(o>1)for(let u=0;u<a/s;u++){let p=u*s;for(let h=0;h<s;h++)i[h]=Math.max(i[h],lp(l[p+h],0,n).length)}return i}function lp(e,t,n){let r;return Array.isArray(e)?r=`${parseFloat(e[0].toFixed(Zy))} + ${parseFloat(e[1].toFixed(Zy))}j`:Oa(e)?r=`'${e}'`:n==="bool"?r=xS(e):r=parseFloat(e.toFixed(Zy)).toString(),xp(r,t)}function xS(e){return e===0?"false":"true"}function Wh(e,t,n,r,a,s=!0){let i=n==="complex64"?2:1,o=t[0],l=t.length;if(l===0){if(n==="complex64"){let f=up(e);return[lp(f[0],0,n)]}return n==="bool"?[xS(e[0])]:[e[0].toString()]}if(l===1){if(o>fk){let f=rp*i,g=Array.from(e.slice(0,f)),y=Array.from(e.slice((o-rp)*i,o*i));return n==="complex64"&&(g=up(g),y=up(y)),["["+g.map((b,x)=>lp(b,a[x],n)).join(", ")+", ..., "+y.map((b,x)=>lp(b,a[o-rp+x],n)).join(", ")+"]"]}return["["+(n==="complex64"?up(e):Array.from(e)).map((f,g)=>lp(f,a[g],n)).join(", ")+"]"]}let u=t.slice(1),p=r.slice(1),h=r[0]*i,d=[];if(o>fk){for(let f=0;f<rp;f++){let g=f*h,y=g+h;d.push(...Wh(e.slice(g,y),u,n,p,a,!1))}d.push("...");for(let f=o-rp;f<o;f++){let g=f*h,y=g+h;d.push(...Wh(e.slice(g,y),u,n,p,a,f===o-1))}}else for(let f=0;f<o;f++){let g=f*h,y=g+h;d.push(...Wh(e.slice(g,y),u,n,p,a,f===o-1))}let c=l===2?",":"";d[0]="["+(o>0?d[0]+c:"");for(let f=1;f<d.length-1;f++)d[f]=" "+d[f]+c;let m=`,
`;for(let f=2;f<l;f++)m+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(s?"":m),d}function up(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var Rt=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=rt(e),n!=null){let r=n.length;$(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||Tx(t,this.size),this.strides=Il(e)}set(e,...t){t.length===0&&(t=[0]),$(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(let r of e){if(r<0||r>=this.shape[t]){let a=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(a)}t++}let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Ir().makeTensor(this.values,this.shape,this.dtype)}},Ir=null,Zo=null,bM=null;function xM(e){Ir=e}function vM(e){Zo=e}function wM(e){bM=e}var Re=class{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=rt(e),this.strides=Il(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return Zo.buffer(this.shape,this.dtype,e)}bufferSync(){return Zo.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return el(this.shape,e,this.dtype==="complex64")}arraySync(){return el(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let e=Ir().read(this.dataId);if(this.dtype==="string"){let t=await e;try{return t.map(n=>nc(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Ir().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=Ir().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>nc(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await Ir().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Ir().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Zo.print(this,e)}clone(){return this.throwIfDisposed(),Zo.clone(this)}toString(e=!1){let t=this.dataSync();return gM(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Zo.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),Ir().makeVariable(this,e,t,n)}};Object.defineProperty(Re,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function Q(){return Ex("Tensor",()=>Re)}Q();var Us=class extends Re{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!fa(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Ir().disposeTensor(this),this.dataId=e.dataId,Ir().incRef(this,null)}dispose(){Ir().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(Us,Symbol.hasInstance,{value:e=>e instanceof Re&&e.assign!=null&&e.assign instanceof Function});var Sr={};_e(Sr,{assertTypesMatch:()=>kS,getTensorsInContainer:()=>Ax,isTensorInList:()=>IM,makeTypesMatch:()=>Nt});var fb;(function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"})(fb||(fb={}));var gb;(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"})(gb||(gb={}));var yb;(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"})(yb||(yb={}));var bb;(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"})(bb||(bb={}));var xb;(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"})(xb||(xb={}));var kM={float32:bb,int32:gb,bool:yb,complex64:xb};function sr(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return kM[e][t]}function Hc(e){return sr(e,"int32")}function vS(e){return e!=null&&typeof e=="object"&&"texture"in e&&e.texture instanceof WebGLTexture}function wS(e){return typeof GPUBuffer!="undefined"&&e!=null&&typeof e=="object"&&"buffer"in e&&e.buffer instanceof GPUBuffer}function Nt(e,t){if(e.dtype===t.dtype)return[e,t];let n=sr(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function kS(e,t){$(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function IM(e,t){return t.some(n=>n.id===e.id)}function Ax(e){let t=[];return IS(e,t,new Set),t}function IS(e,t,n){if(e==null)return;if(e instanceof Re){t.push(e);return}if(!SM(e))return;let r=e;for(let a in r){let s=r[a];n.has(s)||(n.add(s),IS(s,t,n))}}function SM(e){return Array.isArray(e)||typeof e=="object"}function Jy(e){return e.kernelName!=null}var gk=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},Fx=class vb{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new gk}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let r=t[n];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:n}=this.initializeBackend(t);if(n)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,n,r=1){return t in this.registryFactory?(Ma(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:n,priority:r},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:n,asyncInit:r}=this.initializeBackend(t);if(!(r?await n:n))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new dM(this.backendInstance),!0}setupRegisteredKernels(){tc(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){tc(t).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[t])})}initializeBackend(t){let n=this.registryFactory[t];if(n==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let r=n.factory();if(r&&!(r instanceof Hp)&&typeof r.then=="function"){let a=++this.pendingBackendInitId,s=r.then(i=>a<this.pendingBackendInitId?!1:(this.registry[t]=i,this.pendingBackendInit=null,!0)).catch(i=>(a<this.pendingBackendInitId||(this.pendingBackendInit=null,Ma(`Initialization of backend ${t} failed`),Ma(i.stack||i.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[t]=r,{success:!0,asyncInit:!1}}catch(r){return Ma(`Initialization of backend ${t} failed`),Ma(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let r=t[n],{success:a,asyncInit:s}=this.initializeBackend(r);if(s||a)return{name:r,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,n){let r=this.state.tensorInfo.get(n),a=r.backend,s=this.readSync(n),i=a.refCount(n);a.disposeData(n,!0),r.backend=t,t.move(n,s,r.shape,r.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,n){let r=null;if(n==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");n=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}let a;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(a),()=>(a=n(),a instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),a))}scopedRun(t,n,r){t();try{let a=r();return n(),a}catch(a){throw n(),a}}nextTensorId(){return vb.nextTensorId++}nextVariableId(){return vb.nextVariableId++}clone(t){let n=O.runKernel(Oi,{x:t}),r={x:t},a=i=>({x:()=>{let o="float32",l={x:i},u={dtype:o};return O.runKernel(yi,l,u)}}),s=[];return this.addTapeNode(this.state.activeScope.name,r,[n],a,s,{}),n}runKernel(t,n,r){if(this.backendName==null&&this.backend,Tp(t,this.backendName)==null)throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:n,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,r){let a=this.backend.numDataIds(),s=0;r.forEach(l=>{s+=l.dtype==="complex64"?3:1});let i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=a-n-s-i;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${t}'`)}runKernelFunc(t){let n,r=[],a=this.isTapeOn(),s=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let l,u=Jy(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Jy(t)){let{kernelName:m,inputs:f,attrs:g}=t;this.backendName==null&&this.backend;let y=Tp(m,this.backendName);$(y!=null,()=>`Cannot find registered kernel '${m}' for backend '${this.backendName}'`),o=()=>{let b=this.backend.numDataIds();l=y.kernelFunc({inputs:f,attrs:g,backend:this.backend});let x=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(m,b,x);let v=x.map(I=>I.rank!=null?I:this.makeTensorFromTensorInfo(I));if(a){let I=this.getTensorsForGradient(m,f,v);r=this.saveTensorsForBackwardMode(I)}return v}}else{let{forwardFunc:m}=t,f=g=>{a&&(r=g.map(y=>this.keep(this.clone(y))))};o=()=>{let g=this.backend.numDataIds();l=this.tidy(()=>m(this.backend,f));let y=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,g,y),y}}let{inputs:p,attrs:h}=t,d=Jy(t)?null:t.backwardsFunc,c;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=o():(c=this.profiler.profileKernel(u,p,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(c),n=c.outputs)}),a&&this.addTapeNode(u,p,n,d,r,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(p).map(m=>p[m]!=null?p[m].shape:null),outputShapes:n.map(m=>m.shape),kernelTimeMs:c.timeMs,extraInfo:c.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(t){return t.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(t,n,r){let a=cb(t);if(a!=null){let s=a.inputsToSave||[],i=a.outputsToSave||[],o;a.saveAllInputs?($(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(n).map(u=>n[u])):o=s.map(u=>n[u]);let l=r.filter((u,p)=>i[p]);return o.concat(l)}return[]}makeTensor(t,n,r,a){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",a=a||this.backend;let s=t;r==="string"&&Oa(t[0])&&(s=t.map(l=>gd(l)));let i=a.write(s,n,r),o=new Re(n,r,i,this.nextTensorId());if(this.trackTensor(o,a),r==="string"){let l=this.state.tensorInfo.get(i),u=iS(s);this.state.numBytes+=u-l.bytes,l.bytes=u}return o}makeTensorFromDataId(t,n,r,a){r=r||"float32";let s={dataId:t,shape:n,dtype:r};return this.makeTensorFromTensorInfo(s,a)}makeTensorFromTensorInfo(t,n){let{dataId:r,shape:a,dtype:s}=t,i=new Re(a,s,r,this.nextTensorId());return this.trackTensor(i,n),i}makeVariable(t,n=!0,r,a){r=r||this.nextVariableId().toString(),a!=null&&a!==t.dtype&&(t=t.cast(a));let s=new Us(t,n,r,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(t,n){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let r=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(r=t.size*Yh(t.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:r})),t instanceof Us||this.track(t)}incRef(t,n){this.trackTensor(t,n),this.backend.incRef(t.dataId)}removeDataId(t,n){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;let n=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){let r=t.size*Yh(t.dtype);this.state.numBytes-=r}n.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,n.backend)}disposeVariables(){for(let t in this.state.registeredVariables){let n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;let n=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(a=>a.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-r;for(let a of this.state.activeProfile.kernels)a.kernelTimeMs=await a.kernelTimeMs,a.extraInfo=await a.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,n,r,a,s,i){let o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:r,saved:s},l=cb(t);l!=null&&(a=l.gradFunc),a!=null&&(o.gradient=u=>(u=u.map((p,h)=>{if(p==null){let d=r[h],c=Ec(d.size,d.dtype);return this.makeTensor(c,d.shape,d.dtype)}return p}),a(u.length>1?u:u[0],s,i))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(n.name=t),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(t){let n=Ax(t),r=new Set(n.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){let i=this.state.activeScope.track[s];!i.kept&&!r.has(i.id)&&i.dispose()}let a=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(s=>{!s.kept&&s.scopeId===a.id&&this.track(s)})}gradients(t,n,r,a=!1){if($(n.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);let s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));$(s instanceof Re,()=>"The result y returned by f() must be a tensor.");let i=mM(this.state.activeTape,n,s);if(!a&&i.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let o={};o[s.id]=r==null?NM(s.shape):r,fM(o,i,u=>this.tidy(u),TM);let l=n.map(u=>o[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(let p of u.saved)p.dispose()}),this.state.activeTape=null),{value:s,grads:l}})}customGrad(t){return $(Ha(t),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{$(n.every(o=>o instanceof Re),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r,a={};n.forEach((o,l)=>{a[l]=o});let s=(o,l)=>(r=t(...n,l),$(r.value instanceof Re,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),$(Ha(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),i=(o,l)=>{let u=r.gradFunc(o,l),p=Array.isArray(u)?u:[u];$(p.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),$(p.every(d=>d instanceof Re),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let h={};return p.forEach((d,c)=>{h[c]=()=>d}),h};return this.runKernelFunc({forwardFunc:s,backwardsFunc:i,inputs:a})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,n){return this.state.tensorInfo.get(t).backend.readToGPU(t,n)}async time(t){let n=Cp(),r=await this.backend.time(t);return r.wallMs=Cp()-n,r}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new gk;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};Fx.nextTensorId=0;Fx.nextVariableId=0;function NM(e){let t=Cx(rt(e),"float32");return O.makeTensor(t,e,"float32")}function SS(){let e=dS();if(e._tfengine==null){let t=new pS(e);e._tfengine=new Fx(t)}return qD(e._tfengine.ENV),xM(()=>e._tfengine),e._tfengine}var O=SS();function TM(e,t){let n={a:e,b:t};return O.runKernel(is,n)}var yd={};_e(yd,{isBrowser:()=>NS,isMobile:()=>EM,mockIsMobile:()=>_M});function CM(){return typeof navigator!="undefined"&&navigator!=null}var wb;function _M(e){wb=e}function EM(e){if(wb!==void 0)return wb;if(e||CM()){if(e||(e=navigator),e.product==="ReactNative")return!0;let t=e.userAgent||e.vendor||(typeof window!="undefined"?window.opera:"");if(!t){let n=e;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function NS(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}var Fn=G();Fn.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Fn.registerFlag("IS_BROWSER",()=>NS());Fn.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined");Fn.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Fn.registerFlag("IS_SAFARI",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Fn.registerFlag("PROD",()=>!1);Fn.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Fn.getBool("DEBUG"));Fn.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Fn.registerFlag("IS_TEST",()=>!1);Fn.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Fn.getBool("DEBUG"));Fn.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Fn.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Fn.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function jr(e,t){let n=e;if(Kt(e))return t==="string"?[]:[e.length];if(vS(e)){let a=e.channels||"RGBA";return[e.height,e.width*a.length]}else if(wS(e))return[e.buffer.size/(t==null?4:Yh(t))];if(!Array.isArray(e))return[];let r=[];for(;Array.isArray(n)||Kt(n)&&t!=="string";)r.push(n.length),n=n[0];return Array.isArray(e)&&G().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&TS(e,r,[]),r}function TS(e,t,n){if(n=n||[],!Array.isArray(e)&&!Kt(e)){$(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}$(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),$(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);let r=t.slice(1);for(let a=0;a<e.length;++a)TS(e[a],r,n.concat(a))}function yk(e,t,n,r){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function _(e,t,n,r="numeric"){if(e instanceof Q())return yk(r,e.dtype,t,n),e;let a=jp(e);if(a!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),yk(r,a,t,n),e==null||!Kt(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){let o=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${o}'`)}let s=jr(e,a);!Kt(e)&&!Array.isArray(e)&&(e=[e]);let i=a!=="string"?Gc(e,a):ja(e,[],!0);return O.makeTensor(i,s,a)}function _p(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((a,s)=>_(a,`${t}[${s}]`,n,r))}var Rx="__op";function L(e){let t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+Rx;let a=(...s)=>{O.startScope(n);try{let i=r(...s);return $c(i)&&console.error("Cannot return a Promise inside of tidy."),O.endScope(i),i}catch(i){throw O.endScope(null),i}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}function $M(e,t){let n=_(e,"real","complex"),r=_(t,"imag","complex");vn(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);let a={real:n,imag:r};return O.runKernel(Ac,a)}var ha=L({complex_:$M});function ps(e,t,n,r){if(r==null)r=jp(e);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(wS(e)||vS(e)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return O.backend.createTensorFromGPUData(e,t||n,r)}if(!Kt(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Kn(t);let a=rt(t),s=rt(n);$(a===s,()=>`Based on the provided shape, [${t}], the tensor should have ${a} values but has ${s}`);for(let i=0;i<n.length;++i){let o=n[i],l=i===n.length-1?o!==rt(t.slice(i)):!0;$(n[i]===t[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!Kt(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e=r!=="string"?Gc(e,r):ja(e,[],!0),O.makeTensor(e,t,r)}function yn(e,t,n){let r=jr(e,n);return ps(e,t,r,n)}var Gs={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},ga=class CS{static join(t){return new CS(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(r=>Kt(r)?r.buffer:r),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let n=0;for(let r=0;r<t.length;r++){let a=t[r];r!==t.length-1&&a.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let s=n+a.byteLength;this.shards.push({buffer:a,start:n,end:s}),n=s}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,n=isNaN(Number(n))?0:n,t=Math.max(0,t),n=Math.min(this.byteLength,n),n<=t)return new ArrayBuffer(0);let r=this.findShardForByte(t);if(r===-1)throw new Error(`Could not find start shard for byte ${t}`);let a=n-t,s=new ArrayBuffer(a),i=new Uint8Array(s),o=0;for(let l=r;l<this.shards.length;l++){let u=this.shards[l],p=t+o-u.start,h=o,d=Math.min(n,u.end)-u.start,c=new Uint8Array(u.buffer,p,d-p);if(i.set(c,h),o+=c.length,n<u.end)break}return s}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function n(a){return t<a.start?-1:t>=a.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;let r=AM(this.shards,n);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}};function AM(e,t){let n=0,r=e.length;for(;n<=r;){let a=Math.floor((r-n)/2)+n,s=t(e[a]);if(s===0)return a;s<0?r=a:n=a+1}return-1}function FM(){G().set("PROD",!0)}function RM(){G().set("DEBUG",!0)}function DM(){G().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function Dx(e){G().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}wM(Dx);function MM(){O.disposeVariables()}function cr(){return O}function rc(){return O.memory()}function OM(e){return O.profile(e)}function B(e,t){return O.tidy(e,t)}function Ce(e){Ax(e).forEach(t=>t.dispose())}function zt(e){return O.keep(e)}function LM(e){return O.time(e)}function zM(e){return O.setBackend(e)}function PM(){return O.ready()}function _S(){return O.backendName}function BM(e){O.removeBackend(e)}function WM(e){return O.findBackend(e)}function VM(e){return O.findBackendFactory(e)}function jc(e,t,n=1){return O.registerBackend(e,t,n)}function Mx(){return O.backend}function UM(e,t){G().setPlatform(e,t)}var qa=4;async function GM(e,t){let n=[],r=[],a=Array.isArray(e)?e.map(i=>i.name):Object.keys(e);for(let i=0;i<a.length;++i){let o=a[i],l=Array.isArray(e)?e[i].tensor:e[o];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);let u={name:o,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){let p=new Promise(async h=>{let d=await l.bytes(),c=d.reduce((g,y)=>g+y.length,0)+qa*d.length,m=new Uint8Array(c),f=0;for(let g=0;g<d.length;g++){let y=d[g],b=new Uint8Array(new Uint32Array([y.length]).buffer);m.set(b,f),f+=qa,m.set(y,f),f+=y.length}h(m)});r.push(p)}else r.push(l.data());t!=null&&(u.group=t),n.push(u)}let s=await Promise.all(r);return{data:qM(s),specs:n}}function ES(e,t){let n=new ga(e),r={},a=0;for(let s of t){let i=HM(s,(o,l)=>n.slice(a+o,a+l));r[s.name]=$S(s,n.slice(a,a+i)),a+=i}return r}function HM(e,t){let n=rt(e.shape),r;if("quantization"in e){let a=e.quantization;r=Gs[a.dtype]}else if(e.dtype==="string"){let a=0;for(let s=0;s<n;s++)a+=qa+new Uint32Array(t(a,a+qa))[0];return a}else r=Gs[e.dtype];return n*r}async function jM(e,t){let n=rt(e.shape),r;if("quantization"in e){let a=e.quantization;r=Gs[a.dtype]}else if(e.dtype==="string"){let a=0;for(let s=0;s<n;s++)a+=qa+new Uint32Array(await t(a,a+qa))[0];return a}else r=Gs[e.dtype];return n*r}function $S(e,t){let n=e.name,r=e.dtype,a=e.shape,s=rt(a),i,o=0;if("quantization"in e){let l=e.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${e.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(r!=="float32")throw new Error(`Weight ${e.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${r}.`)}else throw new Error(`Weight ${e.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let u=Gs[l.dtype],p=l.dtype==="uint8"?new Uint8Array(t):new Uint16Array(t);if(r==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){i=new Float32Array(p.length);for(let h=0;h<p.length;h++){let d=p[h];i[h]=d*l.scale+l.min}}else if(l.dtype==="float16")i=eO()(p);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(r==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);i=new Int32Array(p.length);for(let h=0;h<p.length;h++){let d=p[h];i[h]=Math.round(d*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);o+=s*u}else if(r==="string"){let l=rt(e.shape);i=[];for(let u=0;u<l;u++){let p=new Uint32Array(t.slice(o,o+qa))[0];o+=qa;let h=new Uint8Array(t.slice(o,o+p));i.push(h),o+=p}}else{let l=Gs[r];if(r==="float32")i=new Float32Array(t);else if(r==="int32")i=new Int32Array(t);else if(r==="bool")i=new Uint8Array(t);else if(r==="complex64"){i=new Float32Array(t);let u=new Float32Array(i.length/2),p=new Float32Array(i.length/2);for(let m=0;m<u.length;m++)u[m]=i[m*2],p[m]=i[m*2+1];let h=yn(u,a,"float32"),d=yn(p,a,"float32"),c=ha(h,d);return h.dispose(),d.dispose(),c}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);o+=s*l}return yn(i,a,r)}async function bk(e,t,n){let r=new Uint8Array(t);for(;r.byteLength<n;){let{done:a,value:s}=await e.read();if(a&&s==null){let o=n-r.byteLength;throw new Error(`Reader is done but ${o} bytes are still expected`)}let i=new Uint8Array(r.length+s.byteLength);i.set(r,0),i.set(new Uint8Array(s),r.length),r=i}return r.buffer}async function AS(e,t){let n={},r=e.getReader(),a=new ArrayBuffer(0);for(let s of t){let i=await jM(s,async(u,p)=>(a=await bk(r,a,p),a.slice(u,p)));a=await bk(r,a,i);let o=a.slice(0,i);a=a.slice(i);let l=$S(s,o);if(n[s.name]=l,_S()==="webgpu"){let u=Mx();"uploadToGPU"in u&&rt(l.shape)>=G().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&u.uploadToGPU(l.dataId)}}return n}function qM(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach(s=>{if(t+=s.byteLength,n.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let r=new Uint8Array(t),a=0;return n.forEach(s=>{r.set(new Uint8Array(s.buffer),a),a+=s.byteLength}),r.buffer}var Ox=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function xk(e){return Ox?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function KM(e){if(Ox)return Buffer.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let r=0,a=t.length;r<a;r++)n+=String.fromCharCode(t[r]);return btoa(n)}function XM(e){if(Ox){let r=Buffer.from(e,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}function ZM(e){return ga.join(e)}function vk(e){let t="/";for(e=e.trim();e.endsWith(t);)e=e.slice(0,e.length-1);let n=e.split(t);return n[n.length-1]}function FS(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(n.initializerSignature=e.initializerSignature),e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),n}function RS(e,t,n){let r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(r.trainingConfig=e.trainingConfig),e.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return e.signature!=null&&(r.signature=e.signature),e.userDefinedMetadata!=null&&(r.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(r.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(r.initializerSignature=e.initializerSignature),r}async function Lx(e,t){let n,r;return e.weightsManifest!=null&&([n,r]=await t(e.weightsManifest)),RS(e,n,r)}function bd(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:xk(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:xk(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:new ga(e.weightData).byteLength}}function kb(e){let t=[];for(let n of e)t.push(...n.weights);return t}function JM(){let e=n=>{let r=n<<13,a=0;for(;!(r&8388608);)a-=8388608,r<<=1;return r&=-8388609,a+=947912704,r|a},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function YM(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function QM(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function eO(){let e=JM(),t=YM(),n=QM();return r=>{let a=new ArrayBuffer(4*r.length),s=new Uint32Array(a);for(let i=0;i<r.length;i++){let o=r[i],l=e[n[o>>10]+(o&1023)]+t[o>>10];s[i]=l}return new Float32Array(a)}}var ir=class wr{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return wr.instance==null&&(wr.instance=new wr),wr.instance}static registerSaveRouter(t){wr.getInstance().saveRouters.push(t)}static registerLoadRouter(t){wr.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return wr.getHandlers(t,"save")}static getLoadHandlers(t,n){return wr.getHandlers(t,"load",n)}static getHandlers(t,n,r){let a=[];return(n==="load"?wr.getInstance().loadRouters:wr.getInstance().saveRouters).forEach(s=>{let i=s(t,r);i!==null&&a.push(i)}),a}},tO=e=>ir.registerSaveRouter(e),nO=e=>ir.registerLoadRouter(e),rO=e=>ir.getSaveHandlers(e),aO=(e,t)=>ir.getLoadHandlers(e,t),Ib="tensorflowjs",Sb=1,Ms="models_store",La="model_info_store";function DS(){if(!G().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e=typeof window=="undefined"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Nb(e){let t=e.result;t.createObjectStore(Ms,{keyPath:"modelPath"}),t.createObjectStore(La,{keyPath:"modelPath"})}var Hs=class{constructor(e){if(this.indexedDB=DS(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,r)=>{let a=this.indexedDB.open(Ib,Sb);a.onupgradeneeded=()=>Nb(a),a.onsuccess=()=>{let s=a.result;if(t==null){let i=s.transaction(Ms,"readonly"),o=i.objectStore(Ms).get(this.modelPath);o.onsuccess=()=>{if(o.result==null)return s.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(o.result.modelArtifacts)},o.onerror=l=>(s.close(),r(o.error)),i.oncomplete=()=>s.close()}else{t.weightData=ga.join(t.weightData);let i=bd(t),o=s.transaction(La,"readwrite"),l=o.objectStore(La),u;try{u=l.put({modelPath:this.modelPath,modelArtifactsInfo:i})}catch(h){return r(h)}let p;u.onsuccess=()=>{p=s.transaction(Ms,"readwrite");let h=p.objectStore(Ms),d;try{d=h.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i})}catch(c){return r(c)}d.onsuccess=()=>n({modelArtifactsInfo:i}),d.onerror=c=>{l=o.objectStore(La);let m=l.delete(this.modelPath);m.onsuccess=()=>(s.close(),r(d.error)),m.onerror=f=>(s.close(),r(d.error))}},u.onerror=h=>(s.close(),r(u.error)),o.oncomplete=()=>{p==null?s.close():p.oncomplete=()=>s.close()}}},a.onerror=s=>r(a.error)})}};Hs.URL_SCHEME="indexeddb://";var MS=e=>G().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Hs.URL_SCHEME)?sO(e.slice(Hs.URL_SCHEME.length)):null;ir.registerSaveRouter(MS);ir.registerLoadRouter(MS);function sO(e){return new Hs(e)}function iO(e){return e.startsWith(Hs.URL_SCHEME)?e.slice(Hs.URL_SCHEME.length):e}var oO=class{constructor(){this.indexedDB=DS()}async listModels(){return new Promise((e,t)=>{let n=this.indexedDB.open(Ib,Sb);n.onupgradeneeded=()=>Nb(n),n.onsuccess=()=>{let r=n.result,a=r.transaction(La,"readonly"),s=a.objectStore(La).getAll();s.onsuccess=()=>{let i={};for(let o of s.result)i[o.modelPath]=o.modelArtifactsInfo;e(i)},s.onerror=i=>(r.close(),t(s.error)),a.oncomplete=()=>r.close()},n.onerror=r=>t(n.error)})}async removeModel(e){return e=iO(e),new Promise((t,n)=>{let r=this.indexedDB.open(Ib,Sb);r.onupgradeneeded=()=>Nb(r),r.onsuccess=()=>{let a=r.result,s=a.transaction(La,"readwrite"),i=s.objectStore(La),o=i.get(e),l;o.onsuccess=()=>{if(o.result==null)return a.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let u=i.delete(e),p=()=>{l=a.transaction(Ms,"readwrite");let h=l.objectStore(Ms).delete(e);h.onsuccess=()=>t(o.result.modelArtifactsInfo),h.onerror=d=>n(o.error)};u.onsuccess=p,u.onerror=h=>(p(),a.close(),n(o.error))}},o.onerror=u=>(a.close(),n(o.error)),s.oncomplete=()=>{l==null?a.close():l.oncomplete=()=>a.close()}},r.onerror=a=>n(r.error)})}},la="/",Jo="tensorflowjs_models",OS="info",lO="model_topology",uO="weight_specs",pO="weight_data",dO="model_metadata";function LS(e){return{info:[Jo,e,OS].join(la),topology:[Jo,e,lO].join(la),weightSpecs:[Jo,e,uO].join(la),weightData:[Jo,e,pO].join(la),modelMetadata:[Jo,e,dO].join(la)}}function zS(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function hO(e){let t=e.split(la);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(la)}function cO(e){return e.startsWith(js.URL_SCHEME)?e.slice(js.URL_SCHEME.length):e}var js=class{constructor(e){if(!G().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=LS(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=bd(e),a=ga.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,KM(a));let s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:r}}catch{throw zS(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;let a=this.LS.getItem(this.keys.modelMetadata);if(a!=null){let i=JSON.parse(a);t.format=i.format,t.generatedBy=i.generatedBy,t.convertedBy=i.convertedBy,i.signature!=null&&(t.signature=i.signature),i.userDefinedMetadata!=null&&(t.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(t.modelInitializer=i.modelInitializer),i.initializerSignature!=null&&(t.initializerSignature=i.initializerSignature),i.trainingConfig!=null&&(t.trainingConfig=i.trainingConfig)}let s=this.LS.getItem(this.keys.weightData);if(s==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=XM(s),t}};js.URL_SCHEME="localstorage://";var PS=e=>G().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(js.URL_SCHEME)?mO(e.slice(js.URL_SCHEME.length)):null;ir.registerSaveRouter(PS);ir.registerLoadRouter(PS);function mO(e){return new js(e)}var fO=class{constructor(){$(G().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),$(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=Jo+la,n=la+OS;for(let r=0;r<this.LS.length;++r){let a=this.LS.key(r);if(a.startsWith(t)&&a.endsWith(n)){let s=hO(a);e[s]=JSON.parse(this.LS.getItem(a))}}return e}async removeModel(e){e=cO(e);let t=LS(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return zS(t),n}},tl="://",Ka=class $a{constructor(){this.managers={}}static getInstance(){return $a.instance==null&&($a.instance=new $a),$a.instance}static registerManager(t,n){$(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(tl)&&(t=t.slice(0,t.indexOf(tl))),$(t.length>0,()=>"scheme must not be an empty string.");let r=$a.getInstance();$(r.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),r.managers[t]=n}static getManager(t){let n=$a.getInstance().managers[t];if(n==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys($a.getInstance().managers)}};function Vh(e){if(e.indexOf(tl)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Ka.getSchemes().join(",")}`);return{scheme:e.split(tl)[0],path:e.split(tl)[1]}}async function BS(e,t,n=!1){$(e!==t,()=>`Old path and new path are the same: '${e}'`);let r=ir.getLoadHandlers(e);$(r.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),$(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`);let a=r[0],s=ir.getSaveHandlers(t);$(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),$(s.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);let i=s[0],o=Vh(e).scheme,l=Vh(e).path,u=o===Vh(e).scheme,p=await a.load();n&&u&&await Ka.getManager(o).removeModel(l);let h=await i.save(p);return n&&!u&&await Ka.getManager(o).removeModel(l),h.modelArtifactsInfo}async function gO(){let e=Ka.getSchemes(),t={};for(let n of e){let r=await Ka.getManager(n).listModels();for(let a in r){let s=n+tl+a;t[s]=r[a]}}return t}async function yO(e){let t=Vh(e);return Ka.getManager(t.scheme).removeModel(t.path)}async function bO(e,t){return BS(e,t,!1)}async function xO(e,t){return BS(e,t,!0)}var vO=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window=="undefined"||!G().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",n=>{if(n.source===window&&n.data.name===this.messageName){n.stopPropagation();let r=this.functionRefs[n.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return gS(e)}};if(G().get("IS_BROWSER")){G().setPlatform("browser",new vO);try{Ka.registerManager(js.URL_SCHEME,new fO)}catch{}try{Ka.registerManager(Hs.URL_SCHEME,new oO)}catch{}}var wO={importFetch:()=>hD()},Yy,kO=class{constructor(){this.util=cD(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return G().global.fetch!=null?G().global.fetch(e,t):(Yy==null&&(Yy=wO.importFetch()),Yy(e,t))}now(){let e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}};G().get("IS_NODE")&&!G().get("IS_BROWSER")&&G().setPlatform("node",new kO);function Oe(e,t="float32",n){return t=t||"float32",Kn(e),new Rt(e,t,n)}function IO(e,t){let n=_(e,"x","cast");if(!sS(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");let r={x:n},a={dtype:t};return O.runKernel(yi,r,a)}var oe=L({cast_:IO});function SO(e){let t={x:_(e,"x","clone","string_or_numeric")};return O.runKernel(Oi,t)}var Ur=L({clone_:SO});function zx(e,t=!1){console.log(e.toString(t))}SS();var NO={buffer:Oe,cast:oe,clone:Ur,print:zx};vM(NO);function TO(e,t){let n=_(e,"a","add"),r=_(t,"b","add");[n,r]=Nt(n,r);let a={a:n,b:r};return O.runKernel(is,a)}var Z=L({add_:TO});function CO(e,t){let n=_(e,"a","floorDiv"),r=_(t,"b","floorDiv");[n,r]=Nt(n,r);let a={a:n,b:r};return O.runKernel(Ri,a)}var qc=L({floorDiv_:CO});function _O(e,t){let n=_(e,"a","div"),r=_(t,"b","div");if([n,r]=Nt(n,r),n.dtype==="int32"&&r.dtype==="int32")return qc(n,r);let a={a:n,b:r},s={};return O.runKernel(Ci,a,s)}var ce=L({div_:_O});function EO(e,t){let n=_(e,"a","mul"),r=_(t,"b","mul");[n,r]=Nt(n,r);let a={a:n,b:r};return O.runKernel(Yi,a)}var z=L({mul_:EO});function $O(e){let t=_(e,"x","abs");if(t.dtype==="complex64"){let n={x:t};return O.runKernel(Zp,n)}else{let n={x:t};return O.runKernel(Sl,n)}}var At=L({abs_:$O});function AO(e){let t={x:_(e,"x","acos")};return O.runKernel(oi,t)}var Px=L({acos_:AO});function FO(e){let t={x:_(e,"x","acosh")};return O.runKernel(li,t)}var Bx=L({acosh_:FO});function RO(e){$(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),$(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);let t=e.map((a,s)=>_(a,`tensors${s}`,"addN")),n=t[0];t.forEach(a=>{if(a.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(a=>{if(!fa(a.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let r=t;return O.runKernel(ui,r)}var WS=L({addN_:RO});function DO(e,t=null,n=!1){let r={x:_(e,"x","all","bool")},a={axis:t,keepDims:n};return O.runKernel(Nl,r,a)}var Kc=L({all_:DO});function MO(e,t=null,n=!1){let r={x:_(e,"x","any","bool")},a={axis:t,keepDims:n};return O.runKernel(Tl,r,a)}var Ep=L({any_:MO});function OO(e,t=0){let n={x:_(e,"x","argMax")},r={axis:t};return O.runKernel(Cl,n,r)}var qs=L({argMax_:OO});function LO(e,t=0){let n={x:_(e,"x","argMin")},r={axis:t};return O.runKernel(_l,n,r)}var Wx=L({argMin_:LO});function zO(e){let t={x:_(e,"x","asin")};return O.runKernel(pi,t)}var Vx=L({asin_:zO});function PO(e){let t={x:_(e,"x","asinh")};return O.runKernel(di,t)}var Ux=L({asinh_:PO});function BO(e){let t={x:_(e,"x","atan")};return O.runKernel(hi,t)}var Gx=L({atan_:BO});function WO(e,t){let n=_(e,"a","atan2"),r=_(t,"b","atan2");[n,r]=Nt(n,r);let a={a:n,b:r};return O.runKernel(mi,a)}var Hx=L({atan2_:WO});function VO(e){let t={x:_(e,"x","atanh")};return O.runKernel(ci,t)}var jx=L({atanh_:VO});function UO(e,t,n,r,a="NHWC",s){let i=e[3],o=[...t,i],l=GS(a);return xd(e,o,n,s,r,null,null,l)}function VS(e,t,n,r,a,s,i="channelsLast"){let[o,l]=$p(t),u;if(i==="channelsLast")u=[o,l,e[3],e[3]];else if(i==="channelsFirst")u=[o,l,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return xd(e,u,n,r,a,s,!1,i)}function GO(e,t,n,r,a,s,i="NDHWC"){let[o,l,u]=Tb(t),p,h;if(i==="NDHWC")h="channelsLast",p=[o,l,u,e[4],e[4]];else if(i==="NCDHW")h="channelsFirst",p=[o,l,u,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return US(e,p,n,r,a,!1,h,s)}function xd(e,t,n,r,a,s,i=!1,o="channelsLast"){let[l,u,p,h]=[-1,-1,-1,-1];if(o==="channelsLast")[l,u,p,h]=e;else if(o==="channelsFirst")[l,h,u,p]=e;else throw new Error(`Unknown dataFormat ${o}`);let[d,c,,m]=t,[f,g]=$p(n),[y,b]=$p(r),x=nl(d,y),v=nl(c,b),{padInfo:I,outHeight:N,outWidth:C}=qO(a,u,p,f,g,x,v,s,o),E=i?m*h:m,A;return o==="channelsFirst"?A=[l,E,N,C]:o==="channelsLast"&&(A=[l,N,C,E]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:p,inChannels:h,outHeight:N,outWidth:C,outChannels:E,padInfo:I,strideHeight:f,strideWidth:g,filterHeight:d,filterWidth:c,effectiveFilterHeight:x,effectiveFilterWidth:v,dilationHeight:y,dilationWidth:b,inShape:e,outShape:A,filterShape:t}}function US(e,t,n,r,a,s=!1,i="channelsLast",o){let[l,u,p,h,d]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[l,u,p,h,d]=e;else if(i==="channelsFirst")[l,d,u,p,h]=e;else throw new Error(`Unknown dataFormat ${i}`);let[c,m,f,,g]=t,[y,b,x]=Tb(n),[v,I,N]=Tb(r),C=nl(c,v),E=nl(m,I),A=nl(f,N),{padInfo:R,outDepth:F,outHeight:S,outWidth:M}=KO(a,u,p,h,y,b,x,C,E,A,o),W=s?g*d:g,U;return i==="channelsFirst"?U=[l,W,F,S,M]:i==="channelsLast"&&(U=[l,F,S,M,W]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:p,inWidth:h,inChannels:d,outDepth:F,outHeight:S,outWidth:M,outChannels:W,padInfo:R,strideDepth:y,strideHeight:b,strideWidth:x,filterDepth:c,filterHeight:m,filterWidth:f,effectiveFilterDepth:C,effectiveFilterHeight:E,effectiveFilterWidth:A,dilationDepth:v,dilationHeight:I,dilationWidth:N,inShape:e,outShape:U,filterShape:t}}function HO(e,t,n,r,a){r==null&&(r=qx(e,t,n));let s=e[0],i=e[1],o=Ap((s-t+2*r)/n+1,a),l=Ap((i-t+2*r)/n+1,a);return[o,l]}function jO(e,t,n,r,a,s){a==null&&(a=qx(e,t[0],r[0]));let i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*a>=t[o]&&(i[o]=Ap((e[o]-t[o]+2*a)/r[o]+1,s));return i}function qx(e,t,n,r=1){let a=nl(t,r);return Math.floor((e[0]*(n-1)-n+a)/2)}function $p(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function Tb(e){return typeof e=="number"?[e,e,e]:e}function nl(e,t){return t<=1?e:e+(e-1)*(t-1)}function qO(e,t,n,r,a,s,i,o,l){let u,p,h;if(typeof e=="number"){u={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};let d=HO([t,n],s,r,e,o);p=d[0],h=d[1]}else if(e==="same"){p=Math.ceil(t/r),h=Math.ceil(n/a);let d=Math.max(0,(p-1)*r+s-t),c=Math.max(0,(h-1)*a+i-n),m=Math.floor(d/2),f=d-m,g=Math.floor(c/2),y=c-g;u={top:m,bottom:f,left:g,right:y,type:"SAME"}}else if(e==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},p=Math.ceil((t-s+1)/r),h=Math.ceil((n-i+1)/a);else if(typeof e=="object"){let d=l==="channelsLast"?e[1][0]:e[2][0],c=l==="channelsLast"?e[1][1]:e[2][1],m=l==="channelsLast"?e[2][0]:e[3][0],f=l==="channelsLast"?e[2][1]:e[3][1];u={top:d,bottom:c,left:m,right:f,type:d===0&&c===0&&m===0&&f===0?"VALID":"EXPLICIT"},p=Ap((t-s+d+c)/r+1,o),h=Ap((n-i+m+f)/a+1,o)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:u,outHeight:p,outWidth:h}}function KO(e,t,n,r,a,s,i,o,l,u,p){let h,d,c,m;if(e==="valid"&&(e=0),typeof e=="number"){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?"VALID":"NUMBER"};let f=jO([t,n,r,1],[o,l,u],1,[a,s,i],e,p);d=f[0],c=f[1],m=f[2]}else if(e==="same"){d=Math.ceil(t/a),c=Math.ceil(n/s),m=Math.ceil(r/i);let f=(d-1)*a+o-t,g=(c-1)*s+l-n,y=(m-1)*i+u-r,b=Math.floor(f/2),x=f-b,v=Math.floor(g/2),I=g-v,N=Math.floor(y/2),C=y-N;h={top:v,bottom:I,left:N,right:C,front:b,back:x,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:h,outDepth:d,outHeight:c,outWidth:m}}function Ap(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Xa(e){let[t,n,r]=$p(e);return t===1&&n===1&&r===1}function Jr(e,t){return Xa(e)||Xa(t)}function Ks(e){return $p(e).every(t=>t>0)}function GS(e){if(e==="NHWC")return"channelsLast";if(e==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function wn(e,t,n){if(n!=null){if(typeof t=="string")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t=="number")$(al(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t=="object")t.forEach(r=>{r.forEach(a=>{$(al(a),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${a}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}function XO(e,t){let n={x:_(e,"x","reshape","string_or_numeric")},r={shape:t};return O.runKernel(lu,n,r)}var P=L({reshape_:XO});function ZO(e,t,n,r,a){let s=_(e,"x","avgPool","float32"),i=1;$(Jr(n,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let o=s,l=!1;s.rank===3&&(l=!0,o=P(s,[1,s.shape[0],s.shape[1],s.shape[2]])),$(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),wn("avgPool",r,a);let u={x:o},p={filterSize:t,strides:n,pad:r,dimRoundingMode:a},h=O.runKernel(fi,u,p);return h=oe(h,s.dtype),l?P(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var ya=L({avgPool_:ZO});function JO(e,t,n,r,a,s="NDHWC"){let i=_(e,"x","avgPool3d","float32"),o=i,l=!1;i.rank===4&&(l=!0,o=P(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),$(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),$(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),$(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),wn("avgPool3d",r,a);let u={x:o},p={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},h=O.runKernel(El,u,p);return h=oe(h,o.dtype),l?P(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var Kx=L({avgPool3d_:JO});function YO(e,t=0){$(e.length>=1,()=>"Pass at least one tensor to concat");let n=_p(e,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),n.length===1)return Ur(n[0]);let r=n,a={axis:t};return O.runKernel(Rl,r,a)}var ot=L({concat_:YO});function QO(e,t,n=!1,r=!1){let a=_(e,"a","matMul"),s=_(t,"b","matMul");[a,s]=Nt(a,s);let i={a,b:s},o={transposeA:n,transposeB:r};return O.runKernel(gi,i,o)}var De=L({matMul_:QO});function e3(e){let t={x:_(e,"x","sigmoid","float32")};return O.runKernel(yo,t)}var fr=L({sigmoid_:e3});function t3(e,t,n){let r=_(e,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");let a={x:r},s={begin:t,size:n};return O.runKernel(fu,a,s)}var Ue=L({slice_:t3});function n3(e){let t={x:_(e,"x","tanh","float32")};return O.runKernel(No,t)}var Za=L({tanh_:n3});function r3(e,t,n,r,a,s){let i=_(e,"forgetBias","basicLSTMCell"),o=_(t,"lstmKernel","basicLSTMCell"),l=_(n,"lstmBias","basicLSTMCell"),u=_(r,"data","basicLSTMCell"),p=_(a,"c","basicLSTMCell"),h=_(s,"h","basicLSTMCell"),d=ot([u,h],1),c=De(d,o),m=Z(c,l),f=m.shape[0],g=m.shape[1]/4,y=[f,g],b=Ue(m,[0,0],y),x=Ue(m,[0,g],y),v=Ue(m,[0,g*2],y),I=Ue(m,[0,g*3],y),N=Z(z(fr(b),Za(x)),z(p,fr(Z(i,v)))),C=z(Za(N),fr(I));return[N,C]}var HS=L({basicLSTMCell_:r3});function a3(e,t,n){let r=_(e,"x","batchToSpaceND"),a=t.reduce((o,l)=>o*l);$(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),$(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),$(r.shape[0]%a===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${a}`);let s={x:r},i={blockShape:t,crops:n};return O.runKernel($l,s,i)}var vd=L({batchToSpaceND_:a3});function s3(e){let t;return e.rank===0||e.rank===1?t=P(e,[1,1,1,e.size]):e.rank===2?t=P(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=P(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}function i3(e,t,n,r,a,s){s==null&&(s=.001);let i=_(e,"x","batchNorm"),o=_(t,"mean","batchNorm"),l=_(n,"variance","batchNorm"),u;a!=null&&(u=_(a,"scale","batchNorm"));let p;r!=null&&(p=_(r,"offset","batchNorm")),$(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),$(p==null||o.rank===p.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),$(u==null||o.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let h={x:s3(i),scale:u,offset:p,mean:o,variance:l},d={varianceEpsilon:s},c=O.runKernel(Di,h,d);return P(c,i.shape)}var To=L({batchNorm_:i3});function o3(e,t,n,r,a,s){let i=_(e,"x","batchNorm"),o=_(t,"mean","batchNorm"),l=_(n,"variance","batchNorm"),u;a!=null&&(u=_(a,"scale","batchNorm"));let p;return r!=null&&(p=_(r,"offset","batchNorm")),$(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),$(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),$(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&$(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),p!=null&&$(p.rank===2||p.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${p.rank}.`),To(i,o,l,p,u,s)}var Xx=L({batchNorm2d_:o3});function l3(e,t,n,r,a,s){let i=_(e,"x","batchNorm"),o=_(t,"mean","batchNorm"),l=_(n,"variance","batchNorm"),u;a!=null&&(u=_(a,"scale","batchNorm"));let p;return r!=null&&(p=_(r,"offset","batchNorm")),$(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),$(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),$(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&$(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),p!=null&&$(p.rank===3||p.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${p.rank}.`),To(i,o,l,p,u,s)}var Zx=L({batchNorm3d_:l3});function u3(e,t,n,r,a,s){let i=_(e,"x","batchNorm"),o=_(t,"mean","batchNorm"),l=_(n,"variance","batchNorm"),u;a!=null&&(u=_(a,"scale","batchNorm"));let p;return r!=null&&(p=_(r,"offset","batchNorm")),$(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),$(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),$(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&$(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),p!=null&&$(p.rank===4||p.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${p.rank}.`),To(i,o,l,p,u,s)}var Jx=L({batchNorm4d_:u3});function p3(e,t,n){let r=_(e,"x","bincount"),a=_(t,"weights","bincount");$(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),$(n>=0,()=>`size must be non-negative, but got ${n}.`),$(a.size===r.size||a.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${a.shape}.`);let s={x:r,weights:a},i={size:n};return O.runKernel(Al,s,i)}var Yx=L({bincount_:p3});function d3(e,t){let n=_(e,"x","bitwiseAnd"),r=_(t,"y","bitwiseAnd");if(!fa(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if(n.dtype!=="int32"||r.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);let a={a:n,b:r};return O.runKernel(Fl,a)}var jS=L({bitwiseAnd_:d3});function h3(e,t){let n=_(e,"s0","broadcastArgs","int32"),r=_(t,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let a={s0:n,s1:r};return O.runKernel(Xp,a)}var qS=L({broadcastArgs_:h3});function c3(e,t){let n=_(e,"broadcastTo","x"),r=n.shape;if(Kn(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let l=n.shape.slice();for(;l.length<t.length;)l.unshift(1);n=P(n,l)}let a=n.shape,s=Array.from(t);for(let l=t.length-1;l>=0;l--)if(a[l]===t[l])s[l]=1;else if(n.shape[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(s.map((l,u)=>l>1?u:-1).filter(l=>l>=0).length===0)return Ur(n);let i={x:n},o={reps:s};return O.runKernel(ls,i,o)}var Ls=L({broadcastTo_:c3});function m3(e){let t={x:_(e,"x","ceil","float32")};return O.runKernel(bi,t)}var Qx=L({ceil_:m3});function Un(e,t,n){Kn(e),n=n||jp(t);let r={shape:e,value:t,dtype:n};return O.runKernel(Qp,{},r)}function f3(e,t,n){let r=_(e,"x","clipByValue");if($(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return Un(r.shape,t,r.dtype);let a={x:r},s={clipValueMin:t,clipValueMax:n};return O.runKernel(os,a,s)}var un=L({clipByValue_:f3});function g3(e){return ot(e,0)}var ev=L({concat1d_:g3});function y3(e,t){return ot(e,t)}var tv=L({concat2d_:y3});function b3(e,t){return ot(e,t)}var nv=L({concat3d_:b3});function x3(e,t){return ot(e,t)}var rv=L({concat4d_:x3});function v3(e,t,n,r,a="NHWC",s=[1,1],i){let o=_(e,"x","conv2d","float32"),l=_(t,"filter","conv2d","float32"),u=o,p=!1;o.rank===3&&(p=!0,u=P(o,[1,o.shape[0],o.shape[1],o.shape[2]])),$(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),$(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),wn("conv2d",r,i);let h=a==="NHWC"?u.shape[3]:u.shape[1];$(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),$(Jr(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),$(Ks(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),$(Ks(n),()=>"Error in conv2D: Strides should be larger than 0.");let d={x:u,filter:l},c={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},m=O.runKernel(xi,d,c);return p?P(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var bn=L({conv2d_:v3});function w3(e,t,n,r,a="NWC",s=1,i){let o=_(e,"x","conv1d"),l=_(t,"filter","conv1d"),u=o,p=!1;o.rank===2&&(p=!0,u=P(o,[1,o.shape[0],o.shape[1]])),$(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),$(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),wn("conv1d",r,i),$(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),$(Jr(n,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`),$(Ks(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),$(Ks(n),()=>"Error in conv1D: Stride should be larger than 0."),$(a==="NWC",()=>`Error in conv1d: got dataFormat of ${a} but only NWC is currently supported.`);let h=P(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=P(u,[u.shape[0],1,u.shape[1],u.shape[2]]),c=bn(d,h,[1,n],r,"NHWC",[1,s],i);return p?P(c,[c.shape[2],c.shape[3]]):P(c,[c.shape[0],c.shape[2],c.shape[3]])}var Xc=L({conv1d_:w3});function k3(e,t,n,r,a,s="NHWC",i){$(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,l=t,u=!1;t.rank===3&&(u=!0,l=P(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),$(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),$(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),$(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);let p=s==="NHWC"?o[3]:o[1],h=s==="NHWC"?l.shape[3]:l.shape[1];$(p===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${p}) must match input depth for filter ${n.shape[2]}.`),$(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),wn("conv2dDerInput",a,i);let d={dy:l,filter:n},c={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,inputShape:o},m=O.runKernel(vi,d,c);return u?P(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var av=L({conv2DBackpropInput_:k3});function I3(e,t,n,r,a,s){let i=_(e,"x","conv2dTranspose"),o=_(t,"filter","conv2dTranspose");return av(n,i,o,r,a,"NHWC",s)}var Zc=L({conv2dTranspose_:I3});function S3(e,t,n,r,a="NDHWC",s=[1,1,1]){let i=_(e,"x","conv3d"),o=_(t,"filter","conv3d"),l=i,u=!1;i.rank===4&&(u=!0,l=P(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),$(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),$(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),$(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),$(Jr(n,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),$(a==="NDHWC",()=>`Error in conv3d: got dataFormat of ${a} but only NDHWC is currently supported.`),$(Ks(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),$(Ks(n),()=>"Error in conv3D: Strides should be larger than 0.");let p={x:l,filter:o},h={strides:n,pad:r,dataFormat:a,dilations:s},d=O.runKernel(wi,p,h);return u?P(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var sv=L({conv3d_:S3});function N3(e,t,n,r,a){$(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let s=e,i=t,o=!1;t.rank===4&&(o=!0,i=P(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);let l=s[4],u=i.shape[4];$(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),$(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),$(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),$(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),$(u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);let p={dy:i,filter:n},h={pad:a,strides:r,inputShape:s},d=O.runKernel(Ml,p,h);return o?P(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var KS=L({conv3DBackpropInput_:N3});function T3(e,t,n,r,a){let s=_(e,"x","conv3dTranspose"),i=_(t,"filter","conv3dTranspose");return KS(n,s,i,r,a)}var iv=L({conv3dTranspose_:T3});function C3(e){let t={x:_(e,"x","cos","float32")};return O.runKernel(ki,t)}var wd=L({cos_:C3});function _3(e){let t={x:_(e,"x","cosh","float32")};return O.runKernel(Ii,t)}var Jc=L({cosh_:_3});function E3(e,t=0,n=!1,r=!1){let a={x:_(e,"x","cumprod")},s={axis:t,exclusive:n,reverse:r};return O.runKernel(Ol,a,s)}var Fp=L({cumprod_:E3});function $3(e,t=0,n=!1,r=!1){let a={x:_(e,"x","cumsum")},s={axis:t,exclusive:n,reverse:r};return O.runKernel(Si,a,s)}var Yc=L({cumsum_:$3});function A3(e,t,n,r=!1){let a=_(e,"x","denseBincount"),s=_(t,"weights","denseBincount");$(a.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${a.dtype}`),$(a.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${a.rank}.`),$(n>=0,()=>`size must be non-negative, but got ${n}.`),$(s.size===a.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${a.shape}, weights shape: ${s.shape}.`);let i={x:a,weights:s},o={size:n,binaryOutput:r};return O.runKernel(Jp,i,o)}var ac=L({denseBincount_:A3});function F3(e,t,n="NHWC"){let r=_(e,"x","depthToSpace","float32"),a=n==="NHWC"?r.shape[1]:r.shape[2],s=n==="NHWC"?r.shape[2]:r.shape[3],i=n==="NHWC"?r.shape[3]:r.shape[1];$(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),$(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${t}  for depthToSpace with input shape
    ${r.shape}`),$(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t} for depthToSpace with input shape
        ${r.shape}`),$(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`);let o={x:r},l={blockSize:t,dataFormat:n};return O.runKernel(zl,o,l)}var ov=L({depthToSpace_:F3});function R3(e,t,n,r,a="NHWC",s=[1,1],i){let o=_(e,"x","depthwiseConv2d","float32"),l=_(t,"filter","depthwiseConv2d","float32"),u=o,p=!1;o.rank===3&&(p=!0,u=P(o,[1,o.shape[0],o.shape[1],o.shape[2]])),$(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),$(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);let h=a==="NHWC"?u.shape[3]:u.shape[1];$(h===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`),wn("depthwiseConv2d",r,i);let d={x:u,filter:l},c={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},m=O.runKernel(Ni,d,c);return p?P(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var Co=L({depthwiseConv2d_:R3});function D3(e){let t={x:_(e,"x","diag")};return O.runKernel(Yp,t)}var XS=L({diag_:D3});function M3(e,t,n,r,a=[1,1],s="NHWC"){let i=_(e,"x","dilation2d"),o=_(t,"filter","dilation2d");$(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),$(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),$(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let l=i,u=!1;i.rank===3&&(l=P(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),$(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);let p={x:l,filter:o},h={strides:n,pad:r,dilations:a},d=O.runKernel(Ti,p,h);return u?P(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var lv=L({dilation2d_:M3}),Tu={};_e(Tu,{assertAndGetBroadcastShape:()=>lt,getBroadcastDims:()=>ZS,getReductionAxes:()=>Mt});function ZS(e,t){let n=e.length,r=[];for(let a=0;a<n;a++){let s=n-1-a,i=e[s]||1;(t[t.length-1-a]||1)>1&&i===1&&r.unshift(s)}return r}function Mt(e,t){let n=[];for(let r=0;r<t.length;r++){let a=e[e.length-r-1],s=t.length-r-1,i=t[s];(a==null||a===1&&i>1)&&n.unshift(s)}return n}function lt(e,t){let n=Math.max(e.length,t.length),r=new Array(n);for(let a=0;a<n;a++){let s=e[e.length-a-1];s==null&&(s=1);let i=t[t.length-a-1];if(i==null&&(i=1),s===1)r[n-a-1]=i;else if(i===1)r[n-a-1]=s;else if(s!==i){let o=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(o)}else r[n-a-1]=s}return r}function O3(e,t){let n=_(e,"a","equal","string_or_numeric"),r=_(t,"b","equal","string_or_numeric");[n,r]=Nt(n,r),lt(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(Bl,a)}var Gn=L({equal_:O3});function L3(e,t,n){let r=_(t,"a","where"),a=_(n,"b","where"),s=_(e,"condition","where","bool"),i=lt(lt(s.shape,r.shape),a.shape),o=Ls(s,i),l=Ls(r,i),u=Ls(a,i),p={condition:o,t:l,e:u};return O.runKernel(mu,p)}var Jt=L({where_:L3});function z3(e){let t={x:_(e,"x","zerosLike")};return O.runKernel(Su,t)}var Ge=L({zerosLike_:z3});function P3(e,t){let n=_(e,"a","div"),r=_(t,"b","div");[n,r]=Nt(n,r);let a=ce(n,r),s=Ge(a),i=Gn(r,s);return Jt(i,s,a)}var uv=L({divNoNan_:P3});function B3(e,t){let n=_(e,"t1","dot"),r=_(t,"t2","dot");$((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);let a=n.rank===1?n.size:n.shape[1],s=r.rank===1?r.size:r.shape[0];if($(a===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${a} and ${s}.`),n.rank===1&&r.rank===1){let i=P(n,[1,-1]),o=P(r,[-1,1]),l=De(i,o);return P(l,[])}else if(n.rank===1&&r.rank===2){let i=P(n,[1,-1]),o=P(r,[r.shape[0],r.shape[1]]),l=De(i,o);return P(l,[l.size])}else if(n.rank===2&&r.rank===1){let i=P(r,[-1,1]),o=De(n,i);return P(o,[o.size])}else{let i=P(r,[r.shape[0],r.shape[1]]);return De(n,i)}}var pv=L({dot_:B3});function W3(e,...t){let n=t.map((a,s)=>_(a,`tensors${s}`,"einsum")),r={equation:e};return O.runKernel(Oc,n,r)}var As=L({einsum_:W3});function V3(e){let t={x:_(e,"x","elu","float32")};return O.runKernel(_i,t)}var Cu=L({elu_:V3});function U3(e,t){let n=_(e,"x","ensureShape","string_or_numeric");if(!tS(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}var JS=L({ensureShape_:U3});function G3(e){let t=_(e,"x","erf");$(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=oe(t,"float32"));let n={x:t};return O.runKernel(Ei,n)}var Qc=L({erf_:G3});function dv(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function YS(e,t,n){let r=e.length+t.length,a=[],s=0,i=0;for(let o=0;o<r;o++)n.indexOf(o)===-1?a.push(e[s++]):a.push(t[i++]);return a}function QS(e,t){let n=[],r=e.length;for(let s=0;s<r;s++)t.indexOf(s)===-1&&n.push(e[s]);let a=t.map(s=>e[s]);return[n,a]}function Xs(e,t){let n=t.map(r=>1);return YS(e,n,t)}function H3(e,t,n){$(dv(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function eN(e,t){if(dv(e,t))return null;let n=[];for(let r=0;r<t;++r)e.indexOf(r)===-1&&n.push(r);return e.forEach(r=>n.push(r)),n}function hv(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function j3(e,t){let n=[];for(let r=t-e;r<t;++r)n.push(r);return n}function q3(e,t=null,n=!1){let r={x:_(e,"x","max")},a={reductionIndices:t,keepDims:n};return O.runKernel(Gi,r,a)}var ar=L({max_:q3});function K3(e,t=null,n=!1){let r={x:_(e,"x","min")},a={axis:t,keepDims:n};return O.runKernel(Ki,r,a)}var ll=L({min_:K3});function X3(e,t){let n=_(e,"base","pow"),r=_(t,"exp","pow");[n,r]=Nt(n,r);let a={a:n,b:r};return O.runKernel(to,a)}var qr=L({pow_:X3});function ve(e,t){if((Kt(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&Kt(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return ps(e,[],[],t)}function Z3(e){let t={x:_(e,"x","sqrt","float32")};return O.runKernel(xo,t)}var Yt=L({sqrt_:Z3});function J3(e){let t=_(e,"x","square"),n={};return O.runKernel("Square",{x:t},n)}var it=L({square_:J3});function Y3(e,t=null,n=!1){let r=_(e,"x","sum");r.dtype==="bool"&&(r=oe(r,"int32"));let a={x:r},s={axis:t,keepDims:n};return O.runKernel(vo,a,s)}var fe=L({sum_:Y3});function Q3(e,t="euclidean",n=null,r=!1){e=_(e,"x","norm");let a=tN(e,t,n),s=a.shape;if(r){let i=yr(n,e.shape);s=Xs(a.shape,i)}return P(a,s)}function tN(e,t,n=null){if(e.rank===0)return At(e);if(e.rank!==1&&n===null)return tN(P(e,[-1]),t,n);if(e.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(t===1)return fe(At(e),n);if(t===1/0)return ar(At(e),n);if(t===-1/0)return ll(At(e),n);if(t==="euclidean"||t===2)return Yt(fe(qr(At(e),ve(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return ar(fe(At(e),n[0]),n[1]-1);if(t===1/0)return ar(fe(At(e),n[1]),n[0]);if(t===-1/0)return ll(fe(At(e),n[1]),n[0]);if(t==="fro"||t==="euclidean")return Yt(fe(it(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var _u=L({norm_:Q3});function eL(e,t=null,n=!1){return _u(e,"euclidean",t,n)}var cv=L({euclideanNorm_:eL});function tL(e){let t={x:_(e,"x","exp")};return O.runKernel($i,t)}var pn=L({exp_:tL});function nL(e,t=0){let n=_(e,"x","expandDims","string_or_numeric");$(t<=n.rank,()=>"Axis must be <= rank of the tensor");let r={input:n},a={dim:t};return O.runKernel(Wl,r,a)}var Xt=L({expandDims_:nL});function rL(e){let t={x:_(e,"x","expm1")};return O.runKernel(Ai,t)}var mv=L({expm1_:rL});function aL(e,t){let n=_(e,"x","tile","string_or_numeric");$(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);let r={x:n},a={reps:t};return O.runKernel(ls,r,a)}var Vn=L({tile_:aL});function sL(e,t,n,r="float32"){t==null&&(t=e);let a=Oe([e,t],r),s=e<=t?e:t;for(let o=0;o<s;++o)a.set(1,o,o);let i=P(a.toTensor(),[e,t]);if(n==null)return i;if(n.length===1)return Vn(Xt(i,0),[n[0],1,1]);if(n.length===2)return Vn(Xt(Xt(i,0),0),[n[0],n[1],1,1]);if(n.length===3)return Vn(Xt(Xt(Xt(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}var em=L({eye_:sL});function iL(e){let t={x:_(e,"x","floor","float32")};return O.runKernel(Fi,t)}var Eu=L({floor_:iL});function oL(e,t,n=0,r=0){let a=_(e,"x","gather"),s=_(t,"indices","gather","int32"),i={x:a,indices:s},o={axis:n,batchDims:r};return O.runKernel(Ul,i,o)}var $u=L({gather_:oL});function lL(e,t){let n=_(e,"a","greater","string_or_numeric"),r=_(t,"b","greater","string_or_numeric");[n,r]=Nt(n,r),lt(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(Hl,a)}var kn=L({greater_:lL});function uL(e,t){let n=_(e,"a","greaterEqual","string_or_numeric"),r=_(t,"b","greaterEqual","string_or_numeric");[n,r]=Nt(n,r),lt(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(Mi,a)}var ba=L({greaterEqual_:uL});function pL(e){let t={input:_(e,"input","imag")};return O.runKernel(Pc,t)}var kd=L({imag_:pL});function dL(e){let t={x:_(e,"x","isFinite")};return O.runKernel(Li,t)}var fv=L({isFinite_:dL});function hL(e){let t={x:_(e,"x","isInf")};return O.runKernel(zi,t)}var gv=L({isInf_:hL});function cL(e){let t={x:_(e,"x","isNaN")};return O.runKernel(Pi,t)}var yv=L({isNaN_:cL});function mL(e,t=.2){let n={x:_(e,"x","leakyRelu")},r={alpha:t};return O.runKernel(Bi,n,r)}var Id=L({leakyRelu_:mL});function fL(e,t){let n=_(e,"a","less","string_or_numeric"),r=_(t,"b","less","string_or_numeric");[n,r]=Nt(n,r),lt(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(jl,a)}var ul=L({less_:fL});function gL(e,t){let n=_(e,"a","lessEqual","string_or_numeric"),r=_(t,"b","lessEqual","string_or_numeric");[n,r]=Nt(n,r),lt(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(ql,a)}var ds=L({lessEqual_:gL});function nN(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");let r={start:e,stop:t,num:n};return O.runKernel(Kl,{},r)}function yL(e,t=5,n=1,r=1,a=.5){let s=_(e,"x","localResponseNormalization");$(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),$(al(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=s,o=!1;s.rank===3&&(o=!0,i=P(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let l={x:i},u={depthRadius:t,bias:n,alpha:r,beta:a},p=O.runKernel(Ui,l,u);return o?P(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var bv=L({localResponseNormalization_:yL});function bL(e){let t={x:_(e,"x","log","float32")};return O.runKernel(Wi,t)}var Hn=L({log_:bL});function xL(e){let t={x:_(e,"x","log1p")};return O.runKernel(Vi,t)}var Sd=L({log1p_:xL});function vL(e){return $(Ha(e),()=>"The f passed in grad(f) must be a function"),(t,n)=>{let r=_(t,"x","tf.grad","string_or_numeric"),a=n!=null?_(n,"dy","tf.grad"):null;return O.tidy(()=>{let{value:s,grads:i}=O.gradients(()=>e(r),[r],a);return a!=null&&vn(s.shape,a.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),tm(i),i[0]})}}function wL(e){return $(Ha(e),()=>"The f passed in grads(f) must be a function"),(t,n)=>{$(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let r=_p(t,"args","tf.grads","string_or_numeric"),a=n!=null?_(n,"dy","tf.grads"):null;return O.tidy(()=>{let{value:s,grads:i}=O.gradients(()=>e(...r),r,a);return a!=null&&vn(s.shape,a.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),tm(i),i})}}function kL(e){return $(Ha(e),()=>"The f passed in valueAndGrad(f) must be a function"),(t,n)=>{$(t instanceof Re,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),$(n==null||n instanceof Re,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:r,value:a}=O.gradients(()=>e(t),[t],n);return tm(r),{grad:r[0],value:a}}}function IL(e){return $(Ha(e),()=>"The f passed in valueAndGrads(f) must be a function"),(t,n)=>{$(Array.isArray(t)&&t.every(a=>a instanceof Re),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),$(n==null||n instanceof Re,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let r=O.gradients(()=>e(...t),t,n);return n!=null&&vn(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),tm(r.grads),r}}function rN(e,t){$(Ha(e),()=>"The f passed in variableGrads(f) must be a function"),$(t==null||Array.isArray(t)&&t.every(u=>u instanceof Us),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let n=t!=null;if(!n){t=[];for(let u in O.registeredVariables)t.push(O.registeredVariables[u])}let r=n?t.filter(u=>!u.trainable):null,a=t.length;t=t.filter(u=>u.trainable),$(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${a} variables is trainable.`);let s=!0,{value:i,grads:o}=O.gradients(e,t,null,s);$(o.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),$(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let l={};return t.forEach((u,p)=>{o[p]!=null&&(l[u.name]=o[p])}),r!=null&&r.forEach(u=>l[u.name]=null),{value:i,grads:l}}function Kr(e){return O.customGrad(e)}function tm(e){if(e.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function SL(e){let t={x:_(e,"x","neg")};return O.runKernel(tu,t)}var ft=L({neg_:SL});function NL(e){let t={x:_(e,"x","softplus")};return O.runKernel(bo,t)}var _o=L({softplus_:NL});function TL(e){let t=_(e,"x","logSigmoid");return Kr(n=>({value:ft(_o(ft(n))),gradFunc:r=>z(r,fr(ft(n)))}))(t)}var xv=L({logSigmoid_:TL});function CL(e,t){let n=_(e,"a","sub"),r=_(t,"b","sub");[n,r]=Nt(n,r);let a={a:n,b:r};return O.runKernel(Io,a)}var he=L({sub_:CL});function _L(e,t=-1){let n=_(e,"logits","logSoftmax");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return Kr((r,a)=>{let s=ar(r,t,!0),i=he(r,s),o=he(oe(i,"float32"),Hn(fe(pn(i),t,!0)));return a([o]),{value:o,gradFunc:(l,u)=>{let[p]=u,h=!0,d=pn(p);return he(l,z(fe(l,t,h),d))}}})(n)}var nm=L({logSoftmax_:_L});function EL(e,t=null,n=!1){let r=_(e,"x","logSumExp"),a=yr(t,r.shape),s=ar(r,a,!0),i=he(r,s),o=pn(i),l=fe(o,a),u=Hn(l),p=Z(P(s,u.shape),u);if(n){let h=Xs(p.shape,a);return P(p,h)}return p}var Nd=L({logSumExp_:EL});function $L(e,t){let n=_(e,"a","logicalAnd","bool"),r=_(t,"b","logicalAnd","bool");lt(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(Xl,a)}var gr=L({logicalAnd_:$L});function AL(e){let t={x:_(e,"x","logicalNot","bool")};return O.runKernel(Zl,t)}var Td=L({logicalNot_:AL});function FL(e,t){let n=_(e,"a","logicalOr","bool"),r=_(t,"b","logicalOr","bool");lt(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(Jl,a)}var rm=L({logicalOr_:FL});function RL(e,t){let n=_(e,"a","logicalXor","bool"),r=_(t,"b","logicalXor","bool");return lt(n.shape,r.shape),gr(rm(e,t),Td(gr(e,t)))}var vv=L({logicalXor_:RL}),Nh=2147483648;function DL(e,t,n="left"){let r=_(e,"sortedSequence","searchSorted"),a=_(t,"values","searchSorted"),s=r.shape[r.shape.length-1],i=a.shape[a.shape.length-1],o=P(r,[-1,s]),l=P(a,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(rt(l.shape)>=Nh)throw new Error(`values tensor size must less than ${Nh}`);if(o.shape[1]>=Nh)throw new Error(`trailing dim_size must less than ${Nh} for int32 output type, was ${o.shape[1]}`);let u={sortedSequence:o,values:l},p={side:n};return O.runKernel(cu,u,p)}var am=L({searchSorted_:DL});function aN(e,t){return am(e,t,"left")}function ML(e,t,n,r,a){let s=_(e,"x","maxPool"),i=1,o=s,l=!1;s.rank===3&&(l=!0,o=P(s,[1,s.shape[0],s.shape[1],s.shape[2]])),$(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),$(Jr(n,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),wn("maxPool",r,a);let u={x:o},p={filterSize:t,strides:n,pad:r,dimRoundingMode:a},h=O.runKernel(ji,u,p);return l?P(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var jt=L({maxPool_:ML});function OL(e,t=[1,1,1],n,r,a,s="NDHWC"){let i=_(e,"x","maxPool3d"),o=i,l=!1;i.rank===4&&(l=!0,o=P(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),$(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),$(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),wn("maxPool3d",r,a);let u={x:o},p={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},h=O.runKernel(Ql,u,p);return l?P(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var wv=L({maxPool3d_:OL});function LL(e,t,n,r,a=!1){let s={x:_(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:a},o=O.runKernel(nd,s,i);return{result:o[0],indexes:o[1]}}var sN=L({maxPoolWithArgmax_:LL});function zL(e,t){let n=_(e,"a","maximum"),r=_(t,"b","maximum");[n,r]=Nt(n,r),n.dtype==="bool"&&(n=oe(n,"int32"),r=oe(r,"int32")),lt(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(Hi,a)}var Yr=L({maximum_:zL});function PL(e,t=null,n=!1){let r={x:_(e,"x","mean")},a={axis:t,keepDims:n};return O.runKernel(qi,r,a)}var kt=L({mean_:PL});function It(e,t="float32"){if(Kn(e),t==="complex64"){let r=It(e,"float32"),a=It(e,"float32");return ha(r,a)}let n=Ec(rt(e),t);return O.makeTensor(n,e,t)}function En(e,t="float32"){if(Kn(e),t==="complex64"){let r=En(e,"float32"),a=It(e,"float32");return ha(r,a)}let n=Cx(rt(e),t);return O.makeTensor(n,e,t)}function iN(e,t,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(e===void 0)return[];let r=_(e,"x","meshgrid",e instanceof Re?e.dtype:"float32");if(t===void 0)return[r];let a=_(t,"y","meshgrid",t instanceof Re?t.dtype:"float32"),s=rt(r.shape),i=rt(a.shape);return n==="xy"?(r=P(r,[1,-1]),a=P(a,[-1,1]),[De(En([i,1],r.dtype),r),De(a,En([1,s],a.dtype))]):(r=P(r,[-1,1]),a=P(a,[1,-1]),[De(r,En([1,i],r.dtype)),De(En([s,1],a.dtype),a)])}function BL(e,t){let n=_(e,"a","minimum"),r=_(t,"b","minimum");[n,r]=Nt(n,r),n.dtype==="bool"&&(n=oe(n,"int32"),r=oe(r,"int32")),lt(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(Xi,a)}var Ja=L({minimum_:BL});function WL(e,t,n){$(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);let r=_(e,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");$(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);let a=n==="reflect"?1:0;for(let o=0;o<r.rank;o++)$(t[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),$(t[o][0]>=0&&t[o][0]<=r.shape[o]-a&&t[o][1]>=0&&t[o][1]<=r.shape[o]-a,()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-a} or less than 0 for input of shape ${r.shape}`);let s={paddings:t,mode:n},i={x:r};return O.runKernel(Zi,i,s)}var kv=L({mirrorPad_:WL});function VL(e,t){let n=_(e,"a","mod"),r=_(t,"b","mod");[n,r]=Nt(n,r);let a={a:n,b:r};return O.runKernel(Ji,a)}var Iv=L({mod_:VL});function UL(e,t=null,n=!1){e=_(e,"x","moments");let r=yr(t,e.shape),a=kt(e,r,n),s=a.shape;n||(s=Xs(a.shape,r));let i=it(he(oe(e,"float32"),P(a,s))),o=kt(i,r,n);return{mean:a,variance:o}}var Cd=L({moments_:UL});function GL(e,t,n,r){let a=_(t,"data","multiRNNCell"),s=_p(n,"c","multiRNNCell"),i=_p(r,"h","multiRNNCell"),o=a,l=[];for(let h=0;h<e.length;h++){let d=e[h](o,s[h],i[h]);l.push(d[0]),l.push(d[1]),o=d[1]}let u=[],p=[];for(let h=0;h<l.length;h+=2)u.push(l[h]),p.push(l[h+1]);return[u,p]}var oN=L({multiRNNCell_:GL});function HL(e,t,n,r=!1){let a=_(e,"logits","multinomial"),s=a.size,i=a.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();let o={logits:i===1?P(a,[1,-1]):a},l={numSamples:t,seed:n,normalized:r},u=O.runKernel(eu,o,l);return i===1?P(u,[u.size]):u}var lN=L({multinomial_:HL});function jL(e,t){let n=_(e,"a","notEqual","string_or_numeric"),r=_(t,"b","notEqual","string_or_numeric");[n,r]=Nt(n,r),lt(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(nu,a)}var Zs=L({notEqual_:jL});function qL(e,t,n=1,r=0,a="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let s={indices:_(e,"indices","oneHot","int32")},i={dtype:a,depth:t,onValue:n,offValue:r};return O.runKernel(Qi,s,i)}var pl=L({oneHot_:qL});function KL(e){let t={x:_(e,"x","onesLike")};return O.runKernel(iu,t)}var jn=L({onesLike_:KL});function XL(e,t){let n=_(e,"v1","outerProduct"),r=_(t,"v2","outerProduct");$(n.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);let a=P(n,[-1,1]),s=P(r,[1,-1]);return De(a,s)}var uN=L({outerProduct_:XL});function ZL(e,t,n=0){let r=_(e,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let a={paddings:t,constantValue:n},s={x:r};return O.runKernel(eo,s,a)}var Ar=L({pad_:ZL});function JL(e,t,n=0){return $(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),Ar(e,[t],n)}var pN=L({pad1d_:JL});function YL(e,t,n=0){return $(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ar(e,t,n)}var dN=L({pad2d_:YL});function QL(e,t,n=0){return $(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ar(e,t,n)}var hN=L({pad3d_:QL});function ez(e,t,n=0){return $(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ar(e,t,n)}var cN=L({pad4d_:ez});function tz(e,t,n){let r=_(e,"x","spaceToBatchND");$(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),$(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),$(r.shape.reduce((i,o,l)=>l>0&&l<=t.length?i&&(o+n[l-1][0]+n[l-1][1])%t[l-1]===0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);let a={x:r},s={blockShape:t,paddings:n};return O.runKernel(gu,a,s)}var _d=L({spaceToBatchND_:tz});function nz(e,t,n,r,a,s,i){a==null&&(a=[1,1]),s==null&&(s=1),r===0&&(r="valid");let o=_(e,"x","maxPool"),l=o,u=!1;o.rank===3&&(u=!0,l=P(o,[1,o.shape[0],o.shape[1],o.shape[2]])),$(Jr(s,a),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${a}'`);let p=VS(l.shape,t,s,a,r),h=[p.dilationHeight,p.dilationWidth],d;r==="same"?d=az([p.filterHeight,p.filterWidth],h):d=[[0,0],[0,0]];let c=h[0]===1&&h[1]===1,[m,f]=rz([p.inHeight,p.inWidth],h,d),g=c?r:"valid",y=c?l:_d(l,h,m),b=(n==="avg"?()=>ya(y,t,s,g,i):()=>jt(y,t,s,g,i))(),x=c?b:vd(b,h,f);return u?P(x,[x.shape[1],x.shape[2],x.shape[3]]):x}function rz(e,t,n){let r=n.map(p=>p[0]),a=n.map(p=>p[1]),s=e.concat(r,a),i=t.map((p,h)=>(p-s[h]%p)%p),o=a.map((p,h)=>p+i[h]),l=t.map((p,h)=>[r[h],o[h]]),u=t.map((p,h)=>[0,i[h]]);return[l,u]}function az(e,t){let n=e.map((s,i)=>s+(s-1)*(t[i]-1)).map(s=>s-1),r=n.map(s=>Math.floor(s/2)),a=n.map((s,i)=>s-r[i]);return n.map((s,i)=>[r[i],a[i]])}var Sv=L({pool_:nz});function sz(e,t){let n=_(e,"x","prelu"),r=_(t,"alpha","prelu"),a={x:n,alpha:r};return O.runKernel(no,a)}var Ed=L({prelu_:sz});function iz(e,t=null,n=!1){let r=_(e,"x","prod");r.dtype==="bool"&&(r=oe(r,"int32"));let a={x:r},s={axis:t,keepDims:n};return O.runKernel(ro,a,s)}var Nv=L({prod_:iz});function oz(e,t,n,r){let a=e.map((p,h)=>_(p,`tensors${h}`,"raggedGather","int32")),s=_(t,"paramsDenseValues","raggedGather"),i=_(n,"indices","raggedGather","int32"),o={paramsNestedSplits:a,paramsDenseValues:s,indices:i},l={outputRaggedRank:r},u=O.runKernel(Bc,o,l);return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}var mN=L({raggedGather_:oz});function lz(e,t,n){let r=_(e,"starts","raggedRange"),a=_(t,"limits","raggedRange",r.dtype),s=_(n,"deltas","raggedRange",r.dtype),i={starts:r,limits:a,deltas:s},o=O.runKernel(Wc,i);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}var fN=L({raggedRange_:lz});function uz(e,t,n,r,a){let s=_(e,"shape","raggedTensorToTensor","int32"),i=_(t,"values","raggedTensorToTensor"),o=_(n,"defaultValue","raggedTensorToTensor",i.dtype),l=r.map((h,d)=>_(h,`tensors${d}`,"raggedTensorToTensor","int32")),u={shape:s,values:i,defaultValue:o,rowPartitionTensors:l},p={rowPartitionTypes:a};return O.runKernel(Vc,u,p)}var gN=L({raggedTensorToTensor_:uz});function pz(e,t,n){Kn(e);let r=rt(e),a=null;if(n==null||n==="float32")a=new Float32Array(r);else if(n==="int32")a=new Int32Array(r);else if(n==="bool")a=new Uint8Array(r);else throw new Error(`Unknown data type ${n}`);for(let s=0;s<r;s++)a[s]=t();return O.makeTensor(a,e,n)}var yN=L({rand_:pz}),Tv=ss(Cc()),bN={};_e(bN,{TEST_EPSILON_FLOAT16:()=>xN,createVideoElement:()=>bz,encodeStrings:()=>vN,expectArrayBuffersEqual:()=>yz,expectArraysClose:()=>hz,expectArraysEqual:()=>mz,expectNumbersClose:()=>fz,expectPromiseToFail:()=>cz,expectValuesInRange:()=>gz,play:()=>xz,testEpsilon:()=>Cv});var dz=.001,xN=.1;function hz(e,t,n){return n==null&&(n=Cv()),Cb(e,t,(r,a)=>_v(r,a,n))}function Cv(){return O.backend.floatPrecision()===32?dz:xN}function Cb(e,t,n){let r=!0;if((Kt(e)||Kt(t))&&(r=!1),Kt(e)&&Kt(t)&&(r=!0),r){let i=e.constructor.name,o=t.constructor.name;if(i!==o)throw new Error(`Arrays are of different type. Actual: ${i}. Expected: ${o}`)}if(Array.isArray(e)&&Array.isArray(t)){let i=jr(e),o=jr(t);if(!fa(i,o))throw new Error(`Arrays have different shapes. Actual: [${i}]. Expected: [${o}]`)}let a=Kt(e)?e:ja(e),s=Kt(t)?t:ja(t);if(a.length!==s.length)throw new Error(`Arrays have different lengths actual: ${a.length} vs expected: ${s.length}.
Actual:   ${a}.
Expected: ${s}.`);for(let i=0;i<s.length;++i){let o=a[i],l=s[i];if(!n(o,l))throw new Error(`Arrays differ: actual[${i}] = ${o}, expected[${i}] = ${l}.
Actual:   ${a}.
Expected: ${s}.`)}typeof expect!="undefined"&&expect().nothing()}function cz(e,t){e().then(()=>t.fail(),()=>t()),typeof expect!="undefined"&&expect().nothing()}function mz(e,t){let n=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return Oa(e)||Oa(e[0])||Oa(t)||Oa(t[0])?Cb(e,n,(r,a)=>r==a):Cb(e,t,(r,a)=>_v(r,a,0))}function fz(e,t,n){if(n==null&&(n=Cv()),!_v(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);typeof expect!="undefined"&&expect().nothing()}function _v(e,t,n){return!isFinite(e)&&!isFinite(t)?!0:!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function gz(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function yz(e,t){let n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let a=0;a<r.length;a++)if(n[a]!==r[a])throw new Error(`Expected ArrayBuffer value at ${a} to be ${r[a]} but got ${n[a]} instead`)}function vN(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?vN(n):e[t]=gd(n)}return e}function bz(e){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise(n=>{t.addEventListener("loadeddata",r=>n(t)),t.load()})}async function xz(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise(t=>{e.requestVideoFrameCallback(t)})}var Ev=class{constructor(e,t,n,r,a){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let s=a||Math.random();this.random=Tv.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){let r=this.nextVal;return this.nextVal=NaN,r}let e,t,n=!1;for(;!n;){let r,a,s;do r=2*this.random()-1,a=2*this.random()-1,s=r*r+a*a;while(s>=1||s===0);let i=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*a*i,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},vz=class{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;let a=r||Math.random();this.randu=Tv.alea(a.toString()),this.randn=new Ev(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,a,s;for(;;){do r=this.randn.nextValue(),s=1+this.c*r;while(s<=0);if(s*=s*s,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-s+Math.log(s)),a=this.randu(),a<t||Math.log(a)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}},wz=class{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=n,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Tv.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function kz(e,t,n=1,r="float32",a){if(Kn(e),n==null&&(n=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);let s=new vz(t,n,r,a),i=Oe(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var wN=L({randomGamma_:kz});function Iz(e,t=0,n=1,r,a){if(Kn(e),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);let s=new Ev(t,n,r,!1,a),i=Oe(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var sm=L({randomNormal_:Iz});function Sz(e,t,n){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return sm(e,0,1,t,n)}var kN=L({randomStandardNormal_:Sz});function Nz(e,t=0,n=1,r="float32",a){Kn(e);let s=Oe(e,r),i=new wz(t,n,null,a);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}var hs=L({randomUniform_:Nz});function Tz(e,t,n,r){return hs(e,t,n,"int32",r)}var IN=L({randomUniformInt_:Tz});function Js(e,t,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");let a={start:e,stop:t,step:n,dtype:r};return O.runKernel(rd,{},a)}function Cz(e){let t={input:_(e,"input","real")};return O.runKernel(Uc,t)}var dl=L({real_:Cz});function _z(e){let t={x:_(e,"x","reciprocal")};return O.runKernel(ao,t)}var $v=L({reciprocal_:_z});function Ez(e){let t={x:_(e,"x","relu")};return O.runKernel(so,t)}var nt=L({relu_:Ez});function $z(e){let t={x:_(e,"x","relu6")};return O.runKernel(lo,t)}var im=L({relu6_:$z});function Az(e,t){let n={x:_(e,"x","reverse")},r={dims:t};return O.runKernel(uo,n,r)}var or=L({reverse_:Az});function Fz(e){let t=_(e,"x","reverse");return $(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),or(t,0)}var SN=L({reverse1d_:Fz});function Rz(e,t){let n=_(e,"x","reverse");return $(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),or(n,t)}var NN=L({reverse2d_:Rz});function Dz(e,t){let n=_(e,"x","reverse");return $(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),or(n,t)}var TN=L({reverse3d_:Dz});function Mz(e,t){let n=_(e,"x","reverse");return $(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),or(n,t)}var CN=L({reverse4d_:Mz});function Oz(e){let t={x:_(e,"x","round")};return O.runKernel(po,t)}var om=L({round_:Oz});function Lz(e){let t={x:_(e,"x","rsqrt","float32")};return O.runKernel(ho,t)}var lm=L({rsqrt_:Lz});function zz(e){let t={x:_(e,"x","selu")};return O.runKernel(co,t)}var um=L({selu_:zz});function Pz(e,t,n,r,a,s=[1,1],i="NHWC"){let o=_(e,"x","separableConv2d"),l=_(t,"depthwiseFilter","separableConv2d"),u=_(n,"pointwiseFilter","separableConv2d"),p=o,h=!1;if(o.rank===3&&(h=!0,p=P(o,[1,o.shape[0],o.shape[1],o.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");$(p.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${p.rank}.`),$(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),$(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),$(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),$(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);let d=l.shape[2],c=l.shape[3];$(u.shape[2]===d*c,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*c}, but got ${u.shape[2]}.`);let m=Co(p,l,r,a,i,s),f=bn(m,u,1,"valid",i);return h?P(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Au=L({separableConv2d_:Pz});async function Bz(e,t){let n=_(e,"x","setdiff1d"),r=_(t,"y","setdiff1d");$(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),$(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),$(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);let a=await n.data(),s=await r.data(),i=new Set(s),o=0;for(let p=0;p<a.length;p++)i.has(a[p])||o++;let l=new Rt([o],n.dtype),u=new Rt([o],"int32");for(let p=0,h=0;p<a.length;p++)i.has(a[p])||(l.values[h]=a[p],u.values[h]=p,h++);return[l.toTensor(),u.toTensor()]}var _N=Bz;function Wz(e){let t={x:_(e,"x","sign")};return O.runKernel(go,t)}var Av=L({sign_:Wz});function Vz(e){let t={x:_(e,"x","sin","float32")};return O.runKernel(mo,t)}var pm=L({sin_:Vz});function Uz(e){let t={x:_(e,"x","sinh")};return O.runKernel(fo,t)}var dm=L({sinh_:Uz});function Gz(e,t,n){let r=_(e,"x","slice1d");return $(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Ue(r,[t],[n])}var $d=L({slice1d_:Gz});function Hz(e,t,n){let r=_(e,"x","slice2d");return $(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Ue(r,t,n)}var hm=L({slice2d_:Hz});function jz(e,t,n){let r=_(e,"x","slice3d");return $(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Ue(r,t,n)}var Fu=L({slice3d_:jz});function qz(e,t,n){let r=_(e,"x","slice4d");return $(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Ue(r,t,n)}var hl=L({slice4d_:qz});function Kz(e,t=-1){let n=_(e,"logits","softmax","float32");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let r={logits:n},a={dim:t};return O.runKernel(wo,r,a)}var cs=L({softmax_:Kz});function Xz(e){$(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);let t={input:e};return O.runKernel(Lc,t)}var Ad=L({fft_:Xz});function Zz(e){$(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);let t={input:e};return O.runKernel(zc,t)}var cl=L({ifft_:Zz});function Jz(e){let t=e.shape[e.shape.length-1],n=e.size/t,r;if(t<=2){let a=P(e,[n,t]);r=cl(a)}else{let a=[n,2*(t-1)],s=P(dl(e),[n,t]),i=P(kd(e),[n,t]),o=or(Ue(s,[0,1],[n,t-2]),1),l=z(or(Ue(i,[0,1],[n,t-2]),1),ve(-1)),u=ot([s,o],1),p=ot([i,l],1),h=P(ha(u,p),[a[0],a[1]]);r=cl(h)}if(r=dl(r),e.rank===3&&e.shape[0]!==0){let a=r,s=e.shape[0];r=P(r,[s,r.shape[0]/s,r.shape[1]]),a.dispose()}return r}var cm=L({irfft_:Jz});function Yz(e,t,n=0){let r={x:_(e,"x","split")},a={numOrSizeSplits:t,axis:n};return O.runKernel(yu,r,a)}var $n=L({split_:Yz});function Qz(e,t){$(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1],r=e.size/n,a;if(t!=null&&t<n){let m=e.shape.map(g=>0),f=e.shape.map(g=>g);f[e.shape.length-1]=t,a=Ue(e,m,f),n=t}else if(t!=null&&t>n){let m=e.shape.map(f=>f);m[e.shape.length-1]=t-n,a=ot([e,It(m)],e.shape.length-1),n=t}else a=e;let s=Ge(a),i=P(ha(a,s),[r,n]),o=Ad(i),l=Math.floor(n/2)+1,u=dl(o),p=kd(o),h=$n(u,[l,n-l],u.shape.length-1),d=$n(p,[l,n-l],p.shape.length-1),c=a.shape.slice();return c[a.shape.length-1]=l,P(ha(h[0],d[0]),c)}var Fd=L({rfft_:Qz});function eP(e,t){let n=_(e,"a","squaredDifference"),r=_(t,"b","squaredDifference");[n,r]=Nt(n,r),lt(n.shape,r.shape);let a={a:n,b:r},s={};return O.runKernel(ko,a,s)}var mm=L({squaredDifference_:eP});function tP(e,t){let n=_(e,"x","squeeze","string_or_numeric");return P(n,nS(n.shape,t).newShape)}var ms=L({squeeze_:tP});function nP(e,t=0){let n=_p(e,"tensors","stack","string_or_numeric");$(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&$(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");let r=n,a={axis:t};return O.runKernel(ou,r,a)}var Dt=L({stack_:nP});function rP(e,t=0){let n={x:_(e,"x","step")},r={alpha:t};return O.runKernel(us,n,r)}var Eo=L({step_:rP});function aP(e,t,n,r,a=0,s=0,i=0,o=0,l=0){let u={x:_(e,"x","stridedSlice","string_or_numeric")},p={begin:t,end:n,strides:r,beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return O.runKernel(vu,u,p)}var Fv=L({stridedSlice_:aP});function sP(e){let t={x:_(e,"x","tan","float32")};return O.runKernel(So,t)}var Rv=L({tan_:sP});function Qe(e,t){ii(e);let n=jr(e,t);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return ps(e,null,n,t)}function Gr(e,t,n){if(ii(e),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let r=jr(e,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return ps(e,t,r,n)}function fm(e,t,n){if(ii(e),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let r=jr(e,n);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return ps(e,t,r,n)}function Ya(e,t,n){if(ii(e),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let r=jr(e,n);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return ps(e,t,r,n)}function EN(e,t,n){if(ii(e),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let r=jr(e,n);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return ps(e,t,r,n)}function $N(e,t,n){if(ii(e),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let r=jr(e,n);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||r,ps(e,t,r,n)}var gm={};_e(gm,{calculateShapes:()=>AN,validateInput:()=>ym,validateUpdateShape:()=>Dv});function Dv(e,t,n){let r=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${a}.`;if(n.rank<a)throw new Error(s+` update.rank < ${a}. `);if(e.length<r+(n.rank-a))throw new Error(s+` Output shape length < ${r+(n.rank-a)}`);if(n.rank!==a+e.length-r)throw new Error(s+` update.rank != ${a+e.length-r}`);for(let i=0;i<a;++i)if(n.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-a;++i)if(n.shape[i+a]!==e[i+r])throw new Error(s+` updates.shape[${i+a}] (${n.shape[i+a]}) != shape[${i+a}] (${e[i+a]})`)}function ym(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}Dv(n,t,e)}function AN(e,t,n){let r=t.shape.length,a=r>1?t.shape[r-1]:1,s=n.length,i=1;for(let h=a;h<s;++h)i*=n[h];let o=a<1?1:a,l=rt(t.shape)/o,u=[...Il(n.slice(0,a)),1],p=rt(n);return{sliceRank:a,numUpdates:l,sliceSize:i,strides:u,outputSize:p}}function iP(e,t,n){let r=_(e,"tensor","tensorScatterupdate"),a=_(t,"indices","tensorScatterupdate","int32"),s=_(n,"updates","tensorScatterupdate");if(ym(s,a,r.shape),r.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${s.dtype}.`);let i={tensor:r,indices:a,updates:s},o={};return O.runKernel(hu,i,o)}var FN=L({tensorScatterUpdate_:iP});function oP(e,t=1,n=!0){let r=_(e,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let a=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>a)throw new Error(`'k' passed to topk() must be <= the last dimension (${a}) but got ${t}`);let s={x:r},i={k:t,sorted:n},[o,l]=O.runKernel(wu,s,i);return{values:o,indices:l}}var Mv=L({topk_:oP});function lP(e,t=0,n=1,r,a){if(Kn(e),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new Ev(t,n,r,!0,a),i=Oe(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var bm=L({truncatedNormal_:lP});function uP(e,t=0){let n=_(e,"x","unique","string_or_numeric");$(n.rank>0,()=>"The input tensor must be at least 1D");let r={x:n},a={axis:t},[s,i]=O.runKernel(hd,r,a);return{values:s,indices:i}}var Ov=L({unique_:uP});function pP(e,t,n){let r=_(e,"x","unsortedSegmentSum"),a=_(t,"segmentIds","unsortedSegmentSum","int32");$(al(n),()=>"numSegments must be of dtype int");let s={x:r,segmentIds:a},i={numSegments:n};return O.runKernel(cd,s,i)}var xm=L({unsortedSegmentSum_:pP});function dP(e,t=0){let n=_(e,"x","unstack","string_or_numeric");$(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);let r={value:n},a={axis:t};return O.runKernel(Iu,r,a)}var Tt=L({unstack_:dP});function RN(e,t){return am(e,t,"right")}function Lv(e,t=!0,n,r){return O.makeVariable(e,t,n,r)}function DN(e,t){let n=[];for(let s=0;s<t.length;s++)t[s]&&n.push(s);let r=Oe(e,"int32"),a=Oe([n.length,e.length],"int32");for(let s=0;s<n.length;s++){let i=r.indexToLoc(n[s]),o=s*e.length;a.values.set(i,o)}return a.toTensor()}async function hP(e){let t=_(e,"condition","whereAsync","bool"),n=await t.data(),r=DN(t.shape,n);return e!==t&&t.dispose(),r}var zv=hP;async function cP(e,t,n){let r=_(e,"tensor","boolMask"),a=_(t,"mask","boolMask","bool"),s=n==null?0:n,i=a.rank,o=r.shape;$(i>0,()=>"mask cannot be scalar"),vn(o.slice(s,s+i),a.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let f=s;f<s+i;f++)l*=o[f];let u=o.slice(0,s).concat([l],o.slice(s+i)),p=P(r,u),h=P(a,[-1]),d=await zv(h),c=ms(d,[1]),m=$u(p,c,s);return e!==r&&r.dispose(),t!==a&&a.dispose(),c.dispose(),p.dispose(),h.dispose(),d.dispose(),m}var MN=cP;function mP(e,t,n){let r=_(e,"x","transpose");if(t==null&&(t=r.shape.map((i,o)=>o).reverse()),$(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(i=>{$(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`)}),r.rank<=1)return r.clone();let a={x:r},s={perm:t};return r.dtype==="complex64"?B(()=>{let i=dl(r),o=kd(r);return i=O.runKernel(ua,{x:i},s),o=O.runKernel(ua,{x:o},s),n&&(o=ft(o)),ha(i,o)}):O.runKernel(ua,a,s)}var Me=L({transpose_:mP});function fP(e,t,n,r,a=!0){let s=_(e,"v","movingAverage"),i=_(t,"x","movingAverage"),o=_(n,"decay","movingAverage");kS(s,i),$(fa(s.shape,i.shape),()=>"Shape mismatch in v and x");let l=ve(1),u=he(l,o),p=z(he(i,s),u);if(a){$(r!=null,()=>"When using zeroDebias: true, step is required.");let h=_(r,"step","movingAverage");p=ce(p,he(l,qr(o,h)))}return Z(s,p)}var ON=L({movingAverage_:fP});function gP(e,t,n){Kn(n);let r=_(e,"indices","scatterND","int32"),a=_(t,"updates","scatterND");ym(a,r,n);let s={indices:r,updates:a},i={shape:n};return O.runKernel(du,s,i)}var LN=L({scatterND_:gP});function yP(e,t,n,r){if(e.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let a=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);let i=t.size;if(!(t.rank===0||t.rank===1&&i===a))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${a}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function bP(e,t,n,r=0){Kn(n);let a=_(e,"sparseIndices","sparseToDense","int32"),s=_(t,"sparseValues","sparseToDense","string_or_numeric"),i=_(r,"defaultValue","sparseToDense",s.dtype);yP(a,s,n,i);let o={sparseIndices:a,sparseValues:s,defaultValue:i},l={outputShape:n};return O.runKernel(xu,o,l)}var zN=L({sparseToDense_:bP});function xP(e,t){let n=_(t,"indices","gatherND","int32"),r={params:_(e,"x","gatherND","string_or_numeric"),indices:n};return O.runKernel(Gl,r)}var PN=L({gatherND_:xP});function vP(e,t){if(t==null)return e.shape.slice();if(fa(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let r=0;r<e.shape.length;r++)t[r]==null&&e.shape[r]!=null?n.push(e.shape[r]):n.push(t[r]);return n}return t}function wP(e,t,n,r){let a=_(e,"x","dropout");if($(a.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${a.dtype} tensor instead.`),$(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof Re?a.clone():a;let s=vP(a,n),i=1-t,o=ce(Eu(Z(hs(s,0,1,"float32",r),i)),i);return z(a,o)}var Pv=L({dropout_:wP});function Bv(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function vm(e,t,n){let r=1-e%2,a=new Float32Array(e);for(let s=0;s<e;++s){let i=2*Math.PI*s/(e+r-1);a[s]=t-n*Math.cos(i)}return Qe(a,"float32")}async function kP(e,t,n=1){let r=_(e,"predictions","inTopK"),a=_(t,"targets","inTopK");$(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),$(r.rank-1===a.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${a.rank}`),vn(r.shape.slice(0,r.shape.length-1),a.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=r.shape[r.shape.length-1];$(n>0&&n<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`);let i=await r.data(),o=await a.data(),[l,u]=[i.length/s,s],p=rS("bool",l);for(let h=0;h<l;h++){let d=h*u,c=i.subarray(d,d+u),m=[];for(let f=0;f<c.length;f++)m.push({value:c[f],index:f});m.sort((f,g)=>g.value-f.value),p[h]=0;for(let f=0;f<n;f++)if(m[f].index===o[h]){p[h]=1;break}}return e!==r&&r.dispose(),t!==a&&a.dispose(),yn(p,a.shape,"bool")}var BN=kP,ml={};_e(ml,{conv2d:()=>NP,depthwiseConv2d:()=>EP,matMul:()=>AP});function IP(e,t,n,r,a,s="NHWC",i){let o=e;e.rank===3&&(o=P(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=P(t,[1,t.shape[0],t.shape[1],t.shape[2]])),$(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),$(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),$(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);let u=s==="NHWC"?o.shape[3]:o.shape[1],p=s==="NHWC"?l.shape[3]:l.shape[1];$(u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),$(p===n[3],()=>`Error in conv2dDerFilter: depth of dy (${p}) must match output depth for filter (${n[3]}).`),wn("conv2dDerFilter",a,i);let h={x:o,dy:l},d={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,filterShape:n};return O.runKernel(Fc,h,d)}var Wv=L({conv2DBackpropFilter_:IP});function wm(e,t,n){if(n==null||n==="linear")return e;if(n==="relu")return z(e,Eo(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function km(e,t){let n=t,r=Mt(e.shape,t.shape);return r.length>0&&(n=fe(n,r)),P(n,e.shape)}function Im(e,t,n,r){if(t==="linear")return e;if(t==="relu")return nt(e);if(t==="elu")return Cu(e);if(t==="relu6")return im(e);if(t==="prelu")return Ed(e,n);if(t==="leakyrelu")return Id(e,r);if(t==="sigmoid")return fr(e);throw new Error(`Unknown fused activation ${t}.`)}var Sm=(e,t)=>!(e>0)||t==="linear";function SP({x:e,filter:t,strides:n,pad:r,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:p}){if(l=l||"linear",Sm(O.state.gradientDepth,l)===!1){$(a==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${a} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let N=bn(e,t,n,r,a,s,i);return o!=null&&(N=Z(N,o)),Im(N,l,u,p)}let h=_(e,"x","conv2d","float32"),d=_(t,"filter","conv2d","float32"),c=h,m=!1;h.rank===3&&(m=!0,c=P(h,[1,h.shape[0],h.shape[1],h.shape[2]])),$(c.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${c.rank}.`),$(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),wn("fused conv2d",r,i);let f=a==="NHWC"?c.shape[3]:c.shape[1];$(d.shape[2]===f,()=>`Error in conv2d: depth of input (${f}) must match input depth for filter ${d.shape[2]}.`),$(Jr(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`);let g=xd(c.shape,d.shape,n,s,r,i),y;o!=null&&(y=_(o,"bias","fused conv2d"),[y]=Nt(y,h),a==="NHWC"?lt(g.outShape,y.shape):($(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),$(y.shape.length===0||y.shape[0]===g.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let b;if(u!=null){let N=u.shape;if($(N.length<=1||N.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${N.length}.`),N.length===1)$(N[0]===1||N[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${N}) is not compatible with the number of output channels (${g.outChannels}).`);else if(N.length===3)try{lt(N,g.outShape)}catch{let E=`Error in fused conv2d: PReLU activation weights (${N}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(E)}b=_(u,"prelu weights","fused conv2d")}let x=(N,C)=>{$(a==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${a} but only NHWC is currently supported.`);let[E,A,R,F]=C,S=wm(N,R,l);$(Xa(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let M=av(A.shape,S,E,n,r),W=Wv(A,S,E.shape,n,r),U=[M,W];if(F!=null){let H=km(F,S);U.push(H)}return U},v={x:c,filter:d,bias:y,preluActivationWeights:b},I={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:p};return o==null?Kr((N,C,E)=>{let A=O.runKernel(Ws,v,I);return E([C,N,A]),m&&(A=P(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:x}})(c,d):Kr((N,C,E,A)=>{let R=O.runKernel(Ws,v,I);return A([C,N,R,E]),m&&(R=P(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:x}})(c,d,y)}var NP=L({fusedConv2d_:SP});function TP(e,t,n,r,a,s=[1,1],i){let o=e;e.rank===3&&(o=P(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=P(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={x:o,dy:l},p={strides:r,pad:a,dimRoundingMode:i,dilations:s,filterShape:n};return O.runKernel(Rc,u,p)}var WN=L({depthwiseConv2dNativeBackpropFilter_:TP});function CP(e,t,n,r,a,s=[1,1],i){let o=t,l=!1;t.rank===3&&(l=!0,o=P(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={dy:o,filter:n},p={strides:r,pad:a,dimRoundingMode:i,dilations:s,inputShape:e},h=O.runKernel(Dc,u,p);return l?P(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var VN=L({depthwiseConv2dNativeBackpropInput_:CP});function _P({x:e,filter:t,strides:n,pad:r,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:p}){if(Sm(O.state.gradientDepth,l)===!1){let I=Co(e,t,n,r,a,s,i);return o!=null&&(I=Z(I,o)),Im(I,l,u,p)}let h=_(e,"x","depthwiseConv2d","float32"),d=_(t,"filter","depthwiseConv2d","float32"),c=h,m=!1;h.rank===3&&(m=!0,c=P(h,[1,h.shape[0],h.shape[1],h.shape[2]])),$(c.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),$(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),$(c.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${c.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),s==null&&(s=[1,1]),$(Jr(n,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),wn("fused depthwiseConv2d",r,i);let f=xd(c.shape,d.shape,n,s,r,i,!0),g;o!=null&&(g=_(o,"bias","fused conv2d"),[g]=Nt(g,h),lt(f.outShape,g.shape));let y;u!=null&&(y=_(u,"prelu weights","fused depthwiseConv2d"));let b=(I,N)=>{$(Xa(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[C,E,A,R]=N,F=wm(I,A,l),S=VN(E.shape,F,C,n,r,s,i),M=WN(E,F,C.shape,n,r,s,i);if(R!=null){let W=km(g,F);return[S,M,W]}return[S,M]},x={x:c,filter:d,bias:g,preluActivationWeights:y},v={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:p};return o==null?Kr((I,N,C)=>{let E=O.runKernel(Vs,x,v);return C([N,I,E]),m&&(E=P(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:b}})(c,d):Kr((I,N,C,E)=>{let A=O.runKernel(Vs,x,v);return E([N,I,A,C]),m&&(A=P(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:b}})(c,d,g)}var EP=L({fusedDepthwiseConv2d_:_P});function $P({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:a,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(Sm(O.state.gradientDepth,s)===!1){let R=De(e,t,n,r);return a!=null&&(R=Z(R,a)),Im(R,s,i,o)}let l=_(e,"a","fused matMul"),u=_(t,"b","fused matMul");[l,u]=Nt(l,u);let p=n?l.shape[l.rank-2]:l.shape[l.rank-1],h=r?u.shape[u.rank-1]:u.shape[u.rank-2],d=n?l.shape[l.rank-1]:l.shape[l.rank-2],c=r?u.shape[u.rank-2]:u.shape[u.rank-1],m=l.shape.slice(0,-2),f=u.shape.slice(0,-2),g=rt(m),y=rt(f);$(p===h,()=>`Error in fused matMul: inner shapes (${p}) and (${h}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${r} must match.`);let b=lt(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([d,c]),x=n?P(l,[g,p,d]):P(l,[g,d,p]),v=r?P(u,[y,c,h]):P(u,[y,h,c]),I;a!=null&&(I=_(a,"bias","fused matMul"),[I]=Nt(I,l),lt(b,I.shape));let N;i!=null&&(N=_(i,"prelu weights","fused matMul"));let C=(R,F)=>{let[S,M,W,U]=F,H=wm(P(R,W.shape),W,s),q,K;if(!n&&!r?(q=De(H,M,!1,!0),K=De(S,H,!0,!1)):!n&&r?(q=De(H,M,!1,!1),K=De(H,S,!0,!1)):n&&!r?(q=De(M,H,!1,!0),K=De(S,H,!1,!1)):(q=De(M,H,!0,!0),K=De(H,S,!0,!0)),a!=null){let J=km(U,H);return[q,K,J]}else return[q,K]},E={a:x,b:v,bias:I,preluActivationWeights:N},A={transposeA:n,transposeB:r,activation:s,leakyreluAlpha:o};return a==null?Kr((R,F,S)=>{let M=O.runKernel(Bs,E,A);return S([R,F,M]),{value:P(M,b),gradFunc:C}})(x,v):Kr((R,F,S,M)=>{let W=O.runKernel(Bs,E,A);return M([R,F,W,S]),{value:P(W,b),gradFunc:C}})(x,v,I)}var AP=L({fusedMatMul_:$P});function FP(e){return vm(e,.54,.46)}var RP=L({hammingWindow_:FP});function DP(e){return vm(e,.5,.5)}var UN=L({hannWindow_:DP});function MP(e,t,n,r=!1,a=0){let s=0,i=[];for(;s+t<=e.size;)i.push(Ue(e,s,t)),s+=n;if(r)for(;s<e.size;){let o=s+t-e.size,l=ot([Ue(e,s,t-o),Un([o],a)]);i.push(l),s+=n}return i.length===0?Gr([],[0,t]):P(ot(i),[i.length,t])}var GN=L({frame_:MP});function OP(e,t,n,r,a=UN){r==null&&(r=Bv(t));let s=GN(e,t,n),i=z(s,a(t));return Fd(i,r)}var LP=L({stft_:OP});function zP(e,t,n,r,a="bilinear",s=0){let i=_(e,"image","cropAndResize"),o=_(t,"boxes","cropAndResize","float32"),l=_(n,"boxInd","cropAndResize","int32"),u=o.shape[0];$(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),$(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`),$(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`),$(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),$(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),$(a==="bilinear"||a==="nearest",()=>`method must be bilinear or nearest, but was ${a}`);let p={image:i,boxes:o,boxInd:l},h={method:a,extrapolationValue:s,cropSize:r};return O.runKernel(Ll,p,h)}var PP=L({cropAndResize_:zP});function BP(e){let t=_(e,"image","flipLeftRight","float32");$(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let n={image:t};return O.runKernel(Vl,n,{})}var WP=L({flipLeftRight_:BP});function VP(e){let t=_(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];$(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),$(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);let a=new Array(t.rank);return a.fill(1,0,n),a[n]=3,Vn(t,a)}var UP=L({grayscaleToRGB_:VP});function GP(e){let t=_(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];$(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),$(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);let a=t.dtype,s=oe(t,"float32"),i=Qe([.2989,.587,.114]),o;switch(t.rank){case 2:o=As("ij,j->i",s,i);break;case 3:o=As("ijk,k->ij",s,i);break;case 4:o=As("ijkl,l->ijk",s,i);break;case 5:o=As("ijklm,m->ijkl",s,i);break;case 6:o=As("ijklmn,n->ijklm",s,i);break;default:throw new Error("Not a valid tensor rank.")}return o=Xt(o,-1),oe(o,a)}var HP=L({rgbToGrayscale_:GP});function jP(e,t,n=0,r=.5){let a=_(e,"image","rotateWithOffset","float32");$(a.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`);let s={image:a},i={radians:t,fillValue:n,center:r};return O.runKernel(Nu,s,i)}var qP=L({rotateWithOffset_:jP});function Ru(e,t,n,r,a,s){r==null&&(r=.5),a==null&&(a=Number.NEGATIVE_INFINITY),s==null&&(s=0);let i=e.shape[0];return n=Math.min(n,i),$(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),$(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),$(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),$(t.rank===1,()=>"scores must be a 1D tensor"),$(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),$(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s}}function KP(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY){let s=_(e,"boxes","nonMaxSuppression","float32"),i=_(t,"scores","nonMaxSuppression","float32"),o=Ru(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;let l={maxOutputSize:n,iouThreshold:r,scoreThreshold:a};return O.runKernel(ru,{boxes:s,scores:i},l)}var XP=L({nonMaxSuppression_:KP});function ZP(e,t,n){let r=JP(e,t,n),a=r<0?-(r+1):r;e.splice(a,0,t)}function JP(e,t,n){return QP(e,t,n||YP)}function YP(e,t){return e>t?1:e<t?-1:0}function QP(e,t,n){let r=0,a=e.length,s=0,i=!1;for(;r<a;){s=r+(a-r>>>1);let o=n(t,e[s]);o>0?r=s+1:(a=s,i=!o)}return i?r:-r-1}function HN(e,t,n,r,a){return Vv(e,t,n,r,a,0)}function jN(e,t,n,r,a,s){return Vv(e,t,n,r,a,0,!1,s,!0)}function qN(e,t,n,r,a,s){return Vv(e,t,n,r,a,s,!0)}function Vv(e,t,n,r,a,s,i=!1,o=!1,l=!1){let u=[];for(let g=0;g<t.length;g++)t[g]>a&&u.push({score:t[g],boxIndex:g,suppressBeginIndex:0});u.sort(wk);let p=s>0?-.5/s:0,h=[],d=[];for(;h.length<n&&u.length>0;){let g=u.pop(),{score:y,boxIndex:b,suppressBeginIndex:x}=g;if(y<a)break;let v=!1;for(let I=h.length-1;I>=x;--I){let N=eB(e,b,h[I]);if(N>=r){v=!0;break}if(g.score=g.score*tB(r,p,N),g.score<=a)break}g.suppressBeginIndex=h.length,v||(g.score===y?(h.push(b),d.push(g.score)):g.score>a&&ZP(u,g,wk))}let c=h.length,m=n-c;o&&m>0&&(h.push(...new Array(m).fill(0)),d.push(...new Array(m).fill(0)));let f={selectedIndices:h};return i&&(f.selectedScores=d),l&&(f.validOutputs=c),f}function eB(e,t,n){let r=e.subarray(t*4,t*4+4),a=e.subarray(n*4,n*4+4),s=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(a[0],a[2]),p=Math.min(a[1],a[3]),h=Math.max(a[0],a[2]),d=Math.max(a[1],a[3]),c=(o-s)*(l-i),m=(h-u)*(d-p);if(c<=0||m<=0)return 0;let f=Math.max(s,u),g=Math.max(i,p),y=Math.min(o,h),b=Math.min(l,d),x=Math.max(y-f,0)*Math.max(b-g,0);return x/(c+m-x)}function tB(e,t,n){let r=Math.exp(t*n*n);return n<=e?r:0}function wk(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function nB(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY){let s=_(e,"boxes","nonMaxSuppressionAsync"),i=_(t,"scores","nonMaxSuppressionAsync"),o=Ru(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;let l=await Promise.all([s.data(),i.data()]),u=l[0],p=l[1],{selectedIndices:h}=HN(u,p,n,r,a);return s!==e&&s.dispose(),i!==t&&i.dispose(),Qe(h,"int32")}var rB=nB;function aB(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=0){let i=_(e,"boxes","nonMaxSuppression"),o=_(t,"scores","nonMaxSuppression"),l=Ru(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;let u={boxes:i,scores:o},p={maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s},h=O.runKernel(su,u,p);return{selectedIndices:h[0],selectedScores:h[1]}}var sB=L({nonMaxSuppressionWithScore_:aB});async function iB(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=0){let i=_(e,"boxes","nonMaxSuppressionAsync"),o=_(t,"scores","nonMaxSuppressionAsync"),l=Ru(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;let u=await Promise.all([i.data(),o.data()]),p=u[0],h=u[1],{selectedIndices:d,selectedScores:c}=qN(p,h,n,r,a,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Qe(d,"int32"),selectedScores:Qe(c)}}var oB=iB;function lB(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=!1){let i=_(e,"boxes","nonMaxSuppression"),o=_(t,"scores","nonMaxSuppression"),l=Ru(i,o,n,r,a,null),u=l.maxOutputSize,p=l.iouThreshold,h=l.scoreThreshold,d={boxes:i,scores:o},c={maxOutputSize:u,iouThreshold:p,scoreThreshold:h,padToMaxOutputSize:s},m=O.runKernel(au,d,c);return{selectedIndices:m[0],validOutputs:m[1]}}var uB=L({nonMaxSuppressionPadded_:lB});async function pB(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=!1){let i=_(e,"boxes","nonMaxSuppressionAsync"),o=_(t,"scores","nonMaxSuppressionAsync"),l=Ru(i,o,n,r,a,null),u=l.maxOutputSize,p=l.iouThreshold,h=l.scoreThreshold,[d,c]=await Promise.all([i.data(),o.data()]),{selectedIndices:m,validOutputs:f}=jN(d,c,u,p,h,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Qe(m,"int32"),validOutputs:ve(f,"int32")}}var dB=pB;function hB(e,t,n=!1,r=!1){let a=_(e,"images","resizeBilinear");$(a.rank===3||a.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a.rank}.`),$(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),$(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=a,i=!1;a.rank===3&&(i=!0,s=P(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let[]=t,o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},u=O.runKernel(oo,o,l);return i?P(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var KN=L({resizeBilinear_:hB});function cB(e,t,n=!1,r=!1){let a=_(e,"images","resizeNearestNeighbor");$(a.rank===3||a.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a.rank}.`),$(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),$(a.dtype==="float32"||a.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),$(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=a,i=!1;a.rank===3&&(i=!0,s=P(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let[]=t,o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},u=O.runKernel(io,o,l);return i?P(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var XN=L({resizeNearestNeighbor_:cB});function mB(e,t="binary",n=!1,r=.5){let a=_(e,"image","threshold"),s=.2989,i=.587,o=.114,l=a.shape[0]*a.shape[1],u=z(Qe([r]),255),p,h,d,c;if($(a.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${a.rank}.`),$(a.shape[2]===3||a.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${a.shape[2]}.`),$(a.dtype==="int32"||a.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${a.dtype}.`),$(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),a.shape[2]===3){[p,h,d]=$n(a,[1,1,1],-1);let f=z(p,s),g=z(h,i),y=z(d,o);c=Z(Z(f,g),y)}else c=e;if(t==="otsu"){let f=Yx(oe(om(c),"int32"),yn([]),256);u=fB(f,l)}let m=n?ds(c,u):kn(c,u);return oe(z(m,255),"int32")}function fB(e,t){let n=Qe([-1]),r=Qe([0]),a=Qe([0]),s,i,o,l,u,p;for(let h=0;h<e.size-1;h++){s=Ue(e,0,h+1),i=Ue(e,h+1),u=ce(fe(s),t),p=ce(fe(i),t);let d=fe(z(s,Js(0,s.size)));o=ce(d,fe(s));let c=Un(i.shape,s.size),m=Z(Js(0,i.size),c),f=z(i,m);l=ce(fe(f),fe(i));let g=he(o,l),y=he(o,l),b=z(u,p);a=z(z(b,g),y);let x=kn(a,r);r=Jt(x,a,r),n=Jt(x,Qe([h]),n)}return n}var gB=L({threshold_:mB});function yB(e,t,n="nearest",r="constant",a=0,s){let i=_(e,"image","transform","float32"),o=_(t,"transforms","transform","float32");$(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),$(o.rank===2&&(o.shape[0]===i.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),$(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let l={image:i,transforms:o},u={interpolation:n,fillMode:r,fillValue:a,outputShape:s};return O.runKernel(ku,l,u)}var bB=L({transform_:yB});function xB(e,t,n){let r=_(e,"a","bandPart");$(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);let a=r.shape,[s,i]=r.shape.slice(-2),o,l;typeof t=="number"?($(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),$(t<=s,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`),o=_(t<0?s:t,"numLower","bandPart")):($(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=Jt(ul(t,0),s,Ja(t,s))),typeof n=="number"?($(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),$(n<=i,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`),l=_(n<0?i:n,"numUpper","bandPart")):($(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=Jt(ul(n,0),i,Ja(n,i)));let u=P(Js(0,s,1,"int32"),[-1,1]),p=Js(0,i,1,"int32"),h=he(u,p),d=gr(ds(h,o),ba(h,ft(l))),c=It([s,i],r.dtype);return P(Dt(Tt(P(r,[-1,s,i])).map(m=>Jt(d,m,c))),a)}var vB=L({bandPart_:xB});function wB(e){let t;if(Array.isArray(e)){t=!1,$(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let a=e[0].shape[0];for(let s=1;s<e.length;++s)$(e[s].shape[0]===a,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[s].shape[0]} vs. ${a})`)}else t=!0,e=$n(e,e.shape[0],0).map(a=>ms(a,[0]));$(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);let n=[],r=e;for(let a=0;a<e.length;++a)n.push(O.tidy(()=>{let s=r[a];if(a>0)for(let i=0;i<a;++i){let o=z(fe(z(n[i],s)),n[i]);s=he(s,o)}return ce(s,_u(s,"euclidean"))}));return t?Dt(n,0):n}var kB=L({gramSchmidt_:wB});function IB(e,t=!1){if($(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return kk(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce((l,u)=>l*u),r=Tt(P(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),a=[],s=[];r.forEach(l=>{let[u,p]=kk(l,t);a.push(u),s.push(p)});let i=P(Dt(a,0),e.shape),o=P(Dt(s,0),e.shape);return[i,o]}}function kk(e,t=!1){return O.tidy(()=>{$(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);let n=e.shape[0],r=e.shape[1],a=em(n),s=Ur(e),i=Gr([[1]],[1,1]),o=Ur(i),l=n>=r?r:n;for(let u=0;u<l;++u){let p=s,h=o,d=a;[o,s,a]=O.tidy(()=>{let c=Ue(s,[u,u],[n-u,1]),m=_u(c),f=Ue(s,[u,u],[1,1]),g=Jt(kn(f,0),Gr([[-1]]),Gr([[1]])),y=he(f,z(g,m)),b=ce(c,y);b.shape[0]===1?o=Ur(i):o=ot([i,Ue(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);let x=ft(ce(De(g,y),m)),v=Ue(s,[u,0],[n-u,r]),I=z(x,o),N=Me(o);if(u===0)s=he(v,De(I,De(N,v)));else{let A=he(v,De(I,De(N,v)));s=ot([Ue(s,[0,0],[u,r]),A],0)}let C=Me(I),E=Ue(a,[0,u],[n,a.shape[1]-u]);if(u===0)a=he(E,De(De(E,o),C));else{let A=he(E,De(De(E,o),C));a=ot([Ue(a,[0,0],[n,u]),A],1)}return[o,s,a]}),Ce([p,h,d])}return!t&&n>r&&(a=Ue(a,[0,0],[n,r]),s=Ue(s,[0,0],[r,r])),[a,s]})}var SB=L({qr_:IB}),fn;(function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(fn||(fn={}));function NB(e,t,n=fn.SUM_BY_NONZERO_WEIGHTS){let r=_(e,"losses","computeWeightedLoss"),a=null;t!=null&&(a=_(t,"weights","computeWeightedLoss"));let s=a==null?r:z(r,a);if(n===fn.NONE)return s;if(n===fn.SUM)return fe(s);if(n===fn.MEAN){if(a==null)return kt(s);{let i=r.size/a.size,o=ce(fe(s),fe(a));return i>1?ce(o,ve(i)):o}}if(n===fn.SUM_BY_NONZERO_WEIGHTS){if(a==null)return ce(fe(s),ve(r.size));{let i=z(a,En(r.shape)),o=oe(fe(Zs(i,ve(0))),"float32");return ce(fe(s),o)}}throw Error(`Unknown reduction: ${n}`)}var xa=L({computeWeightedLoss_:NB});function TB(e,t,n,r=fn.SUM_BY_NONZERO_WEIGHTS){let a=_(e,"labels","absoluteDifference"),s=_(t,"predictions","absoluteDifference"),i=null;n!=null&&(i=_(n,"weights","absoluteDifference")),vn(a.shape,s.shape,"Error in absoluteDifference: ");let o=At(he(a,s));return xa(o,i,r)}var CB=L({absoluteDifference_:TB});function _B(e,t,n,r,a=fn.SUM_BY_NONZERO_WEIGHTS){let s=_(e,"labels","cosineDistance"),i=_(t,"predictions","cosineDistance"),o=null;r!=null&&(o=_(r,"weights","cosineDistance")),vn(s.shape,i.shape,"Error in cosineDistance: ");let l=ve(1),u=he(l,fe(z(s,i),n,!0));return xa(u,o,a)}var EB=L({cosineDistance_:_B});function $B(e,t,n,r=fn.SUM_BY_NONZERO_WEIGHTS){let a=_(e,"labels","hingeLoss"),s=_(t,"predictions","hingeLoss"),i=null;n!=null&&(i=_(n,"weights","hingeLoss")),vn(a.shape,s.shape,"Error in hingeLoss: ");let o=ve(1);a=he(z(ve(2),a),o);let l=nt(he(o,z(a,s)));return xa(l,i,r)}var AB=L({hingeLoss_:$B});function FB(e,t,n,r=1,a=fn.SUM_BY_NONZERO_WEIGHTS){let s=_(e,"labels","huberLoss"),i=_(t,"predictions","huberLoss"),o=null;n!=null&&(o=_(n,"weights","huberLoss")),vn(s.shape,i.shape,"Error in huberLoss: ");let l=ve(r),u=At(he(i,s)),p=Ja(u,l),h=he(u,p),d=Z(z(ve(.5),it(p)),z(l,h));return xa(d,o,a)}var RB=L({huberLoss_:FB});function DB(e,t,n,r=1e-7,a=fn.SUM_BY_NONZERO_WEIGHTS){let s=_(e,"labels","logLoss"),i=_(t,"predictions","logLoss"),o=null;n!=null&&(o=_(n,"weights","logLoss")),vn(s.shape,i.shape,"Error in logLoss: ");let l=ve(1),u=ve(r),p=ft(z(s,Hn(Z(i,u)))),h=z(he(l,s),Hn(Z(he(l,i),u))),d=he(p,h);return xa(d,o,a)}var MB=L({logLoss_:DB});function OB(e,t,n,r=fn.SUM_BY_NONZERO_WEIGHTS){let a=_(e,"labels","meanSquaredError"),s=_(t,"predictions","meanSquaredError"),i=null;n!=null&&(i=_(n,"weights","meanSquaredError")),vn(a.shape,s.shape,"Error in meanSquaredError: ");let o=mm(a,s);return xa(o,i,r)}var LB=L({meanSquaredError_:OB});function zB(e,t){let n=_(e,"labels","sigmoidCrossEntropyWithLogits"),r=_(t,"logits","sigmoidCrossEntropyWithLogits");vn(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let a=nt(r),s=z(r,n),i=Sd(pn(ft(At(r))));return Z(he(a,s),i)}function PB(e,t,n,r=0,a=fn.SUM_BY_NONZERO_WEIGHTS){let s=_(e,"multiClassLabels","sigmoidCrossEntropy"),i=_(t,"logits","sigmoidCrossEntropy"),o=null;if(n!=null&&(o=_(n,"weights","sigmoidCrossEntropy")),vn(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){let u=ve(r),p=ve(1),h=ve(.5);s=Z(z(s,he(p,u)),z(h,u))}let l=zB(s,i);return xa(l,o,a)}var BB=L({sigmoidCrossEntropy_:PB});function WB(e,t,n=-1){if(n===-1&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return Kr((r,a,s)=>{let i=Nd(a,[n],!0),o=he(oe(a,"float32"),i);s([r,o]);let l=ft(z(o,r));return{value:fe(l,[n]),gradFunc:(u,p)=>{let[h,d]=p,c=Xs(u.shape,[n]);return[z(P(u,c),he(oe(h,"float32"),pn(d))),z(P(u,c),he(pn(d),oe(h,"float32")))]}}})(e,t)}function VB(e,t,n,r=0,a=fn.SUM_BY_NONZERO_WEIGHTS){let s=_(e,"onehotLabels","softmaxCrossEntropy"),i=_(t,"logits","softmaxCrossEntropy"),o=null;if(n!=null&&(o=_(n,"weights","softmaxCrossEntropy")),vn(s.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){let u=ve(r),p=ve(1),h=ve(s.shape[1]);s=Z(z(s,he(p,u)),ce(u,h))}let l=WB(s,i);return xa(l,o,a)}var UB=L({softmaxCrossEntropy_:VB});function GB(e,t,n,r){let a=_(e,"indices","sparseFillEmptyRows","int32"),s=_(t,"values","sparseFillEmptyRows"),i=_(n,"denseShape","sparseFillEmptyRows","int32"),o=_(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(a.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${a.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);let l={indices:a,values:s,denseShape:i,defaultValue:o},u=O.runKernel(ad,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}var HB=L({sparseFillEmptyRows_:GB});function jB(e,t,n){let r=_(e,"inputIndices","sparseReshape","int32"),a=_(t,"inputShape","sparseReshape","int32"),s=_(n,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(a.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${a.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:r,inputShape:a,newShape:s},o=O.runKernel(bu,i);return{outputIndices:o[0],outputShape:o[1]}}var qB=L({sparseReshape_:jB});function KB(e,t,n){let r=_(e,"data","sparseSegmentMean"),a=_(t,"indices","sparseSegmentMean","int32"),s=_(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${a.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);let i={data:r,indices:a,segmentIds:s};return O.runKernel(sd,i)}var XB=L({sparseSegmentMean_:KB});function ZB(e,t,n){let r=_(e,"data","sparseSegmentSum"),a=_(t,"indices","sparseSegmentSum","int32"),s=_(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${a.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);let i={data:r,indices:a,segmentIds:s};return O.runKernel(id,i)}var JB=L({sparseSegmentSum_:ZB});function YB(e,t,n,r,a,s,i,o){let l=_(e,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);let u=_(t,"dataSplits","stringNGrams");if(u.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let p={separator:n,nGramWidths:r,leftPad:a,rightPad:s,padWidth:i,preserveShortSequences:o},h={data:l,dataSplits:u},d=O.runKernel(ud,h,p);return{nGrams:d[0],nGramsSplits:d[1]}}var QB=L({stringNGrams_:YB});function eW(e,t,n=!0){let r=_(e,"input","stringSplit","string"),a=_(t,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(a.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${a.shape}`);let s={skipEmpty:n},i={input:r,delimiter:a},o=O.runKernel(pd,i,s);return{indices:o[0],values:o[1],shape:o[2]}}var tW=L({stringSplit_:eW});function nW(e,t){let n=_(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let a={input:n};return O.runKernel(dd,a,r)}var rW=L({stringToHashBucketFast_:nW});function aW(e,t,n,r=!0){let a=_(e,"input","staticRegexReplace","string"),s={pattern:t,rewrite:n,replaceGlobal:r};return O.runKernel(ld,{x:a},s)}var sW=L({staticRegexReplace_:aW}),ZN={fft:Ad,ifft:cl,rfft:Fd,irfft:cm},JN={hammingWindow:RP,hannWindow:UN,frame:GN,stft:LP},er={flipLeftRight:WP,grayscaleToRGB:UP,resizeNearestNeighbor:XN,resizeBilinear:KN,rgbToGrayscale:HP,rotateWithOffset:qP,cropAndResize:PP,nonMaxSuppression:XP,nonMaxSuppressionAsync:rB,nonMaxSuppressionWithScore:sB,nonMaxSuppressionWithScoreAsync:oB,nonMaxSuppressionPadded:uB,nonMaxSuppressionPaddedAsync:dB,threshold:gB,transform:bB},Uv={bandPart:vB,gramSchmidt:kB,qr:SB},YN={absoluteDifference:CB,computeWeightedLoss:xa,cosineDistance:EB,hingeLoss:AB,huberLoss:RB,logLoss:MB,meanSquaredError:LB,sigmoidCrossEntropy:BB,softmaxCrossEntropy:UB},QN={sparseFillEmptyRows:HB,sparseReshape:qB,sparseSegmentMean:XB,sparseSegmentSum:JB},e2={stringNGrams:QB,stringSplit:tW,stringToHashBucketFast:rW,staticRegexReplace:sW},ne={};_e(ne,{Serializable:()=>t2,SerializationMap:()=>n2,getRegisteredName:()=>oW,registerClass:()=>r2});var iW=new Map,_b=new Map,t2=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},n2=class Yo{constructor(){this.classNameMap={}}static getMap(){return Yo.instance==null&&(Yo.instance=new Yo),Yo.instance}static register(t){Yo.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function r2(e,t,n){$(e.className!=null,()=>"Class being registered does not have the static className property defined."),$(typeof e.className=="string",()=>"className is required to be a string, but got type "+typeof e.className),$(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t=="undefined"&&(t="Custom"),typeof n=="undefined"&&(n=e.className);let r=n,a=t+">"+r;return n2.register(e),iW.set(a,e),_b.set(e,a),e}function oW(e){return _b.has(e)?_b.get(e):e.className}var va=class extends t2{minimize(e,t=!1,n){let{value:r,grads:a}=this.computeGradients(e,n);if(n!=null){let s=n.map(i=>({name:i.name,tensor:a[i.name]}));this.applyGradients(s)}else this.applyGradients(a);return Ce(a),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return rN(e,t)}dispose(){this.iterations_!=null&&Ce(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:ve(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(va,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});var Gv=class extends va{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=O.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=O.registeredVariables[t],a=!1;this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:B(()=>Ge(r).variable(a))}),this.accumulatedUpdates[n]==null&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:B(()=>Ge(r).variable(a))});let s=Array.isArray(e)?e[n].tensor:e[t];if(s==null)return;let i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;B(()=>{let l=Z(z(i,this.rho),z(it(s),1-this.rho)),u=z(ce(Yt(Z(o,this.epsilon)),Yt(Z(i,this.epsilon))),s),p=Z(z(o,this.rho),z(it(u),1-this.rho));i.assign(l),o.assign(p);let h=Z(z(u,-this.learningRate),r);r.assign(h)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Ce(this.accumulatedGrads.map(e=>e.variable)),Ce(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},Hv=class extends va{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=O.registeredVariables[t];this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:B(()=>Un(r.shape,this.initialAccumulatorValue).variable(!1))});let a=Array.isArray(e)?e[n].tensor:e[t];if(a==null)return;let s=this.accumulatedGrads[n].variable;B(()=>{let i=Z(s,it(a));s.assign(i);let o=Z(z(ce(a,Yt(Z(i,O.backend.epsilon()))),-this.learningRate),r);r.assign(o)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Ce(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulatedGrads=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},jv=class extends va{static get className(){return"Adam"}constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],B(()=>{this.accBeta1=ve(t).variable(),this.accBeta2=ve(n).variable()}),r==null&&(this.epsilon=O.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);B(()=>{let n=he(1,this.accBeta1),r=he(1,this.accBeta2);t.forEach((a,s)=>{let i=O.registeredVariables[a],o=!1;this.accumulatedFirstMoment[s]==null&&(this.accumulatedFirstMoment[s]={originalName:`${a}/m`,variable:B(()=>Ge(i).variable(o))}),this.accumulatedSecondMoment[s]==null&&(this.accumulatedSecondMoment[s]={originalName:`${a}/v`,variable:B(()=>Ge(i).variable(o))});let l=Array.isArray(e)?e[s].tensor:e[a];if(l==null)return;let u=this.accumulatedFirstMoment[s].variable,p=this.accumulatedSecondMoment[s].variable,h=Z(z(u,this.beta1),z(l,1-this.beta1)),d=Z(z(p,this.beta2),z(it(l),1-this.beta2)),c=ce(h,n),m=ce(d,r);u.assign(h),p.assign(d);let f=Z(z(ce(c,Z(Yt(m),this.epsilon)),-this.learningRate),i);i.assign(f)}),this.accBeta1.assign(z(this.accBeta1,this.beta1)),this.accBeta2.assign(z(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Ce(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Ce(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),B(()=>{this.accBeta1.assign(qr(this.beta1,this.iterations_+1)),this.accBeta2.assign(qr(this.beta2,this.iterations_+1))});let t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},qv=class extends va{static get className(){return"Adamax"}constructor(e,t,n,r=null,a=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],B(()=>{this.iteration=ve(0).variable(),this.accBeta1=ve(t).variable()}),r==null&&(this.epsilon=O.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);B(()=>{let n=he(1,this.accBeta1),r=ce(-this.learningRate,Z(z(this.iteration,this.decay),1));t.forEach((a,s)=>{let i=O.registeredVariables[a],o=!1;this.accumulatedFirstMoment[s]==null&&(this.accumulatedFirstMoment[s]={originalName:`${a}/m`,variable:Ge(i).variable(o)}),this.accumulatedWeightedInfNorm[s]==null&&(this.accumulatedWeightedInfNorm[s]={originalName:`${a}/v`,variable:Ge(i).variable(o)});let l=Array.isArray(e)?e[s].tensor:e[a];if(l==null)return;let u=this.accumulatedFirstMoment[s].variable,p=this.accumulatedWeightedInfNorm[s].variable,h=Z(z(u,this.beta1),z(l,1-this.beta1)),d=z(p,this.beta2),c=At(l),m=Yr(d,c);u.assign(h),p.assign(m);let f=Z(z(ce(r,n),ce(h,Z(m,this.epsilon))),i);i.assign(f)}),this.iteration.assign(Z(this.iteration,1)),this.accBeta1.assign(z(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Ce(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Ce(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},Nm=class extends va{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=Array.isArray(e)?e[n].tensor:e[t];if(r==null)return;let a=O.registeredVariables[t];B(()=>{let s=Z(z(this.c,r),a);a.assign(s)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=zt(ve(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}},Kv=class extends Nm{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=ve(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=O.registeredVariables[t];this.accumulations[n]==null&&(this.accumulations[n]={originalName:`${t}/momentum`,variable:B(()=>Ge(r).variable(!1))});let a=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];s!=null&&B(()=>{let i,o=Z(z(this.m,a),s);this.useNesterov?i=Z(z(this.c,Z(s,z(o,this.m))),r):i=Z(z(this.c,o),r),a.assign(o),r.assign(i)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Ce(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulations=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},Xv=class extends va{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,r=null,a=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,r==null&&(this.epsilon=O.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=O.registeredVariables[t],a=!1;this.accumulatedMeanSquares[n]==null&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:B(()=>Ge(r).variable(a))}),this.accumulatedMoments[n]==null&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:B(()=>Ge(r).variable(a))}),this.accumulatedMeanGrads[n]==null&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:B(()=>Ge(r).variable(a))});let s=Array.isArray(e)?e[n].tensor:e[t];if(s==null)return;let i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;B(()=>{let l=Z(z(i,this.decay),z(it(s),1-this.decay));if(this.centered){let u=this.accumulatedMeanGrads[n].variable,p=Z(z(u,this.decay),z(s,1-this.decay)),h=ce(z(s,this.learningRate),Yt(he(l,Z(it(p),this.epsilon)))),d=Z(z(o,this.momentum),h);i.assign(l),u.assign(p),o.assign(d);let c=he(r,d);r.assign(c)}else{let u=Z(z(i,this.decay),z(it(s),1-this.decay)),p=Z(z(o,this.momentum),ce(z(s,this.learningRate),Yt(Z(u,this.epsilon))));i.assign(u),o.assign(p);let h=he(r,p);r.assign(h)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Ce(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Ce(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Ce(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},lW=[Gv,Hv,jv,qv,Kv,Xv,Nm];function uW(){for(let e of lW)r2(e)}var an={};_e(an,{CompositeArrayBuffer:()=>ga,browserFiles:()=>gW,browserHTTPRequest:()=>kW,concatenateArrayBuffers:()=>ZM,copyModel:()=>bO,decodeWeights:()=>ES,decodeWeightsStream:()=>AS,encodeWeights:()=>GM,fromMemory:()=>SW,fromMemorySync:()=>l2,getLoadHandlers:()=>aO,getModelArtifactsForJSON:()=>Lx,getModelArtifactsForJSONSync:()=>RS,getModelArtifactsInfoForJSON:()=>bd,getSaveHandlers:()=>rO,getWeightSpecs:()=>kb,http:()=>Jv,isHTTPScheme:()=>$b,listModels:()=>gO,loadWeights:()=>bW,moveModel:()=>xO,registerLoadRouter:()=>nO,registerSaveRouter:()=>tO,removeModel:()=>yO,weightsLoaderFactory:()=>s2,withSaveHandler:()=>NW,withSaveHandlerSync:()=>TW});var pW="model",dW=".json",hW=".weights.bin";function Ik(e){return new Promise(t=>setTimeout(t)).then(e)}var sc=class Eb{constructor(t){if(!G().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(Eb.URL_SCHEME)&&(t=t.slice(Eb.URL_SCHEME.length)),(t==null||t.length===0)&&(t=pW),this.modelJsonFileName=t+dW,this.weightDataFileName=t+hW}async save(t){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let n=ga.join(t.weightData),r=window.URL.createObjectURL(new Blob([n],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let a=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],s=FS(t,a),i=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=i,await Ik(()=>o.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){let l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=r,await Ik(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:bd(t)}}}};sc.URL_SCHEME="downloads://";var cW=class{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let n=new FileReader;n.onload=r=>{let a=JSON.parse(r.target.result),s=a.modelTopology;if(s==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(a.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:s});return}let i=Lx(a,o=>this.loadWeights(o));e(i)},n.onerror=r=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){let t=[],n=[];for(let s of e)t.push(...s.weights),n.push(...s.paths);let r=this.checkManifestAndWeightFiles(e),a=n.map(s=>this.loadWeightsFile(s,r[s]));return Promise.all(a).then(s=>[t,s])}loadWeightsFile(e,t){return new Promise((n,r)=>{let a=new FileReader;a.onload=s=>{let i=s.target.result;n(i)},a.onerror=s=>r(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map(a=>vk(a.name)),r={};for(let a of e)a.paths.forEach(s=>{let i=vk(s);if(t.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(t.push(i),n.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);r[s]=this.weightsFiles[n.indexOf(i)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}},mW=e=>G().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(sc.URL_SCHEME)?fW(e.slice(sc.URL_SCHEME.length)):null;ir.registerSaveRouter(mW);function fW(e="model"){return new sc(e)}function gW(e){return new cW(e)}function Sk(e,t,n,r){i(e),n=n==null?0:n,r=r==null?1:r,o(n,r);let a=0,s=l=>(l.then(u=>{let p=n+ ++a/e.length*(r-n);return t(p),u}),l);function i(l){$(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function o(l,u){$(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),$(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),$(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(e.map(s))}async function a2(e,t){t==null&&(t={});let n=t.fetchFunc==null?G().platform.fetch:t.fetchFunc,r=e.map(s=>n(s,t.requestInit,{isBinary:!0})),a=(t.onProgress==null?await Promise.all(r):await Sk(r,t.onProgress,0,.5)).map(s=>s.arrayBuffer());return t.onProgress==null?await Promise.all(a):await Sk(a,t.onProgress,.5,1)}function yW(e,t){var n;let r=t.fetchFunc==null?G().platform.fetch:t.fetchFunc,a=0,s;return(n=t.onProgress)===null||n===void 0||n.call(t,0),new ReadableStream({pull:async i=>{for(var o;a<e.length;){s||(s=(await r(e[a],t.requestInit,{isBinary:!0})).body.getReader());let{done:l,value:u}=await s.read();if(l){a++,s=void 0,(o=t.onProgress)===null||o===void 0||o.call(t,a/e.length);continue}i.enqueue(u);return}i.close()}})}async function bW(e,t="",n,r){return s2(a=>a2(a,{requestInit:r}))(e,t,n)}function s2(e){return async(t,n="",r)=>{let a=t.map(()=>!1),s={},i=r!=null?r.map(()=>!1):[],o=[];if(t.forEach((c,m)=>{let f=0;c.weights.forEach(g=>{let y="quantization"in g?g.quantization.dtype:g.dtype,b=Gs[y]*rt(g.shape),x=()=>{a[m]=!0,s[m]==null&&(s[m]=[]),s[m].push({manifestEntry:g,groupOffset:f,sizeBytes:b})};r!=null?r.forEach((v,I)=>{v===g.name&&(x(),i[I]=!0)}):x(),o.push(g.name),f+=b})}),!i.every(c=>c)){let c=r.filter((m,f)=>!i[f]);throw new Error(`Could not find weights in manifest with names: ${c.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}let l=a.reduce((c,m,f)=>(m&&c.push(f),c),[]),u=[];l.forEach(c=>{t[c].paths.forEach(m=>{let f=n+(n.endsWith("/")?"":"/")+m;u.push(f)})});let p=await e(u),h={},d=0;return l.forEach(c=>{let m=t[c].paths.length,f=new ga(p.slice(d,d+m));s[c].forEach(g=>{let y=f.slice(g.groupOffset,g.groupOffset+g.sizeBytes),b=ES(y,[g.manifestEntry]);for(let x in b)h[x]=b[x]}),d+=m}),h}}var xW="application/octet-stream",vW="application/json",Zv=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?($(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=G().platform.fetch,$(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&$(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=FS(e,n);if(t.body.append("model.json",new Blob([JSON.stringify(r)],{type:vW}),"model.json"),e.weightData!=null){let s=ga.join(e.weightData);t.body.append("model.weights.bin",new Blob([s],{type:xW}),"model.weights.bin")}let a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:bd(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async loadModelJSON(){let e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let s=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?s+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":s+=" Please make sure the server is serving valid JSON for this request.",new Error(s)}let n=t.modelTopology,r=t.weightsManifest;if(n==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();let e=await this.loadModelJSON();return Lx(e,t=>this.loadWeights(t))}async loadStream(){let e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=kb(e.weightsManifest),r=()=>yW(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:r})}async getWeightUrls(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=wW(t),a=this.weightPathPrefix||n,s=[],i=[];for(let o of e)for(let l of o.paths)this.weightUrlConverter!=null?i.push(this.weightUrlConverter(l)):s.push(a+l+r);return this.weightUrlConverter&&s.push(...await Promise.all(i)),s}async loadWeights(e){let t=await this.getWeightUrls(e),n=kb(e),r=await a2(t,this.loadOptions);return[n,r]}};Zv.URL_SCHEME_REGEX=/^https?:\/\//;function wW(e){let t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),a=n>t?e.substring(n):"";return[r+"/",a]}function $b(e){return e.match(Zv.URL_SCHEME_REGEX)!=null}var i2=(e,t)=>{if(typeof fetch=="undefined"&&(t==null||t.fetchFunc==null))return null;{let n=!0;if(Array.isArray(e)?n=e.every(r=>$b(r)):n=$b(e),n)return Jv(e,t)}return null};ir.registerSaveRouter(i2);ir.registerLoadRouter(i2);function Jv(e,t){return new Zv(e,t)}function kW(e,t){return Jv(e,t)}var Qy=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},o2=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},IW=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function SW(e,t,n,r){let a=arguments;return new IW(l2(...a))}function l2(e,t,n,r){return arguments.length===1?e.modelTopology!=null||e.weightSpecs!=null?new Qy(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Qy({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Qy({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r}))}function NW(e){return new o2(e)}function TW(e){return new o2(e)}var u2={};_e(u2,{confusionMatrix:()=>_W});function CW(e,t,n){let r=_(e,"labels","confusionMatrix"),a=_(t,"predictions","confusionMatrix");$(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),$(r.rank===1,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),$(a.rank===1,()=>`Expected the rank of predictions to be 1, but got ${a.rank}`),$(r.shape[0]===a.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${a.shape[0]}. Labels and predictions should have the same number of elements.`),$(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);let s=pl(oe(r,"int32"),n),i=pl(oe(a,"int32"),n),o=Me(s),l=De(o,i);return oe(l,"int32")}var _W=L({confusionMatrix_:CW}),Rd={};_e(Rd,{draw:()=>OW,fromPixels:()=>LW,fromPixelsAsync:()=>RW,toPixels:()=>MW});var Ns,Nk=!1;function p2(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(e==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,a=!1,s=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if(typeof ImageData!="undefined"&&e instanceof ImageData)r=!0;else if(typeof HTMLVideoElement!="undefined"&&e instanceof HTMLVideoElement)a=!0;else if(typeof HTMLImageElement!="undefined"&&e instanceof HTMLImageElement)s=!0;else if(e.getContext!=null)i=!0;else if(typeof ImageBitmap!="undefined"&&e instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(Tp(ec,O.backendName)!=null){let d={pixels:e},c={numChannels:t};return O.runKernel(ec,d,c)}let[l,u]=a?[e.videoWidth,e.videoHeight]:[e.width,e.height],p;if(i)p=e.getContext("2d").getImageData(0,0,l,u).data;else if(r||n)p=e.data;else if(s||a||o){if(Ns==null)if(typeof document=="undefined")if(typeof OffscreenCanvas!="undefined"&&typeof OffscreenCanvasRenderingContext2D!="undefined")Ns=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Ns=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Ns.canvas.width=l,Ns.canvas.height=u,Ns.drawImage(e,0,0,l,u),p=Ns.getImageData(0,0,l,u).data}let h;if(t===4)h=new Int32Array(p);else{let d=l*u;h=new Int32Array(d*t);for(let c=0;c<d;c++)for(let m=0;m<t;++m)h[c*t+m]=p[c*4+m]}return fm(h,[u,l,t],"int32")}function EW(e){return e!=null&&e.data instanceof Uint8Array}function $W(){return typeof window!="undefined"&&typeof ImageBitmap!="undefined"&&window.hasOwnProperty("createImageBitmap")}function AW(e){return e!=null&&e.width!==0&&e.height!==0}function FW(e){return $W()&&!(e instanceof ImageBitmap)&&AW(e)&&!EW(e)}async function RW(e,t=3){let n=null;if(G().getBool("WRAP_TO_IMAGEBITMAP")&&FW(e)){let r;try{r=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch{r=null}r!=null&&r.width===e.width&&r.height===e.height?n=r:n=e}else n=e;return p2(n,t)}function d2(e){if(e.rank!==2&&e.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let t=e.rank===2?1:e.shape[2];if(t>4||t===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if(e.dtype!=="float32"&&e.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}function DW(e){let t=(e==null?void 0:e.alpha)||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}async function MW(e,t){let n=_(e,"img","toPixels");if(!(e instanceof Re)){let u=n;n=oe(u,"int32"),u.dispose()}d2(n);let[r,a]=n.shape.slice(0,2),s=n.rank===2?1:n.shape[2],i=await n.data(),o=n.dtype==="float32"?255:1,l=new Uint8ClampedArray(a*r*4);for(let u=0;u<r*a;++u){let p=[0,0,0,255];for(let d=0;d<s;d++){let c=i[u*s+d];if(n.dtype==="float32"){if(c<0||c>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${c}.`)}else if(n.dtype==="int32"&&(c<0||c>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${c}.`);s===1?(p[0]=c*o,p[1]=c*o,p[2]=c*o):p[d]=c*o}let h=u*4;l[h+0]=Math.round(p[0]),l[h+1]=Math.round(p[1]),l[h+2]=Math.round(p[2]),l[h+3]=Math.round(p[3])}if(t!=null){Nk||Tp(Mc,O.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),Nk=!0),t.width=a,t.height=r;let u=t.getContext("2d"),p=new ImageData(l,a,r);u.putImageData(p,0,0)}return n!==e&&n.dispose(),l}function OW(e,t,n){let r=_(e,"img","draw");if(!(e instanceof Re)){let i=r;r=oe(i,"int32"),i.dispose()}d2(r),DW(n==null?void 0:n.imageOptions);let a={image:r},s={canvas:t,options:n};O.runKernel(Mc,a,s)}var LW=L({fromPixels_:p2}),Yv={};_e(Yv,{prepareAndValidate:()=>h2});function h2(e,t){let n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(rt(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let a=t.shape,s=a[a.length-1],i=1;for(let h=0;h<a.length-1;++h)i*=a[h];let o=e.shape,l=a.slice();l.pop();let u=1;for(let h=s;h<n;++h)u*=o[h],l.push(o[h]);let p=[...Il(e.shape).map(h=>h/u),1].slice(0,s);return[l,i,u,p]}var Bt={};_e(Bt,{assertParamsValid:()=>PW,computeFlatOffset:()=>GW,computeOutShape:()=>WW,getNormalizedAxes:()=>VW,isSliceContinous:()=>UW,maskToAxes:()=>BW,parseSliceParams:()=>w2,sliceInfo:()=>HW,startForAxis:()=>x2,startIndicesWithElidedDims:()=>g2,stopForAxis:()=>v2,stopIndicesWithElidedDims:()=>y2,stridesForAxis:()=>b2,stridesWithElidedDims:()=>c2});var Ab=-2,zW=-1;function PW(e,t,n){let r=e.shape.length;$(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),$(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let a=0;a<r;++a)$(t[a]+n[a]<=e.shape[a],()=>`Error in slice${r}D: begin[${a}] + size[${a}] (${t[a]+n[a]}) would overflow input.shape[${a}] (${e.shape[a]})`)}function BW(e){let t=[],n=0;for(;e>0;)e&1&&t.push(n),e/=2,n++;return t}function WW(e,t,n){let r=[];for(let a=0;a<e.length;a++)r[a]=Math.ceil((t[a]-e[a])/n[a]);return r}function c2(e,t,n,r){let a=[...e];for(let s=a.length;s<r.length;s++)a.push(1);for(let s=0;s<n;s++)s===0?a[t]=1:(a.splice(t,0,1),a.pop());return a}function m2(e,t,n){return n<=e?n:n-(t-1)}function f2(e,t){let n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function VW(e,t,n,r,a,s,i,o,l){let u=e.length,p=new Array(u),h=new Array(u),d=new Array(u);if(t.length&&n>0){let c=t[0],m=n+1;p=g2(i,c,m,r,e),h=y2(o,c,m,a,e),d=c2(s,c,m,e)}else for(let c=0;c<u;c++)p[c]=x2(i,r,s,e,c,l),h[c]=v2(o,a,s,e,c,l),d[c]=b2(s,c,l);return{begin:p,end:h,strides:d}}function g2(e,t,n,r,a){let s=[...a],i=f2(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=0;else{let l=m2(t,n,o),u=r[l];e&1<<l&&(u=0),s[o]=u}return s}function y2(e,t,n,r,a){let s=[...a],i=f2(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=Number.MAX_SAFE_INTEGER;else{let l=m2(t,n,o),u=r[l];e&1<<l&&(u=Number.MAX_SAFE_INTEGER),s[o]=u}for(let o=0;o<s.length;o++){let l=a[o];s[o]<0&&(s[o]+=l),s[o]=Sp(0,s[o],a[o])}return s}function b2(e,t,n){let r=e[t];return(n&1<<t||r==null)&&(r=1),r}function x2(e,t,n,r,a,s){let i=t[a],o=n[a]||1;(e&1<<a||s&1<<a||i==null)&&(o>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let l=r[a];return i<0&&(i+=l),i=Sp(0,i,l-1),i}function v2(e,t,n,r,a,s){let i=t[a],o=n[a]||1;(e&1<<a||s&1<<a||i==null)&&(o>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let l=r[a];return i<0&&(i+=l),o>0?i=Sp(0,i,l):i=Sp(-1,i,l-1),i}function UW(e,t,n){let r=n.length;for(let a=0;a<n.length;a++)if(n[a]>1){r=a;break}for(let a=r+1;a<n.length;a++)if(t[a]>0||n[a]!==e[a])return!1;return!0}function GW(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function w2(e,t,n){let r,a=e.shape.length;typeof t=="number"?r=[t,...new Array(a-1).fill(0)]:t.length<a?r=t.concat(new Array(a-t.length).fill(0)):r=t.slice(),r.forEach(i=>{$(i!==-1,()=>"slice() does not support negative begin indexing.")});let s;return n==null?s=new Array(a).fill(-1):typeof n=="number"?s=[n,...new Array(a-1).fill(-1)]:n.length<a?s=n.concat(new Array(a-n.length).fill(-1)):s=n,s=s.map((i,o)=>i>=0?i:($(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${o}.`),e.shape[o]-r[o])),[r,s]}function HW(e,t,n,r,a,s,i,o,l){let u;if(r==null?(u=new Array(t.length),u.fill(1)):u=r,i!=null&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let p=!1,h={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let b=0;b<h.dims;b++)p&&1<<b&o&&h.numAddAxisAfterEllipsis++,1<<b&i&&(p=!0);p||(h.ellipsisMask|=1<<h.dims,h.dims++);let d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};jW(h,d);let c=!0,m=!0,f=!0,g=[],y=[];for(let b=0;b<e.length;++b){if(d.strides[b]===0)throw Error(`strides[${b}] must be non-zero`);let x=!!(d.shrinkAxisMask&1<<b),v=e[b];if(v===-1){g.push(x?1:-1);continue}let I=[d.beginMask&1<<b,d.endMask&1<<b],N=[d.strides[b]>0?0:-1,d.strides[b]>0?v:v-1];if(x&&d.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");f=f&&d.strides[b]===1;let C=!!(d.beginMask&1<<b&&d.endMask&1<<b);if(d.beginValid&&d.endValid){if(x){let F=d.begin[b]<0?v+d.begin[b]:d.begin[b];if(d.begin[b]=F,d.end[b]=d.begin[b]+1,F<0||F>=v)throw Error(`slice index ${d.begin[b]} of dimension ${b} out of bounds.`)}else d.begin[b]=Tk(d.begin[b],0,d.strides[b],v,I,N),d.end[b]=Tk(d.end[b],1,d.strides[b],v,I,N);let R=d.strides[b]===1&&d.begin[b]===0&&d.end[b]===v;c=c&&R,m=m&&(b===0&&d.strides[b]===1||R)}else c=c&&d.strides[b]===1&&C,m=m&&(b===0&&d.strides[b]===1||C);let E,A=!1;if(d.beginValid&&d.endValid?(E=d.end[b]-d.begin[b],A=!0):x?(E=1,A=!0):C&&v>=0&&(d.strides[b]<0?E=-v:E=v,A=!0),A){let R;E===0||E<0!=d.strides[b]<0?R=0:R=Math.trunc(E/d.strides[b])+(E%d.strides[b]!==0?1:0),g.push(R)}else g.push(-1)}for(let b=0;b<d.finalShapeGatherIndices.length;++b){let x=d.finalShapeGatherIndices[b];x>=0?y.push(g[x]):x===Ab&&y.push(1)}return{finalShapeSparse:y.filter((b,x)=>d.finalShapeGatherIndices[x]!==Ab),finalShape:y,isIdentity:c,sliceDim0:m,isSimpleSlice:f,begin:d.begin,end:d.end,strides:d.strides}}function jW(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=e.begin!=null,t.endValid=e.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){let a=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<a;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(Ab),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);e.begin!=null&&(t.begin[n]=e.begin[r]),e.end!=null&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(zW),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}function Tk(e,t,n,r,a,s){if(a[t])return n>0?s[t]:s[t+1&1];{let i=e<0?r+e:e;return i<s[0]?s[0]:i>s[1]?s[1]:i}}var qW="4.22.0",k2=class{static sgd(e){return new Nm(e)}static momentum(e,t,n=!1){return new Kv(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,a=!1){return new Xv(e,t,n,r,a)}static adam(e=.001,t=.9,n=.999,r=null){return new jv(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new Gv(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,a=0){return new qv(e,t,n,r,a)}static adagrad(e,t=.1){return new Hv(e,t)}},_s=k2,KW=typeof requestAnimationFrame!="undefined"?requestAnimationFrame:typeof setImmediate!="undefined"?setImmediate:e=>e();function Qv(){return new Promise(e=>KW(()=>e()))}var T={};_e(T,{ERF_A1:()=>u4,ERF_A2:()=>p4,ERF_A3:()=>d4,ERF_A4:()=>h4,ERF_A5:()=>c4,ERF_P:()=>l4,PARALLELIZE_THRESHOLD:()=>ew,RowPartitionType:()=>zr,SELU_SCALE:()=>S2,SELU_SCALEALPHA:()=>I2,applyActivation:()=>Im,assertAndGetBroadcastShape:()=>lt,assertAxesAreInnerMostDims:()=>H3,assertParamsConsistent:()=>XW,assignToTypedArray:()=>x4,axesAreInnerMostDims:()=>dv,calculateShapes:()=>AN,checkEinsumDimSizes:()=>N4,checkPadOnDimRoundingMode:()=>wn,combineLocations:()=>YS,combineRaggedTensorToTensorShapes:()=>JW,complexWithEvenIndex:()=>g4,complexWithOddIndex:()=>y4,computeConv2DInfo:()=>xd,computeConv3DInfo:()=>US,computeDefaultPad:()=>qx,computeDilation2DInfo:()=>UO,computeOptimalWindowSize:()=>t4,computeOutAndReduceShapes:()=>QS,computeOutShape:()=>ZW,computePool2DInfo:()=>VS,computePool3DInfo:()=>GO,convertConv2DDataFormat:()=>GS,decodeEinsumEquation:()=>I4,eitherStridesOrDilationsAreOne:()=>Jr,expandShapeToKeepDim:()=>Xs,exponent:()=>w4,exponents:()=>v4,fromStringArrayToUint8:()=>j4,fromUint8ToStringArray:()=>H4,getAxesPermutation:()=>eN,getBroadcastDims:()=>ZS,getComplexWithIndex:()=>b4,getEinsumComputePath:()=>T4,getEinsumPermutation:()=>S4,getFusedBiasGradient:()=>km,getFusedDyActivation:()=>wm,getImageCenter:()=>n4,getInnerMostAxes:()=>j3,getPermuted:()=>a4,getRaggedRank:()=>QW,getReductionAxes:()=>Mt,getReshaped:()=>r4,getReshapedPermuted:()=>s4,getRowPartitionTypesHelper:()=>YW,getSliceBeginCoords:()=>i4,getSliceSize:()=>o4,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>$4,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>A4,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>F4,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>M4,getSparseReshapeInputOutputMismatchErrorMessage:()=>L4,getSparseReshapeInputOutputMultipleErrorMessage:()=>O4,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>R4,getSparseReshapeNegativeOutputDimErrorMessage:()=>D4,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>W4,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>z4,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>P4,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>B4,getUndoAxesPermutation:()=>hv,isIdentityPermutation:()=>C4,log:()=>QD,mergeRealAndImagArrays:()=>m4,prepareAndValidate:()=>h2,prepareSplitSize:()=>E4,segment_util:()=>N2,shouldFuse:()=>Sm,slice_util:()=>Bt,splitRealAndImagArrays:()=>f4,stridesOrDilationsArePositive:()=>Ks,tupleValuesAreOne:()=>Xa,upcastType:()=>sr,validateDefaultValueShape:()=>e4,validateInput:()=>ym,validateUpdateShape:()=>Dv,warn:()=>Ma});function XW(e,t){let n=e[0].length;e.forEach((a,s)=>{$(a.length===n,()=>`Error in concat${n}D: rank of tensors[${s}] must be the same as the rank of the rest (${n})`)}),$(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);let r=e[0];e.forEach((a,s)=>{for(let i=0;i<n;i++)$(i===t||a[i]===r[i],()=>`Error in concat${n}D: Shape of tensors[${s}] (${a}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`)})}function ZW(e,t){let n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var zr;(function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"})(zr||(zr={}));function JW(e,t,n){let r=new Array;if(n==null&&t==null)return r;if(t==null)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(n==null)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let a=1;a<n.length;++a){let s=n[a],i=r[r.length-n.length+a],o=r[i];if(s>=0)if(o>=0){if(o!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${a+e}] = ${s} but shape[${a+e}] = ${o}`)}else r[i]=s}return r}function YW(e){let t={FIRST_DIM_SIZE:zr.FIRST_DIM_SIZE,VALUE_ROWIDS:zr.VALUE_ROWIDS,ROW_LENGTHS:zr.ROW_LENGTHS,ROW_SPLITS:zr.ROW_SPLITS,ROW_LIMITS:zr.ROW_LIMITS,ROW_STARTS:zr.ROW_STARTS},n=[];for(let r of e)if(r in t)n.push(t[r]);else break;return n}function QW(e){return e.length===0?0:e[0]===zr.FIRST_DIM_SIZE?e.length-1:e.length}function e4(e,t){if(e==null||t==null)return;let n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let a=0;a<Math.min(n,r-1);++a){let s=e[a],i=t[a+1];if(s>=0&&i>=0&&s!==1&&s!==i)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${a-e.length}] = ${s} but ragged tensor input.flatValues.shape[${a-e.length}] = ${i}`)}}var ew=30;function t4(e){return e<=ew?e:Qh(e,Math.floor(Math.sqrt(e)))}function n4(e,t,n){let r=n*(typeof e=="number"?e:e[0]),a=t*(typeof e=="number"?e:e[1]);return[r,a]}function r4(e,t,n,r=!0){let a=[];if(r)a=a.concat(t.slice(0)),a.push(e[0]/n),a=a.concat(e.slice(1));else{a=a.concat(e[0]);let s=t.length;for(let i=0;i<s;++i)a=a.concat([e[i+1]/t[i],t[i]]);a=a.concat(e.slice(s+1))}return a}function a4(e,t,n=!0){let r=[];if(n){r.push(t);for(let a=t+1;a<e;++a)a<=2*t?(r.push(a),r.push(a-(t+1))):r.push(a)}else{let a=[],s=[];for(let i=1;i<e;++i)i>=t*2+1||i%2===1?s.push(i):a.push(i);r.push(...a),r.push(0),r.push(...s)}return r}function s4(e,t,n,r=!0){let a=[];r?a.push(e[0]/n):a.push(e[0]*n);for(let s=1;s<e.length;++s)s<=t.length?r?a.push(t[s-1]*e[s]):a.push(e[s]/t[s-1]):a.push(e[s]);return a}function i4(e,t){let n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function o4(e,t,n){let r=e.slice(0,1);for(let a=0;a<n;++a)r.push(e[a+1]-t[a][0]-t[a][1]);return r}var I2=1.7580993408473768,S2=1.0507009873554805,l4=.3275911,u4=.254829592,p4=-.284496736,d4=1.421413741,h4=-1.453152027,c4=1.061405429;function m4(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(e.length*2);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function f4(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function g4(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=0;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function y4(e){let t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=2;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function b4(e,t){let n=e[t*2],r=e[t*2+1];return{real:n,imag:r}}function x4(e,t,n,r){e[r*2]=t,e[r*2+1]=n}function v4(e,t){let n=new Float32Array(e/2),r=new Float32Array(e/2);for(let a=0;a<Math.ceil(e/2);a++){let s=(t?2:-2)*Math.PI*(a/e);n[a]=Math.cos(s),r[a]=Math.sin(s)}return{real:n,imag:r}}function w4(e,t,n){let r=(n?2:-2)*Math.PI*(e/t),a=Math.cos(r),s=Math.sin(r);return{real:a,imag:s}}var eb="->",k4=/->/g,Ck=",",_k="...";function I4(e,t){e=e.replace(/\s/g,"");let n=(e.length-e.replace(k4,"").length)/eb.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${eb}").`);let[r,a]=e.split(eb);$(r.indexOf(_k)===-1,()=>`The ellipsis notation ("${_k}") is not supported yet.`);let s=r.split(Ck),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let o=[];for(let d=0;d<a.length;++d){let c=a[d];if(!s.some(m=>m.indexOf(c)!==-1))throw new Error(`Output subscripts contain the label ${c} not present in the input subscripts.`);o.indexOf(c)===-1&&o.push(c)}for(let d=0;d<r.length;++d){let c=r[d];o.indexOf(c)===-1&&c!==Ck&&o.push(c)}let l=new Array(s.length);for(let d=0;d<i;++d){if(new Set(s[d].split("")).size!==s[d].length)throw new Error(`Found duplicate axes in input component ${s[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let c=0;c<s[d].length;++c)l[d].push(o.indexOf(s[d][c]))}let u=o.length,p=a.length,h=[];for(let d=p;d<u;++d)h.push(d);return{allDims:o,summedDims:h,idDims:l}}function S4(e,t){let n=new Array(e);n.fill(-1);for(let a=0;a<t.length;++a)n[t[a]]=a;let r=[];for(let a=0;a<e;++a)n[a]===-1&&r.push(a);return n=n.filter(a=>a!==-1),{permutationIndices:n,expandDims:r}}function N4(e,t,n){let r=new Array(e);for(let a=0;a<n.length;++a){let s=n[a].shape;for(let i=0;i<t[a].length;++i)r[t[a][i]]===void 0?r[t[a][i]]=s[i]:$(r[t[a][i]]===s[i],()=>`Expected dimension ${r[t[a][i]]} at axis ${i} of input shaped ${JSON.stringify(s)}, but got dimension ${s[i]}`)}}function T4(e,t){let n=e,r=[],a=0;e.length===0&&n.push(-1),a=e.length+1;for(let i=0;i<a;++i)r.push([]);let s=[];for(let i=0;i<n.length;++i){let o=n[i],l=_4(t,o);for(let u of l)s.indexOf(u)===-1&&(r[i].push(u),s.push(u))}return{path:n,steps:r}}function C4(e){return e.every((t,n)=>t===n)}function _4(e,t){let n=[];for(let r=0;r<e.length;++r)(e[r].length===0||e[r].indexOf(t)!==-1||t===-1)&&n.push(r);return n}function E4(e,t,n=0){let r=[];if(typeof t=="number")$(e.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(e.shape[n]/t);else{let a=t.reduce((i,o)=>(o===-1&&(i+=1),i),0);$(a<=1,()=>"There should be only one negative value in split array.");let s=t.indexOf(-1);if(s!==-1){let i=t.reduce((o,l)=>l>0?o+l:o);t[s]=e.shape[n]-i}$(e.shape[n]===t.reduce((i,o)=>i+o),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function $4(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function A4(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function F4(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function R4(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function D4(e,t){return`size ${e} must be non-negative, not ${t}`}function M4(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function O4(e,t){let n=rt(e),r=rt(t);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${e} outputShape= ${t}`}function L4(e,t){let n=rt(e),r=rt(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${e} outputShape=${t}`}function z4(){return"segment ids must be >= 0"}function P4(){return"segment ids are not increasing"}function B4(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function W4(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}var N2={};_e(N2,{collectGatherOpShapeInfo:()=>G4,computeOutShape:()=>U4,segOpComputeOptimalWindowSize:()=>V4});function V4(e,t){let n=!1,r;for(e<=ew?(r=e,n=!0):r=Qh(e,Math.floor(Math.sqrt(e)));!n;)r>t||r===e?n=!0:r=Qh(e,r+1);return r}function U4(e,t,n){let r=[],a=e.length;for(let s=0;s<a;s++)s!==t?r.push(e[s]):r.push(n);return r}function G4(e,t,n,r){let a=t.shape.length,s=e.shape.length;if(r!==0&&(r<-a||r>a))throw new Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${r}`);if(r<0&&(r+=a),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${s}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let h=0;h<r;++h)if(e.shape[h]!==t.shape[h])throw new Error(`x.shape[${h}]: ${e.shape[h]} should be equal to indices.shape[${h}]: ${t.shape[h]}.`);let i=e.shape[n],o=[],l=1,u=1,p=1;for(let h=0;h<r;++h)o.push(e.shape[h]),l*=e.shape[h];for(let h=r;h<n;h++)o.push(e.shape[h]),u*=e.shape[h];for(let h=r;h<a;h++)o.push(t.shape[h]);for(let h=n+1;h<s;h++)o.push(e.shape[h]),p*=e.shape[h];return{batchSize:l,sliceSize:p,outerSize:u,dimSize:i,outputShape:o}}function H4(e){try{return e.map(t=>nc(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function j4(e){return e.map(t=>gd(t))}var Qr={};_e(Qr,{nonMaxSuppressionV3Impl:()=>HN,nonMaxSuppressionV4Impl:()=>jN,nonMaxSuppressionV5Impl:()=>qN,whereImpl:()=>DN});uW();var T2={kernelName:Sl,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,Eo(oe(n,"float32"),-1))}}},q4={kernelName:oi,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=it(oe(n,"float32")),a=Yt(he(ve(1),r));return ft(ce(e,a))}}}},K4={kernelName:li,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=Yt(he(it(oe(n,"float32")),1));return ce(e,r)}}}},X4={kernelName:is,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=lt(n.shape,r.shape);return{a:()=>{let s=e,i=Mt(n.shape,a);return i.length>0&&(s=fe(s,i)),P(s,n.shape)},b:()=>{let s=e,i=Mt(r.shape,a);return i.length>0&&(s=fe(s,i)),P(s,r.shape)}}}},Z4={kernelName:ui,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach((r,a)=>{n[a]=()=>e.clone()}),n}},J4={kernelName:Cl,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ge(n)}}},Y4={kernelName:_l,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ge(n)}}},Q4={kernelName:pi,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ce(e,Yt(he(ve(1),it(oe(n,"float32")))))}}},eV={kernelName:di,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=Yt(Z(ve(1),it(oe(n,"float32"))));return ce(e,r)}}}},tV={kernelName:mi,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=lt(n.shape,r.shape);return{a:()=>{let s=Z(it(n),it(r)),i=z(e,ce(r,s)),o=Mt(n.shape,a);return o.length>0&&(i=fe(i,o)),P(i,n.shape)},b:()=>{let s=Z(it(n),it(r)),i=ft(z(e,ce(n,s))),o=Mt(r.shape,a);return o.length>0&&(i=fe(i,o)),P(i,r.shape)}}}},nV={kernelName:hi,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ce(e,Z(it(oe(n,"float32")),1))}}},rV={kernelName:ci,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ce(e,he(ve(1),it(oe(n,"float32"))))}}};function aV(e,t,n,r,a,s){let i=_(e,"dy","avgPool3dGrad"),o=_(t,"input","avgPool3dGrad"),l=i,u=o,p=!1;o.rank===4&&(p=!0,l=P(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=P(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),$(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),$(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),wn("avgPool3dGrad",a,s);let h={dy:l,input:u},d={filterSize:n,strides:r,pad:a,dimRoundingMode:s},c=O.runKernel(Kp,h,d);return p?P(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}var sV=L({avgPool3dGrad_:aV}),iV={kernelName:El,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:s,pad:i,dimRoundingMode:o}=n;return{x:()=>sV(e,r,a,s,i,o)}}};function oV(e,t,n,r,a){let s=_(e,"dy","avgPoolGrad"),i=_(t,"input","avgPoolGrad");$(i.rank===s.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`);let o=i,l=s,u=!1;i.rank===3&&(u=!0,o=P(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=P(s,[1,s.shape[0],s.shape[1],s.shape[2]])),$(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),$(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);let p={dy:l,input:o},h={filterSize:n,strides:r,pad:a},d=O.runKernel(qp,p,h);return u?P(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var lV=L({avgPoolGrad_:oV}),uV={kernelName:fi,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:s,pad:i}=n;return{x:()=>lV(e,r,a,s,i)}}},pV={kernelName:gi,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{let[r,a]=t,{transposeA:s,transposeB:i}=n;return!s&&!i?{a:()=>De(e,a,!1,!0),b:()=>De(r,e,!0,!1)}:!s&&i?{a:()=>De(e,a,!1,!1),b:()=>De(e,r,!0,!1)}:s&&!i?{a:()=>De(a,e,!1,!0),b:()=>De(r,e,!1,!1)}:{a:()=>De(a,e,!0,!0),b:()=>De(e,r,!0,!0)}}},dV={kernelName:$l,gradFunc:(e,t,n)=>{let{blockShape:r,crops:a}=n;return{x:()=>_d(e,r,a)}}},hV={kernelName:hS,gradFunc:(e,t,n)=>{let r=n,a=r.inputShape,s=r.shape,i=Array.from(s);for(let l=a.length-1;l>=0;l--)if(a[l]===s[l])i[l]=1;else if(a[l]!==1)throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${s}].`);let o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>fe(e,o,!0)}}},cV={kernelName:yi,gradFunc:e=>({x:()=>e.clone()})},mV={kernelName:bi,gradFunc:e=>({x:()=>Ge(e)})},fV={kernelName:os,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{clipValueMin:a,clipValueMax:s}=n;return{x:()=>Jt(gr(ba(r,a),ds(r,s)),e,Ge(e))}}},gV={kernelName:Zp,inputsToSave:["x"],gradFunc:T2.gradFunc},yV={kernelName:Rl,saveAllInputs:!0,gradFunc:(e,t,n)=>{let r=t.map(o=>o.shape),{axis:a}=n,s=yr(a,t[0].shape)[0],i=r.map(o=>o[s]);return $n(e,i,s).map(o=>()=>o)}},bV={kernelName:xi,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{dilations:s,strides:i,pad:o,dataFormat:l}=n;return $(Xa(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>av(r.shape,e,a,i,o,l),filter:()=>Wv(r,e,a.shape,i,o,l)}}},xV={kernelName:vi,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{strides:s,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>bn(e,a,s,i,o,1,l),filter:()=>Wv(e,r,a.shape,s,i,o,l)}}};function vV(e,t,n,r,a){let s=e;e.rank===4&&(s=P(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;i.rank===4&&(i=P(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),$(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),$(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),$(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),$(s.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`),$(i.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`);let o={x:s,dy:i},l={strides:r,pad:a,filterShape:n};return O.runKernel(Dl,o,l)}var wV=L({conv3DBackpropFilter_:vV}),kV={kernelName:wi,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:s}=n;$(Xa(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);let[i,o]=t;return{x:()=>KS(i.shape,e,o,a,s),filter:()=>wV(i,e,o.shape,a,s)}}},IV={kernelName:ki,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(ft(pm(oe(n,"float32"))),e)}}},SV={kernelName:Ii,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(dm(oe(n,"float32")),e)}}},NV={kernelName:Si,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a,exclusive:s,reverse:i}=n;return{x:()=>{let o=eN([a],r.rank),l=Yc(e,a,s,!i);return o!=null&&(l=Me(l,o)),l}}}},TV={kernelName:Ni,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:s,dimRoundingMode:i}=n,o=r==null?[1,1]:r;$(Xa(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);let[l,u]=t;return $(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),$(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),$(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),$(Jr(a,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${a} and dilations '${o}'.`),wn("depthwiseConv2d",s,i),{x:()=>VN(l.shape,e,u,a,s,o,i),filter:()=>WN(l,e,u.shape,a,s,o,i)}}},CV={kernelName:Ti,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,s={x:r,filter:a,dy:e},i={x:r,filter:a,dy:e};return{x:()=>O.runKernel(sl,s,n),filter:()=>O.runKernel(il,i,n)}}},_V={kernelName:_i,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,r={dy:e,y:n};return{x:()=>O.runKernel(Pl,r)}}},EV={kernelName:Ei,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=z(pn(ft(it(n))),2/Math.sqrt(Math.PI));return{x:()=>z(e,r)}}},$V={kernelName:$i,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,n)}}},AV={kernelName:Wl,inputsToSave:["input"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>P(e,n.shape)}}},FV={kernelName:Ai,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,pn(n))}}},RV={kernelName:Fi,gradFunc:e=>({x:()=>Ge(e)})},DV={kernelName:Ri,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=lt(n.shape,r.shape);return{a:()=>{let s=ce(e,oe(r,"float32")),i=Mt(n.shape,a);return i.length>0?P(fe(s,i),n.shape):s},b:()=>{let s=z(e,oe(n,"float32")),i=Mt(r.shape,a);i.length>0&&(s=P(fe(s,i),r.shape));let o=it(r);return ft(ce(s,oe(o,"float32")))}}}},MV={kernelName:Di,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{let{varianceEpsilon:r}=n,[a,s,i,o]=t,l=o==null?ve(1):o,u=Mt(s.shape,a.shape),p=[];if(s.rank===1){for(let f=0;f<a.shape.length-1;++f)p.push(a.shape[f]);p.push(1)}let h=he(a,s),d=z(e,l),c=lm(Z(i,ve(r))),m=z(z(z(c,c),c),ve(-.5));return{x:()=>s.rank===1?P(z(z(e,Vn(P(c,[1,1,1,s.shape[0]]),p)),l),a.shape):P(z(z(e,c),l),a.shape),mean:()=>{let f=z(z(c,ve(-1)),d);return s.rank===1&&(f=fe(f,u)),P(f,s.shape)},variance:()=>{let f=z(z(m,h),d);return s.rank===1&&(f=fe(f,u)),P(f,s.shape)},scale:()=>{let f=z(h,c),g=z(e,f);return s.rank===1&&(g=fe(g,u)),P(g,s.shape)},offset:()=>{let f=e;return s.rank===1&&(f=fe(f,u)),P(f,s.shape)}}}},OV={kernelName:Ul,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{let[r,a]=t,{axis:s,batchDims:i}=n,o=yr(s,r.shape)[0],l=(u,p,h)=>()=>{let d=u.shape,c=p.size,m=d.slice(0,o),f=m.length,g=d.slice(s,d.length).slice(1),y=g.length,b=Ek(0,f),x=Ek(f+1,f+1+y),v=$k([m,[c],g]),I=P(h,v),N=P(p,[c]),C=$k([[f],b,x]),E=Me(I,C),A=xm(E,N,u.shape[o]),R=hv(C);return A=Me(A,R),A};if(i===1){let u=r.shape[0],p=r.split(u,0);return{x:()=>Dt(p.map((h,d)=>l(h,a.slice(d,1),e.slice(d,1))())).reshape(r.shape),indices:()=>a}}else return{x:l(r,a,e),indices:()=>a}}};function Ek(e,t){let n=[];for(let r=e;r<t;++r)n.push(r);return n}function $k(e){let t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}var LV={kernelName:Mi,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>Ge(n),b:()=>Ge(r)}}},zV={kernelName:Oi,gradFunc:e=>({x:()=>oe(e,"float32")})},PV={kernelName:Li,gradFunc:e=>({x:()=>Ge(e)})},BV={kernelName:zi,gradFunc:e=>({x:()=>Ge(e)})},WV={kernelName:Pi,gradFunc:e=>({x:()=>Ge(e)})},VV={kernelName:Bi,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{alpha:a}=n,s=kn(r,0);return{x:()=>Jt(s,e,z(e,a))}}},UV={kernelName:Vi,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ce(e,Z(n,1))}}},GV={kernelName:Wi,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ce(e,oe(n,"float32"))}}},HV={kernelName:mS,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n;return{logits:()=>{let s=pn(r);return he(e,z(fe(e,a,!0),s))}}}};function jV(e,t,n,r=5,a=1,s=1,i=.5){let o={x:e,y:t,dy:n},l={depthRadius:r,bias:a,alpha:s,beta:i};return O.runKernel(Yl,o,l)}var qV=L({localResponseNormalizationBackprop_:jV}),KV={kernelName:Ui,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{depthRadius:s,bias:i,alpha:o,beta:l}=n;return{x:()=>qV(r,a,e,s,i,o,l)}}};function C2(e,t,n,r){return t.rank<n.rank&&(t=P(t,Xs(t.shape,r))),e.rank<n.rank&&(e=P(e,Xs(e.shape,r))),{x:()=>z(e,oe(Gn(n,t),e.dtype))}}var Ak={kernelName:Gi,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{reductionIndices:a}=r,s=t[0],i=t[1],o=yr(a,s.shape),l=C2(e,i,s,o);return{x:()=>l.x()}}},XV={kernelName:Hi,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>z(e,oe(ba(n,r),"float32")),b:()=>z(e,oe(ul(n,r),"float32"))}}};function ZV(e,t,n,r,a,s,i){let o=_(e,"dy","maxPool3dGrad"),l=_(t,"input","maxPool3dGrad"),u=_(n,"output","maxPool3dGrad"),p=o,h=l,d=u,c=!1;l.rank===4&&(c=!0,p=P(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=P(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=P(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),$(p.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${p.rank}.`),$(h.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),$(d.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),wn("maxPool3dGrad",s,i);let m={dy:p,input:h,output:d},f={filterSize:r,strides:a,pad:s,dimRoundingMode:i},g=O.runKernel(td,m,f);return c?P(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var JV=L({maxPool3dGrad_:ZV}),YV={kernelName:Ql,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>JV(e,r,a,s,i,o,l)}}};function QV(e,t,n,r,a,s,i){let o=_(e,"dy","maxPoolGrad"),l=_(t,"input","maxPoolGrad"),u=_(n,"output","maxPoolGrad");$(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),$(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),$(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),wn("maxPoolGrad",s,i);let p={dy:o,input:l,output:u},h={filterSize:r,strides:a,pad:s,dimRoundingMode:i};return O.runKernel(ed,p,h)}var eU=L({maxPoolGrad_:QV}),tU={kernelName:ji,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:s,strides:i,pad:o}=n;return{x:()=>eU(e,r,a,s,i,o)}}},nU={kernelName:qi,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,s=yr(a,r.shape),i=QS(r.shape,s)[1],o=rt(i);return{x:()=>{let l=r.shape.slice();s.forEach(p=>{l[p]=1});let u=P(e,l);return ce(z(u,En(r.shape,"float32")),o)}}}},rU={kernelName:Ki,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{axis:a}=r,[s,i]=t,o=yr(a,s.shape),l=C2(e,i,s,o);return{x:()=>l.x()}}},aU={kernelName:Xi,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>z(e,oe(ds(n,r),"float32")),b:()=>z(e,oe(kn(n,r),"float32"))}}},sU={kernelName:Zi,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,s=a.map(i=>i[0]);return{x:()=>Ue(e,s,r.shape)}}},iU={kernelName:Ji,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=lt(n.shape,r.shape);return{a:()=>{let s=Mt(n.shape,a);return s.length>0?P(fe(e,s),n.shape):e},b:()=>{let s=z(e,ft(Eu(ce(n,r)))),i=Mt(r.shape,a);return i.length>0?P(fe(s,i),r.shape):s}}}},oU={kernelName:Yi,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=lt(n.shape,r.shape);return{a:()=>{let s=z(e,oe(r,"float32")),i=Mt(n.shape,a);return i.length>0?P(fe(s,i),n.shape):s},b:()=>{let s=z(e,oe(n,"float32")),i=Mt(r.shape,a);return i.length>0?P(fe(s,i),r.shape):s}}}},lU={kernelName:tu,gradFunc:e=>({x:()=>ft(e)})},uU={kernelName:Qi,inputsToSave:["indices"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>It(n.shape,"float32")}}},pU={kernelName:iu,gradFunc:e=>({x:()=>Ge(e)})},dU={kernelName:ou,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:r}=n;return Tt(e,r).map(a=>()=>a)}},Fk={kernelName:eo,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,s=a.map(i=>i[0]);return{x:()=>Ue(e,s,r.shape)}}},hU={kernelName:to,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,r,a]=t,s=n,i=r,o=lt(s.shape,i.shape);return{a:()=>{let l=oe(i,"float32"),u=z(e,z(l,qr(s,he(l,ve(1))))),p=Mt(s.shape,o);return p.length>0&&(u=fe(u,p)),P(u,s.shape)},b:()=>{let l=kn(s,0),u=Jt(l,Hn(s),Ge(s)),p=z(e,z(a,u)),h=Mt(i.shape,o);return h.length>0&&(p=fe(p,h)),P(p,i.shape)}}}},cU={kernelName:no,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[n,r]=t,a=kn(n,0);return{x:()=>Jt(a,e,z(e,r)),alpha:()=>{let s=Jt(a,Ge(e),z(e,n)),i=Mt(r.shape,e.shape);return i.length>0&&(s=fe(s,i)),P(s,r.shape)}}}};function mU(e,t,n){let r=e.shape.slice();r[n]=1;let a=P(t,r),s=Fp(e,n,!0,!1),i=Fp(e,n,!0,!0),o=z(s,i);return z(a,o)}function fU(e,t,n){let r=e.shape.length,a=r-n.length,s=T.getAxesPermutation(n,r),i=e;s!=null&&(i=Me(e,s));let o=i.shape.slice(),l=o.splice(r-n.length,n.length).reduce((h,d)=>h*d,1);o.push(l);let u=i.reshape(o),p=mU(u,t,a);if(p=p.reshape(i.shape),s!=null){let h=T.getUndoAxesPermutation(s);p=Me(p,h)}return p}var gU={kernelName:ro,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,s=[];return a==null?s=r.shape.map((i,o)=>o):typeof a=="number"?s=[a]:s=a,{x:()=>fU(r,e,s)}}},yU={kernelName:Ci,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=lt(n.shape,r.shape);return{a:()=>{let s=ce(e,oe(r,"float32")),i=Mt(n.shape,a);return i.length>0?P(fe(s,i),n.shape):s},b:()=>{let s=z(e,oe(n,"float32")),i=Mt(r.shape,a);i.length>0&&(s=P(fe(s,i),r.shape));let o=it(r);return ft(ce(s,oe(o,"float32")))}}}},bU={kernelName:ao,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ce(e,ft(it(n)))}}},xU={kernelName:lo,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=z(ds(n,6),Eo(n));return{x:()=>z(e,oe(r,"float32"))}}},vU={kernelName:so,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,oe(Eo(n),"float32"))}}},wU={kernelName:lu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>P(e,n.shape)}}},kU={kernelName:oo,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>O.runKernel(pu,a,n)}}},IU={kernelName:io,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>O.runKernel(uu,a,n)}}},SU={kernelName:uo,gradFunc:(e,t,n)=>{let{dims:r}=n,a=yr(r,e.shape);return{x:()=>or(e,a)}}},NU={kernelName:po,gradFunc:e=>({x:()=>Ge(e)})},TU={kernelName:ho,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ft(ce(e,z(qr(n,1.5),2)))}}},CU={kernelName:mu,inputsToSave:["condition"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>oe(Ge(n),"float32"),t:()=>z(e,oe(n,e.dtype)),e:()=>z(e,oe(Td(n),e.dtype))}}},_U={kernelName:co,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=kn(n,ve(0)),a=ve(I2),s=ve(S2),i=z(e,s),o=z(z(e,a),pn(oe(n,"float32")));return Jt(r,i,o)}}}},EU={kernelName:yo,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,z(n,he(ve(1),n)))}}},$U={kernelName:go,gradFunc:e=>({x:()=>Ge(e)})},AU={kernelName:mo,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(wd(oe(n,"float32")),e)}}},FU={kernelName:fo,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(Jc(oe(n,"float32")),e)}}},RU={kernelName:fu,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{begin:a,size:s}=n,i=r.shape,[o,l]=w2(r,a,s),u=[];for(let p=0;p<e.rank;p++)u.push([o[p],i[p]-o[p]-l[p]]);return{x:()=>Ar(e,u)}}},DU={kernelName:wo,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{dim:a}=n,s=!0,i=z(e,r);return{logits:()=>he(i,z(fe(i,[a],s),r))}}},MU={kernelName:bo,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,fr(n))}}},Rk={kernelName:gu,gradFunc:(e,t,n)=>{let{blockShape:r,paddings:a}=n;return{x:()=>vd(e,r,a)}}},Dk={kernelName:yu,gradFunc:(e,t,n)=>{let{axis:r}=n;return{x:()=>ot(e,r)}}},OU={kernelName:xo,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ce(e,z(Yt(oe(n,"float32")),2))}}},LU={kernelName:od,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,z(oe(n,"float32"),2))}}},zU={kernelName:ko,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=ve(2);return{a:()=>z(e,z(a,he(n,r))),b:()=>z(e,z(a,he(r,n)))}}},PU={kernelName:us,gradFunc:e=>({x:()=>Ge(e)})},BU={kernelName:Io,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=lt(n.shape,r.shape);return{a:()=>{let s=e,i=Mt(n.shape,a);return i.length>0&&(s=fe(s,i)),P(s,n.shape)},b:()=>{let s=e,i=Mt(r.shape,a);return i.length>0&&(s=fe(s,i)),P(ft(s),r.shape)}}}},WU={kernelName:vo,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,a=r.shape.slice(),{axis:s}=n;yr(s,r.shape).forEach(l=>{a[l]=1});let i=P(e,a),o=z(i,En(r.shape,"float32"));return{x:()=>o}}},VU={kernelName:So,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ce(e,it(wd(n)))}}},UU={kernelName:No,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(he(ve(1),it(n)),e)}}},GU={kernelName:ls,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{reps:a}=n;return{x:()=>{let s=Ge(r);if(r.rank===1)for(let i=0;i<a[0];++i)s=Z(s,Ue(e,[i*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let i=0;i<a[0];++i)for(let o=0;o<a[1];++o)s=Z(s,Ue(e,[i*r.shape[0],o*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let i=0;i<a[0];++i)for(let o=0;o<a[1];++o)for(let l=0;l<a[2];++l)s=Z(s,Ue(e,[i*r.shape[0],o*r.shape[1],l*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let i=0;i<a[0];++i)for(let o=0;o<a[1];++o)for(let l=0;l<a[2];++l)for(let u=0;u<a[3];++u)s=Z(s,Ue(e,[i*r.shape[0],o*r.shape[1],l*r.shape[2],u*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return s}}}},HU={kernelName:ua,gradFunc:(e,t,n)=>{let r=n,{perm:a}=r,s=hv(a);return{x:()=>Me(e,s)}}},jU={kernelName:Iu,gradFunc:(e,t,n)=>{let r=n,{axis:a}=r;return{value:()=>Dt(e,a)}}},qU={kernelName:cd,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>KU(e,n)}}};function KU(e,t){let n=Yr(t,Ge(t)),r=$u(e,n),a=ba(t,ve(0,"int32")),s=r.rank-a.rank;for(let o=0;o<s;++o)a=Xt(a,o+1);a=gr(a,En(r.shape,"bool"));let i=Ge(r);return Jt(a,r,i)}var XU={kernelName:Su,gradFunc:e=>({x:()=>Ge(e)})},ZU=[T2,q4,K4,X4,Z4,J4,Y4,Q4,eV,tV,nV,rV,iV,uV,pV,dV,hV,cV,mV,fV,gV,yV,xV,bV,kV,IV,SV,NV,TV,CV,yU,_V,EV,$V,AV,FV,DV,RV,MV,OV,LV,zV,PV,BV,WV,VV,UV,GV,HV,KV,Ak,Ak,XV,YV,tU,nU,rU,aU,sU,iU,oU,lU,uU,pU,dU,Fk,Fk,hU,cU,gU,bU,xU,vU,wU,kU,IU,SU,NU,TU,CU,_U,EU,$U,AU,FU,RU,DU,MU,Rk,Rk,Dk,Dk,OU,zU,LU,PU,BU,WU,VU,UU,GU,HU,jU,qU,XU];for(let e of ZU)fS(e);Q().prototype.abs=function(){return this.throwIfDisposed(),At(this)};Q().prototype.acos=function(){return this.throwIfDisposed(),Px(this)};Q().prototype.acosh=function(){return this.throwIfDisposed(),Bx(this)};Q().prototype.add=function(e){return this.throwIfDisposed(),Z(this,e)};Q().prototype.all=function(e,t){return this.throwIfDisposed(),Kc(this,e,t)};Q().prototype.any=function(e,t){return this.throwIfDisposed(),Ep(this,e,t)};Q().prototype.argMax=function(e){return this.throwIfDisposed(),qs(this,e)};Q().prototype.argMin=function(e){return this.throwIfDisposed(),Wx(this,e)};Q().prototype.asScalar=function(){return this.throwIfDisposed(),$(this.size===1,()=>"The array must have only 1 element."),P(this,[])};Q().prototype.asType=function(e){return this.throwIfDisposed(),oe(this,e)};Q().prototype.as1D=function(){return this.throwIfDisposed(),P(this,[this.size])};Q().prototype.as2D=function(e,t){return this.throwIfDisposed(),P(this,[e,t])};Q().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),P(this,[e,t,n])};Q().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),P(this,[e,t,n,r])};Q().prototype.as5D=function(e,t,n,r,a){return this.throwIfDisposed(),P(this,[e,t,n,r,a])};Q().prototype.asin=function(){return this.throwIfDisposed(),Vx(this)};Q().prototype.asinh=function(){return this.throwIfDisposed(),Ux(this)};Q().prototype.atan=function(){return this.throwIfDisposed(),Gx(this)};Q().prototype.atan2=function(e){return this.throwIfDisposed(),Hx(this,e)};Q().prototype.atanh=function(){return this.throwIfDisposed(),jx(this)};Q().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),ya(this,e,t,n,r)};Q().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),vd(this,e,t)};Q().prototype.batchNorm=function(e,t,n,r,a){return this.throwIfDisposed(),To(this,e,t,n,r,a)};Q().prototype.broadcastTo=function(e){return this.throwIfDisposed(),Ls(this,e)};Q().prototype.cast=function(e){return this.throwIfDisposed(),oe(this,e)};Q().prototype.ceil=function(){return this.throwIfDisposed(),Qx(this)};Q().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),un(this,e,t)};Q().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Re&&(e=[e]),ot([this,...e],t)};Q().prototype.conv1d=function(e,t,n,r,a,s){return this.throwIfDisposed(),Xc(this,e,t,n,r,a,s)};Q().prototype.conv2dTranspose=function(e,t,n,r,a){return this.throwIfDisposed(),Zc(this,e,t,n,r,a)};Q().prototype.conv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),bn(this,e,t,n,r,a,s)};Q().prototype.cos=function(){return this.throwIfDisposed(),wd(this)};Q().prototype.cosh=function(){return this.throwIfDisposed(),Jc(this)};Q().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),Fp(this,e,t,n)};Q().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),Yc(this,e,t,n)};Q().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),ov(this,e,t)};Q().prototype.depthwiseConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),Co(this,e,t,n,r,a,s)};Q().prototype.dilation2d=function(e,t,n,r,a){return this.throwIfDisposed(),lv(this,e,t,n,r,a)};Q().prototype.divNoNan=function(e){return this.throwIfDisposed(),uv(this,e)};Q().prototype.div=function(e){return this.throwIfDisposed(),ce(this,e)};Q().prototype.dot=function(e){return this.throwIfDisposed(),pv(this,e)};Q().prototype.elu=function(){return this.throwIfDisposed(),Cu(this)};Q().prototype.equal=function(e){return this.throwIfDisposed(),Gn(this,e)};Q().prototype.erf=function(){return this.throwIfDisposed(),Qc(this)};Q().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),cv(this,e,t)};Q().prototype.exp=function(){return this.throwIfDisposed(),pn(this)};Q().prototype.expandDims=function(e){return this.throwIfDisposed(),Xt(this,e)};Q().prototype.expm1=function(){return this.throwIfDisposed(),mv(this)};Q().prototype.fft=function(){return this.throwIfDisposed(),Ad(this)};Q().prototype.flatten=function(){return this.throwIfDisposed(),P(this,[this.size])};Q().prototype.floor=function(){return this.throwIfDisposed(),Eu(this)};Q().prototype.floorDiv=function(e){return this.throwIfDisposed(),qc(this,e)};Q().prototype.gather=function(e,t,n){return this.throwIfDisposed(),$u(this,e,t,n)};Q().prototype.greaterEqual=function(e){return this.throwIfDisposed(),ba(this,e)};Q().prototype.greater=function(e){return this.throwIfDisposed(),kn(this,e)};Q().prototype.ifft=function(){return this.throwIfDisposed(),cl(this)};Q().prototype.irfft=function(){return this.throwIfDisposed(),cm(this)};Q().prototype.isFinite=function(){return this.throwIfDisposed(),fv(this)};Q().prototype.isInf=function(){return this.throwIfDisposed(),gv(this)};Q().prototype.isNaN=function(){return this.throwIfDisposed(),yv(this)};Q().prototype.leakyRelu=function(e){return this.throwIfDisposed(),Id(this,e)};Q().prototype.lessEqual=function(e){return this.throwIfDisposed(),ds(this,e)};Q().prototype.less=function(e){return this.throwIfDisposed(),ul(this,e)};Q().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),bv(this,e,t,n,r)};Q().prototype.logSigmoid=function(){return this.throwIfDisposed(),xv(this)};Q().prototype.logSoftmax=function(e){return this.throwIfDisposed(),nm(this,e)};Q().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),Nd(this,e,t)};Q().prototype.log=function(){return this.throwIfDisposed(),Hn(this)};Q().prototype.log1p=function(){return this.throwIfDisposed(),Sd(this)};Q().prototype.logicalAnd=function(e){return this.throwIfDisposed(),gr(this,e)};Q().prototype.logicalNot=function(){return this.throwIfDisposed(),Td(this)};Q().prototype.logicalOr=function(e){return this.throwIfDisposed(),rm(this,e)};Q().prototype.logicalXor=function(e){return this.throwIfDisposed(),vv(this,e)};Q().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),De(this,e,t,n)};Q().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),jt(this,e,t,n,r)};Q().prototype.max=function(e,t){return this.throwIfDisposed(),ar(this,e,t)};Q().prototype.maximum=function(e){return this.throwIfDisposed(),Yr(this,e)};Q().prototype.mean=function(e,t){return this.throwIfDisposed(),kt(this,e,t)};Q().prototype.min=function(e,t){return this.throwIfDisposed(),ll(this,e,t)};Q().prototype.minimum=function(e){return this.throwIfDisposed(),Ja(this,e)};Q().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),kv(this,e,t)};Q().prototype.mod=function(e){return this.throwIfDisposed(),Iv(this,e)};Q().prototype.mul=function(e){return this.throwIfDisposed(),z(this,e)};Q().prototype.neg=function(){return this.throwIfDisposed(),ft(this)};Q().prototype.norm=function(e,t,n){return this.throwIfDisposed(),_u(this,e,t,n)};Q().prototype.notEqual=function(e){return this.throwIfDisposed(),Zs(this,e)};Q().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),pl(this,e,t,n)};Q().prototype.onesLike=function(){return this.throwIfDisposed(),jn(this)};Q().prototype.pad=function(e,t){return this.throwIfDisposed(),Ar(this,e,t)};Q().prototype.pool=function(e,t,n,r,a,s){return this.throwIfDisposed(),Sv(this,e,t,n,r,a,s)};Q().prototype.pow=function(e){return this.throwIfDisposed(),qr(this,e)};Q().prototype.prelu=function(e){return this.throwIfDisposed(),Ed(this,e)};Q().prototype.prod=function(e,t){return this.throwIfDisposed(),Nv(this,e,t)};Q().prototype.reciprocal=function(){return this.throwIfDisposed(),$v(this)};Q().prototype.relu=function(){return this.throwIfDisposed(),nt(this)};Q().prototype.relu6=function(){return this.throwIfDisposed(),im(this)};Q().prototype.reshapeAs=function(e){return this.throwIfDisposed(),P(this,e.shape)};Q().prototype.reshape=function(e){return this.throwIfDisposed(),P(this,e)};Q().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),KN(this,e,t,n)};Q().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),XN(this,e,t,n)};Q().prototype.reverse=function(e){return this.throwIfDisposed(),or(this,e)};Q().prototype.rfft=function(){return this.throwIfDisposed(),Fd(this)};Q().prototype.round=function(){return this.throwIfDisposed(),om(this)};Q().prototype.rsqrt=function(){return this.throwIfDisposed(),lm(this)};Q().prototype.selu=function(){return this.throwIfDisposed(),um(this)};Q().prototype.separableConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),Au(this,e,t,n,r,a,s)};Q().prototype.sigmoid=function(){return this.throwIfDisposed(),fr(this)};Q().prototype.sign=function(){return this.throwIfDisposed(),Av(this)};Q().prototype.sin=function(){return this.throwIfDisposed(),pm(this)};Q().prototype.sinh=function(){return this.throwIfDisposed(),dm(this)};Q().prototype.slice=function(e,t){return this.throwIfDisposed(),Ue(this,e,t)};Q().prototype.softmax=function(e){return this.throwIfDisposed(),cs(this,e)};Q().prototype.softplus=function(){return this.throwIfDisposed(),_o(this)};Q().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),_d(this,e,t)};Q().prototype.split=function(e,t){return this.throwIfDisposed(),$n(this,e,t)};Q().prototype.sqrt=function(){return this.throwIfDisposed(),Yt(this)};Q().prototype.square=function(){return this.throwIfDisposed(),it(this)};Q().prototype.squaredDifference=function(e){return this.throwIfDisposed(),mm(this,e)};Q().prototype.squeeze=function(e){return this.throwIfDisposed(),ms(this,e)};Q().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof Re?[this,e]:[this,...e];return Dt(n,t)};Q().prototype.step=function(e){return this.throwIfDisposed(),Eo(this,e)};Q().prototype.stridedSlice=function(e,t,n,r,a,s,i,o){return this.throwIfDisposed(),Fv(this,e,t,n,r,a,s,i,o)};Q().prototype.sub=function(e){return this.throwIfDisposed(),he(this,e)};Q().prototype.sum=function(e,t){return this.throwIfDisposed(),fe(this,e,t)};Q().prototype.tan=function(){return this.throwIfDisposed(),Rv(this)};Q().prototype.tanh=function(){return this.throwIfDisposed(),Za(this)};Q().prototype.tile=function(e){return this.throwIfDisposed(),Vn(this,e)};Q().prototype.toBool=function(){return this.throwIfDisposed(),oe(this,"bool")};Q().prototype.toFloat=function(){return this.throwIfDisposed(),oe(this,"float32")};Q().prototype.toInt=function(){return this.throwIfDisposed(),oe(this,"int32")};Q().prototype.topk=function(e,t){return this.throwIfDisposed(),Mv(this,e,t)};Q().prototype.transpose=function(e){return this.throwIfDisposed(),Me(this,e)};Q().prototype.unique=function(e){return this.throwIfDisposed(),Ov(this,e)};Q().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),xm(this,e,t)};Q().prototype.unstack=function(e){return this.throwIfDisposed(),Tt(this,e)};Q().prototype.where=function(e,t){return this.throwIfDisposed(),Jt(e,this,t)};Q().prototype.zerosLike=function(){return this.throwIfDisposed(),Ge(this)};var Ra=class _2 extends Error{constructor(t){super(t),Object.setPrototypeOf(this,_2.prototype)}},Wr=class E2 extends Error{constructor(t){super(t),Object.setPrototypeOf(this,E2.prototype)}},V=class $2 extends Error{constructor(t){super(t),Object.setPrototypeOf(this,$2.prototype)}},ze=class A2 extends Error{constructor(t){super(t),Object.setPrototypeOf(this,A2.prototype)}},JU=class F2 extends Error{constructor(t){super(t),Object.setPrototypeOf(this,F2.prototype)}},R2=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=e}};function Ys(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}else{let n=new Array(t);return n.fill(e),n}}function Pr(e,t){if(!e)throw new JU(t)}function Mk(e,t){let n=0;for(let r of e)r===t&&n++;return n}function _n(e){return e.length===1?e[0]:e}function et(e){return Array.isArray(e)?e:[e]}function sa(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function Fs(e){return e.length<=1||e.indexOf("_")===-1?e:e.replace(/[_]+(\w|$)/g,(t,n)=>n.toUpperCase())}var dr={};function tw(e){if(e==null)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function Fb(e){if(!(e==null||typeof e!="object"))if(Array.isArray(e))e.forEach(t=>Fb(t));else{let t=Object.keys(e);for(let n of t){let r=e[n];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?e[n]=r.value:Fb(r))}}}function Dd(e,t={},n={},r="object",a=!1){if(typeof e=="string"){let s=e,i;if(s in n)i=n[s];else if(s in dr)i=dr[s];else if(i=t[s],i==null)throw new V(`Unknown ${r}: ${e}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{let s=e;if(s.className==null||s.config==null)throw new V(`${r}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);let i=s.className,o,l;if(i in n?[o,l]=n[i]:i in dr?[o,l]=dr.className:i in t&&([o,l]=t[i]),o==null)throw new V(`Unknown ${r}: ${i}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){let u={};for(let c of Object.keys(dr))u[c]=dr[c];for(let c of Object.keys(n))u[c]=n[c];let p=s.config;p.customObjects=u;let h=Object.assign({},dr);for(let c of Object.keys(n))dr[c]=n[c];Fb(s.config);let d=l(o,s.config,n,a);return dr=Object.assign({},h),d}else{let u=Object.assign({},dr);for(let h of Object.keys(n))dr[h]=n[h];let p=new o(s.config);return dr=Object.assign({},u),p}}}function YU(e,t){return e<t?-1:e>t?1:0}function Th(e,t){return-1*YU(e,t)}function Wa(e){if(e==null)return e;let t=[];for(let n of e)t.indexOf(n)===-1&&t.push(n);return t}function QU(e){if(e==null)throw new V(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function $o(e,t,n){if(n!=null&&e.indexOf(n)<0)throw new V(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function nw(e,t,n=0,r=1/0){return Pr(n>=0),Pr(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every(a=>typeof a===t)}function Zt(e,t){Array.isArray(e)?(w.assert(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((n,r)=>Zt(n,`element ${r+1} of ${t}`))):w.assert(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${D2(e)}.`)}function D2(e){return e===null?"null":Array.isArray(e)?"["+e.map(t=>D2(t)).join(",")+"]":typeof e=="string"?`"${e}"`:`${e}`}function eG(e,t,n){let r=n!=null?n():w.now(),a;return(...s)=>{let i=n!=null?n():w.now();return i-r<t||(r=i,a=e(...s)),a}}function M2(e){return e==="relu"?"relu":e==="linear"?"linear":e==="elu"?"elu":null}var tG=0;function O2(){return tG++}var Ch={};function Tm(e=""){return e in Ch||(Ch[e]=0),Ch[e]+=1,e+Ch[e].toString()}var nG=["channelsFirst","channelsLast"],rG=["nearest","bilinear"],aG=["valid","same","causal"],sG=["max","avg"],iG=["sum","mul","concat","ave"],qo=new Map;function Ct(e){$o(nG,"DataFormat",e)}function oG(e){$o(rG,"InterpolationFormat",e)}function ur(e){$o(aG,"PaddingMode",e)}function L2(e){$o(sG,"PoolMode",e)}var vp=[],Ok="/";function zs(e,t){vp.push(e);try{let n=t();return vp.pop(),n}catch(n){throw vp.pop(),n}}function lG(){return vp.length===0?"":vp.join(Ok)+Ok}function z2(e){if(!B2(e))throw new Error("Not a valid tensor name: '"+e+"'");return lG()+e}function P2(e){if(!B2(e))throw new Error("Not a valid tensor name: '"+e+"'");qo.has(e)||qo.set(e,0);let t=qo.get(e);if(qo.set(e,qo.get(e)+1),t>0){let n=`${e}_${t}`;return qo.set(n,1),n}else return e}var uG=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function B2(e){return!!e.match(uG)}function pG(e){return e===parseInt(e.toString(),10)}function Va(e,t,n){t==null&&(t=0),n==null&&(n=e.length);let r=1;for(let a=t;a<n;++a)r*=e[a];return r}function fl(e){if(e.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r<t&&(t=r)}return t}function Qa(e){if(e.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r>t&&(t=r)}return t}function Cr(e,t){if(t<e)throw new V(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let r=e;r<t;++r)n.push(r);return n}var tb;function Pt(){return tb==null&&(tb=Mx().epsilon()),tb}function _r(){return"channelsLast"}function ca(e,t){return oe(e,t)}function Md(e,t=-1){let n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),P(e,n)}function dG(e,t){return B(()=>{if(e.shape.length!==2)throw new V(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);let n=Md(e,1);return Rb(n,[1,t,1])})}function hG(e){let t=[Va(e.shape)];return P(e,t)}function cG(e){if(e.rank<=1)throw new V(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],Va(e.shape,1)];return P(e,t)}function Ps(e,t,n){return B(()=>{switch(e.rank){case 1:return $d(e,t,n);case 2:return hm(e,[t,0],[n,e.shape[1]]);case 3:return Fu(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return hl(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Ue(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Ue(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new V(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function nb(e,t,n){return B(()=>{switch(e.rank){case 1:return $d(e,t,n);case 2:return hm(e,[0,t],[e.shape[0],n]);case 3:return Fu(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return hl(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new V(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function _h(e,t,n,r){return B(()=>{switch(e.rank){case 1:return $d(e,t,n);case 2:switch(r){case 1:return Ps(e,t,n);case 2:return nb(e,t,n);default:throw new V(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Ps(e,t,n);case 2:return Fu(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return nb(e,t,n);default:throw new V(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Ps(e,t,n);case 2:return hl(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return hl(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return nb(e,t,n);default:throw new V(`The axis is not within the rank of the tensor ${r}`)}default:throw new V(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function rw(e,t=-1){let n;return t<0&&(n=e[0].rank,n!==0?t=n:t=0),t===e[0].rank&&(t=-1),ot(e,t)}function Lk(e,t){switch(e.rank){case 1:return ev([e,t]);case 2:return tv([e,t],0);case 3:return nv([e,t],0);case 4:return rv([e,t],0);default:throw new V(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function Rb(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new V(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return Vn(e,t)}function Cm(e,t=0,n=1,r,a){return sm(e,t,n,r,a)}function Hr(e,t,n,r){if(e.rank<2||t.rank<2)throw new ze(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){let a=e.shape.slice(-1)[0],s=t.shape.slice(-2)[0];if(a!==s)throw new ze(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(e.rank===2&&t.rank===2)return ml.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?Db(e.rank,r,_r()):null,activation:n});{let a=e.shape.slice(),s=a.pop();e=P(e,[-1,s]);let i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],p=Array.from({length:t.rank},(d,c)=>c===0?t.rank-2:c<=t.rank-2?c-1:c);t=P(Me(t,p),[l,-1]);let h=[...a,...u];return P(ml.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?Db(e.rank,r,_r()):null,activation:n}),h)}}function W2(e,t,n){return B(()=>(Array.isArray(t)?t=Qe(t,"int32"):t=oe(t,"int32"),$u(e,t,n)))}function Od(e){return z(e,e)}function Db(e,t,n){let r=t.shape;if(t.rank!==1&&t.rank!==e)throw new V(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(e===5){if(n==="channelsFirst")return r.length===1?P(t,[1,r[0],1,1,1]):P(t,[1,r[3],r[0],r[1],r[2]]);if(n==="channelsLast")return r.length===1?P(t,[1,1,1,1,r[0]]):P(t,[1].concat(r))}else if(e===4){if(n==="channelsFirst")return r.length===1?P(t,[1,r[0],1,1]):P(t,[1,r[2],r[0],r[1]]);if(n==="channelsLast")return r.length===1?P(t,[1,1,1,r[0]]):P(t,[1].concat(r))}else if(e===3){if(n==="channelsFirst")return r.length===1?P(t,[1,r[0],1]):P(t,[1,r[1],r[0]]);if(n==="channelsLast")return r.length===1?P(t,[1,1,r[0]]):P(t,[1].concat(r))}else if(e<3)return t;throw new V(`Unsupported input rank by biasAdd: ${t.rank}`)}function Fr(e,t,n){return B(()=>(n==null&&(n=_r()),Ct(n),Z(e,Db(e.rank,t,n))))}function mG(e,t=1){if(t!==1)throw new ze(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Cu(e)}function fG(e){return B(()=>ce(e,Z(At(e),1)))}function V2(e,t,n,r){return B(()=>Pv(e,t,n,r))}function gG(e){return B(()=>{let t=Z(.5,z(.2,e));return un(t,0,1)})}function Ld(e,t,n=!1){return n?e():t()}var yG=["fanIn","fanOut","fanAvg"],bG=["normal","uniform","truncatedNormal"];function xG(e){$o(yG,"FanMode",e)}function vG(e){$o(bG,"Distribution",e)}var br=class extends ne.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},aw=class extends br{apply(e,t){return It(e,t)}};aw.className="Zeros";ne.registerClass(aw);var _m=class extends br{apply(e,t){return En(e,t)}};_m.className="Ones";ne.registerClass(_m);var sw=class extends br{constructor(e){if(super(),typeof e!="object")throw new V(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new V(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return B(()=>z(ve(this.value),En(e,t)))}getConfig(){return{value:this.value}}};sw.className="Constant";ne.registerClass(sw);var iw=class extends br{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return hs(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};iw.className="RandomUniform";ne.registerClass(iw);var ow=class extends br{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new ze(`randomNormal does not support dType ${t}.`);return Cm(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};ow.className="RandomNormal";ne.registerClass(ow);var lw=class extends br{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new ze(`truncatedNormal does not support dType ${t}.`);return bm(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};lw.className="TruncatedNormal";ne.registerClass(lw);var uw=class extends br{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return B(()=>{if(e.length!==2||e[0]!==e[1])throw new V("Identity matrix initializer can only be used for 2D square matrices.");return z(this.gain,em(e[0]))})}getConfig(){return{gain:this.gain}}};uw.className="Identity";ne.registerClass(uw);function wG(e,t="channelsLast"){let n,r;if(Ct(t),e.length===2)n=e[0],r=e[1];else if([3,4,5].indexOf(e.length)!==-1){if(t==="channelsFirst"){let a=Va(e,2);n=e[1]*a,r=e[0]*a}else if(t==="channelsLast"){let a=Va(e,0,e.length-2);n=e[e.length-2]*a,r=e[e.length-1]*a}}else{let a=Va(e);n=Math.sqrt(a),r=Math.sqrt(a)}return[n,r]}var Rn=class extends br{constructor(e){if(super(),e.scale<0)throw new V(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,xG(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,vG(this.distribution),this.seed=e.seed}apply(e,t){let n=wG(e),r=n[0],a=n[1],s=this.scale;if(this.mode==="fanIn"?s/=Math.max(1,r):this.mode==="fanOut"?s/=Math.max(1,a):s/=Math.max(1,(r+a)/2),this.distribution==="normal"){let i=Math.sqrt(s);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new ze(`${this.getClassName()} does not support dType ${t}.`);return bm(e,0,i,t,this.seed)}else{let i=Math.sqrt(3*s);return hs(e,-i,i,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};Rn.className="VarianceScaling";ne.registerClass(Rn);var Em=class extends Rn{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Rn.className}};Em.className="GlorotUniform";ne.registerClass(Em);var $m=class extends Rn{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Rn.className}};$m.className="GlorotNormal";ne.registerClass($m);var Am=class extends Rn{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Rn.className}};Am.className="HeNormal";ne.registerClass(Am);var Fm=class extends Rn{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Rn.className}};Fm.className="HeUniform";ne.registerClass(Fm);var Rm=class extends Rn{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Rn.className}};Rm.className="LeCunNormal";ne.registerClass(Rm);var Dm=class extends Rn{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Rn.className}};Dm.className="LeCunUniform";ne.registerClass(Dm);var pw=class extends br{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return B(()=>{if(e.length<2)throw new ze("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;let n=w.sizeFromShape(e.slice(0,-1)),r=e[e.length-1],a=n*r;a>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);let s=[Math.max(r,n),Math.min(r,n)],i=Cm(s,0,1,t,this.seed),o=Uv.qr(i,!1),l=o[0],u=o[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return l=z(l,u.sign()),n<r&&(l=l.transpose()),z(ve(this.gain),l.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}};pw.className="Orthogonal";ne.registerClass(pw);var zk={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function Pk(e,t={}){return Dd(e,ne.SerializationMap.getMap().classNameMap,t,"initializer")}function St(e){return tw(e)}function xt(e){if(typeof e=="string"){let t=e in zk?zk[e]:e;if(t==="GlorotNormal")return new $m;if(t==="GlorotUniform")return new Em;if(t==="HeNormal")return new Am;if(t==="HeUniform")return new Fm;if(t==="LeCunNormal")return new Rm;if(t==="LeCunUniform")return new Dm;{let n={};return n.className=t,n.config={},Pk(n)}}else return e instanceof br?e:Pk(e)}function Mb(e){return Array.isArray(e)&&Array.isArray(e[0])}function ic(e){return e.length===0?[]:Array.isArray(e[0])?e:[e]}function Te(e){let t;if(Array.isArray(e)){if(e.length!==1)throw new V(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function Ke(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(e.length===1)return e=e,e[0];throw new V(`Expected exactly 1 Shape; got ${e.length}`)}else return e}function oc(e){let t=0;for(let n of e)n.shape.length===0?t+=1:t+=n.shape.reduce((r,a)=>r*a);return t}var Bk="Variable",U2=class{constructor(e,t="float32",n=Bk,r=!0,a=null){this.dtype=t==null?"float32":t,this.shape=e.shape,this.id=O2(),n=n==null?Bk:n,this.originalName=z2(n),this.name=P2(this.originalName),this.trainable_=r,this.constraint=a,this.val=Lv(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),kG(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function kG(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function Ob(e){return e.map(t=>t.read())}function dw(e){e.forEach(t=>{t[0].write(t[1])})}var Ft=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},Er=class{constructor(e,t,n,r,a,s,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=i,this.id=O2(),s!=null&&(this.originalName=z2(s),this.name=P2(this.originalName)),this.rank=t.length}},IG=0,Mm=class{constructor(e,t){this.callArgs=t,this.id=IG++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)n!=null&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},SG=0,Pe=class extends ne.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=SG++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let n=this.getClassName();t=sa(n)+"_"+Tm(n)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let n;if(e.batchInputShape!=null)n=e.batchInputShape;else if(e.inputShape!=null){let a=null;e.batchSize!=null&&(a=e.batchSize),n=[a].concat(e.inputShape)}this.batchInputShape=n;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new Wr(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new V(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return _n(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return _n(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Ra(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Ra(`Layer ${this.name} is not connected, no input to return.`);return _n(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Ra(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Ra(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return _n(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){let t=et(e);if(this.inputSpec==null||this.inputSpec.length===0)return;let n=et(this.inputSpec);if(t.length!==n.length)throw new V(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){let a=t[r],s=n[r];if(s==null)continue;let i=a.rank;if(s.ndim!=null&&i!==s.ndim)throw new V(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${i}`);if(s.maxNDim!=null&&i>s.maxNDim)throw new V(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${i}`);if(s.minNDim!=null&&i<s.minNDim)throw new V(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${i}.`);if(s.dtype!=null&&a.dtype!==s.dtype)throw new V(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${a.dtype}.`);if(s.axes){let o=a.shape;for(let l in s.axes){let u=Number(l),p=s.axes[l],h=u>=0?o[u]:o[o.length+u];if(p!=null&&[p,null].indexOf(h)===-1)throw new V(`Input ${r} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${p} but got shape ${o}.`)}}if(s.shape!=null)for(let o=0;o<s.shape.length;++o){let l=s.shape[o],u=a.shape[o];if(l!=null&&u!=null&&l!==u)throw new V(`Input ${r} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${a.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=et(e),r=CG(e),a=_G(e);if(r===a)throw new V("Arguments to apply() must be all SymbolicTensors or all Tensors");return zs(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let s=[];for(let i of et(e))s.push(i.shape);this.build(_n(s)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let s=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,s);let i=et(s),o=[];for(let l of i)n.indexOf(l)!==-1&&(l=l.clone()),o.push(l);if(s=_n(o),this.activityRegularizer!=null)throw new ze("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}else{let s=NG(e),i=this.computeOutputShape(s),o,l=TG(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?s[0]:s),i!=null&&i.length>0&&Array.isArray(i[0])?o=i.map((u,p)=>new Er(l,u,this,et(e),t,this.name,p)):o=new Er(l,i,this,et(e),t,this.name),this.addInboundNode(e,o,null,null,s,i,t),this._refCount++,this.activityRegularizer!=null)throw new ze("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,r)=>{n!=null&&e[r]!=null&&e[r]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Ra(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);e.indexOf(n)===-1&&e.push(n)}if(e.length===1){let t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new Ra(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Wr(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return oc(this.weights)}build(e){this.built=!0}getWeights(e=!1){return Ob(e?this.trainableWeights:this.weights)}setWeights(e){B(()=>{let t=this.weights;if(t.length!==e.length)throw new V(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;let n=[],r=Ob(t);for(let a=0;a<r.length;++a){let s=r[a],i=t[a],o=e[a];if(!w.arraysEqual(s.shape,o.shape))throw new V(`Layer weight shape ${s.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}dw(n)})}addWeight(e,t,n,r,a,s,i,o){if(this._addedWeightNames.indexOf(e)!==-1)throw new V(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(r=o!=null?o():xt("zeros"));let l=r.apply(t,n),u=new U2(l,n,e,s,i);return l.dispose(),a!=null&&this.addLoss(()=>a.apply(u.read())),s==null&&(s=!0),s?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=et(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;let r=this.computeMask(e,n),a=et(t),s=et(r);if(a.length!==s.length)throw new Error(`${this.name} outputs ${a.length} tensors but ${a.length} masks for those tensors`);for(let i=0;i<a.length;i++)a[i].kerasMask=s[i]}addInboundNode(e,t,n,r,a,s,i=null){let o=et(e);t=et(t),n=et(n),r=et(r),a=ic(a),s=ic(s);let l=[],u=[],p=[];for(let h of o)l.push(h.sourceLayer),u.push(h.nodeIndex),p.push(h.tensorIndex);new Mm({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:p,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:s},i);for(let h=0;h<t.length;h++)t[h].sourceLayer=this,t[h].nodeIndex=this.inboundNodes.length-1,t[h].tensorIndex=h}getConfig(){let e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function NG(e){e=et(e);let t=[];for(let n of e)t.push(n.shape);return _n(t)}function TG(e){return"float32"}function G2(e,t,n){if((t==null||n!=null&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),t.inboundNodes.length===0)return[e];{let r=t.inboundNodes[n];if(r.inboundLayers.length===0)return r.inputTensors;{let a=[];for(let s=0;s<r.inboundLayers.length;s++){let i=r.inputTensors[s],o=r.inboundLayers[s],l=r.nodeIndices[s],u=G2(i,o,l);for(let p of u)a.indexOf(p)===-1&&a.push(p)}return a}}}function CG(e){let t=!0;for(let n of et(e))if(!(n instanceof Er)){t=!1;break}return t}function _G(e){let t=!0;for(let n of et(e))if(n instanceof Er){t=!1;break}return t}var Du=class extends Pe{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:Tm("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new V("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new V("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new V("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let r=new Er(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new Mm({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new V(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};Du.className="InputLayer";ne.registerClass(Du);function H2(e){if(e.batchShape==null&&e.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(e.batchShape!=null&&e.shape!=null)throw new V("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;e.shape!=null&&t==null&&(t=[null].concat(e.shape));let n=e.dtype;return n==null&&(n="float32"),new Du({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}function EG(e,t){if(e.dtype==null||e.dtype===t.dtype)return t;try{return oe(t,e.dtype)}catch{throw new V(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}var Qo=class j2{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof j2)for(let n in t.id2Value)this.id2Value[n]=t.id2Value[n],n in t.id2Mask&&(this.id2Mask[n]=t.id2Mask[n]);else{if(t==null)return;for(let n of t)this.add(n.key,n.value)}}add(t,n,r){if(this.id2Value[t.id]==null)this.id2Value[t.id]=EG(t,n),this.name2Id[t.name]=t.id,r!=null&&(this.id2Mask[t.id]=r);else throw new V(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof Er){if(this.id2Value[t.id]==null)throw new V(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{let n=this.name2Id[t];if(n==null)throw new V(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[n]}}getMask(t){if(t instanceof Er){if(this.id2Value[t.id]==null)throw new V(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{let n=this.name2Id[t];if(n==null)throw new V(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[n]}}disposeMasks(){this.id2Mask!=null&&Ce(this.id2Mask)}},lc=new R2,uc=new R2;function $G(e){lc!=null&&lc.setMaxEntries(e),uc!=null&&uc.setMaxEntries(e)}function pp(e,t,n,r){let a=n==null?!1:n.training,s=Array.isArray(e),i=s?e:[e],o=i.map(m=>m.name),l=[],u=t.names();for(let m of o)u.indexOf(m)!==-1?l.push(t.getValue(m)):l.push(null);r!=null&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);let p=o.join(",")+"|"+t.names().sort().join(","),h=lc.get(p),d;if(h==null){let m=AG(i,t);h=m.sorted,d=m.recipientCounts,lc.put(p,h),uc.put(p,d)}d={},a||Object.assign(d,uc.get(p));let c=new Qo(t);for(let m=0;m<h.length;++m){if(r!=null){let A=rc().numTensors;A>r.maxNumTensors&&(r.maxNumTensors=A),A<r.minNumTensors&&(r.minNumTensors=A)}let f=h[m],g=f.sourceLayer;if(g instanceof Du)continue;let y=[],b=[],x=[],v=!1;for(let A of f.inputs){let R=c.getValue(A),F=c.getMask(A);y.push(R),b.push(F),F!=null&&(v=!0),a||(d[A.name]--,d[A.name]===0&&!t.hasKey(A)&&o.indexOf(A.name)===-1&&!R.isDisposed&&A.sourceLayer.stateful!==!0&&x.push(R))}v&&(n=n||{},n.mask=b[0]);let I=et(g.apply(y,n)),N=null;g.supportsMasking&&(N=g.computeMask(y,b));let C=RG(f),E=Array.isArray(C)?C:[C];for(let A=0;A<E.length;++A){c.hasKey(E[A])||c.add(E[A],I[A],Array.isArray(N)?N[0]:N);let R=o.indexOf(E[A].name);R!==-1&&(l[R]=I[A])}a||Ce(x)}return c.disposeMasks(),s?l:l[0]}function AG(e,t){w.assert(e!=null&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],r={};if(e.length===1){let a=Wk(e[0],t);n=a.sorted,r=a.recipientMap}else{let a=new Set;for(let s of e){let{sorted:i,recipientMap:o}=Wk(s,t);for(let l of i)a.has(l.name)||(n.push(l),a.add(l.name));for(let l in o)r[l]==null&&(r[l]=new Set),o[l].forEach(u=>r[l].add(u))}}return{sorted:n,recipientCounts:FG(r)}}function FG(e){let t={};for(let n in e)t[n]=e[n].size;return t}function Wk(e,t){let n=new Set,r=[],a={};for(let o of t.names())n.add(o);let s=[],i=[];for(s.push(e);s.length>0;){let o=s[s.length-1];if(n.has(o.name)){s.pop();continue}let l=i[i.length-1]===s.length-1;if(o.inputs.length===0||l)s.pop(),r.push(o),n.add(o.name),l&&i.pop();else{i.push(s.length-1);for(let u of o.inputs)a[u.name]==null&&(a[u.name]=new Set),a[u.name].add(o.name),!n.has(u.name)&&s.push(u)}}return{sorted:r,recipientMap:a}}function RG(e){let t;if(e.sourceLayer.inboundNodes.length===1)t=e.sourceLayer.output;else{let n=null;for(let r=0;r<e.sourceLayer.inboundNodes.length;++r)for(let a of e.sourceLayer.inboundNodes[r].outputTensors)if(a.id===e.id){n=r;break}t=e.sourceLayer.getOutputAt(n)}return t}var DG=G();DG.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,$G);var q2={};_e(q2,{maxNorm:()=>MG,minMaxNorm:()=>zG,nonNeg:()=>LG,unitNorm:()=>OG});function hw(e,t){return B(()=>Yt(fe(z(e,e),t,!0)))}var zd=class extends ne.Serializable{getConfig(){return{}}},cw=class extends zd{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return B(()=>{let t=hw(e,this.axis),n=un(t,0,this.maxValue);return z(e,ce(n,Z(Pt(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};cw.className="MaxNorm";ne.registerClass(cw);var mw=class extends zd{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return B(()=>ce(e,Z(Pt(),hw(e,this.axis))))}getConfig(){return{axis:this.axis}}};mw.className="UnitNorm";ne.registerClass(mw);var fw=class extends zd{apply(e){return nt(e)}};fw.className="NonNeg";ne.registerClass(fw);var gw=class extends zd{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return B(()=>{let t=hw(e,this.axis),n=Z(z(this.rate,un(t,this.minValue,this.maxValue)),z(1-this.rate,t));return z(e,ce(n,Z(Pt(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};gw.className="MinMaxNorm";ne.registerClass(gw);var Vk={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Wt(e){return tw(e)}function Uk(e,t={}){return Dd(e,ne.SerializationMap.getMap().classNameMap,t,"constraint")}function Vt(e){if(e==null)return null;if(typeof e=="string"){let t={className:e in Vk?Vk[e]:e,config:{}};return Uk(t)}else return e instanceof zd?e:Uk(e)}function MG(e){return new cw(e)}function OG(e){return new mw(e)}function LG(){return new fw}function zG(e){return new gw(e)}var K2={};_e(K2,{constant:()=>WG,glorotNormal:()=>KG,glorotUniform:()=>qG,heNormal:()=>XG,heUniform:()=>ZG,identity:()=>HG,leCunNormal:()=>JG,leCunUniform:()=>YG,ones:()=>BG,orthogonal:()=>QG,randomNormal:()=>UG,randomUniform:()=>VG,truncatedNormal:()=>GG,varianceScaling:()=>jG,zeros:()=>PG});function PG(){return new aw}function BG(){return new _m}function WG(e){return new sw(e)}function VG(e){return new iw(e)}function UG(e){return new ow(e)}function GG(e){return new lw(e)}function HG(e){return new uw(e)}function jG(e){return new Rn(e)}function qG(e){return new Em(e)}function KG(e){return new $m(e)}function XG(e){return new Am(e)}function ZG(e){return new Fm(e)}function JG(e){return new Rm(e)}function YG(e){return new Dm(e)}function QG(e){return new pw(e)}var X2={};_e(X2,{Layer:()=>Pe,RNN:()=>wa,RNNCell:()=>Bd,activation:()=>$6,add:()=>P6,alphaDropout:()=>kj,average:()=>B6,averagePooling1d:()=>_0,averagePooling2d:()=>E0,averagePooling3d:()=>$0,avgPool1d:()=>X6,avgPool2d:()=>J6,avgPool3d:()=>Q6,avgPooling1d:()=>Z6,avgPooling2d:()=>Y6,avgPooling3d:()=>ej,batchNormalization:()=>j6,bidirectional:()=>mj,categoryEncoding:()=>Cj,centerCrop:()=>Nj,concatenate:()=>W6,conv1d:()=>w6,conv2d:()=>k6,conv2dTranspose:()=>I6,conv3d:()=>S6,conv3dTranspose:()=>N6,convLstm2d:()=>pj,convLstm2dCell:()=>dj,cropping2D:()=>C6,dense:()=>A6,depthwiseConv2d:()=>E6,dot:()=>H6,dropout:()=>F6,elu:()=>f6,embedding:()=>z6,flatten:()=>D6,gaussianDropout:()=>wj,gaussianNoise:()=>vj,globalAveragePooling1d:()=>tj,globalAveragePooling2d:()=>nj,globalMaxPool1d:()=>gj,globalMaxPool2d:()=>yj,globalMaxPooling1d:()=>JT,globalMaxPooling2d:()=>YT,gru:()=>aj,gruCell:()=>sj,input:()=>cT,inputLayer:()=>m6,layerNormalization:()=>q6,leakyReLU:()=>y6,lstm:()=>ij,lstmCell:()=>oj,masking:()=>Ij,maxPool1d:()=>bj,maxPool2d:()=>xj,maxPooling1d:()=>QT,maxPooling2d:()=>eC,maxPooling3d:()=>rj,maximum:()=>V6,minimum:()=>U6,multiply:()=>G6,permute:()=>L6,prelu:()=>b6,randomWidth:()=>_j,reLU:()=>g6,repeatVector:()=>M6,rescaling:()=>Sj,reshape:()=>O6,resizing:()=>Tj,rnn:()=>hj,separableConv2d:()=>T6,simpleRNN:()=>lj,simpleRNNCell:()=>uj,softmax:()=>x6,spatialDropout1d:()=>R6,stackedRNNCells:()=>cj,thresholdedReLU:()=>v6,timeDistributed:()=>fj,upSampling2d:()=>_6,zeroPadding2d:()=>K6});async function Aa(e){if(e==null)return;let t=[],n=[],r=[];for(let a in e){let s=e[a];if(typeof s!="number"){let i=s;t.push(i.data()),n.push(a),r.push(i)}}if(t.length>0){let a=await Promise.all(t);for(let s=0;s<a.length;++s)e[n[s]]=a[s][0];Ce(r)}}function Z2(e){if(e!=null)for(let t in e){let n=e[t];typeof n!="number"&&n.dispose()}}var Gk;(function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"})(Gk||(Gk={}));var eH=125,gl=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},J2=class{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},tH=class extends gl{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});let n=t.size==null?0:t.size;this.seen+=n;for(let r in t){let a=t[r];if(typeof a=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+a*n;else{let s;r in this.totals?s=this.totals[r]:this.totals[r]=0;let i=B(()=>Z(this.totals[r],z(a,n)));this.totals[r]=i,s!=null&&s.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?t[n]=this.totals[n]/this.seen:B(()=>{let r=z(ce(1,this.seen),this.totals[n]);t[n]=r,this.totals[n].dispose(),zt(t[n])}))}},Y2=class extends gl{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(let n in t)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let a in this.history){let s=this.history[a];for(let i=0;i<s.length;++i)if(typeof s[i]!="number"){let o=s[i];e.push(o.data()),t.push(a),n.push(i)}}let r=await Promise.all(e);for(let a=0;a<r.length;++a)this.history[t[a]][n[a]].dispose(),this.history[t[a]][n[a]]=r[a][0]}},Q2=class extends gl{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Qv,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=eH),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");w.isNumber(this.yieldEvery)&&(this.maybeWait=eG(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let r=[];this.yield!=null&&(await Aa(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await Aa(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];this.epochEnd!=null&&(await Aa(t),n.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){this.batchBegin!=null&&(await Aa(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];this.batchEnd!=null&&(await Aa(t),n.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):w.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){this.trainBegin!=null&&(await Aa(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await Aa(e),await this.trainEnd(e))}};function eT(e,t){return e==null&&(e={}),e instanceof gl?[e]:Array.isArray(e)&&e[0]instanceof gl?e:et(e).map(n=>new Q2(n,t))}var yw=class Mr{constructor(){}static registerCallbackConstructor(t,n){w.assert(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),Mr.checkForDuplicate(n),Mr.constructors[t]==null&&(Mr.constructors[t]=[]),Mr.constructors[t].push(n)}static checkForDuplicate(t){for(let n in Mr.constructors)Mr.constructors[+n].forEach(r=>{if(r===t)throw new V("Duplicate callback constructor.")})}static clear(){Mr.constructors={}}static createCallbacks(t){let n=[];for(let r in Mr.constructors){let a=+r;t>=a&&n.push(...Mr.constructors[a])}return n.map(r=>new r)}};yw.constructors={};function tT(e,t,n,r,a,s,i,o,l){let u=new Y2,p=[new tH,...yw.createCallbacks(t)];e!=null&&p.push(...e),p.push(u);let h=new J2(p);return h.setParams({epochs:n,initialEpoch:r,samples:a,steps:s,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:h,history:u}}function Nr(e,t={},n=!1){return Dd(e,ne.SerializationMap.getMap().classNameMap,t,"layer",n)}function pc(e,t){return B(()=>{e.dtype!=="float32"&&(e=oe(e,"float32"));let n=fe(Od(e),t,!0),r=Un(n.shape,Pt()),a=Yt(Yr(n,r));return ce(e,a)})}function Ao(e,t){return B(()=>kt(Od(he(t,e)),-1))}function Om(e,t){return B(()=>kt(At(he(t,e)),-1))}function Mu(e,t){return B(()=>{let n=he(e,t),r=un(At(e),Pt(),Number.MAX_VALUE),a=At(ce(n,r));return z(100,kt(a,-1))})}function nH(e,t){return B(()=>{let n=un(t,Pt(),Number.MAX_VALUE),r=Hn(Z(1,n)),a=un(e,Pt(),Number.MAX_VALUE),s=Hn(Z(1,a));return kt(Od(he(r,s)),-1)})}function rH(e,t){return B(()=>{let n=Yr(0,he(1,z(e,t)));return kt(Od(n),-1)})}function aH(e,t){return B(()=>{let n=Yr(0,he(1,z(e,t)));return kt(n,-1)})}function sH(e,t){return B(()=>{let n=fe(z(e,t),-1),r=ar(z(he(1,e),t),-1);return Yr(0,Z(1,he(r,n)))})}function iH(e,t){return B(()=>{let n=Math.log(2),r=he(t,e),a=he(Z(r,_o(z(-2,r))),n);return kt(a,-1)})}function Rp(e,t,n=!1){return B(()=>{if(n)t=cs(t);else{let r=fe(t,t.shape.length-1,!0);t=ce(t,r)}return t=un(t,Pt(),1-Pt()),ft(fe(z(oe(e,"float32"),Hn(t)),t.shape.length-1))})}function dc(e,t,n=!1){return B(()=>{let r=oe(Eu(hG(e)),"int32");t=un(t,Pt(),1-Pt());let a=t.shape,s=P(pl(r,a[a.length-1]),a);return Rp(s,t,n)})}function oH(e,t){if(!w.arraysEqual(e.shape,t.shape))throw new V(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return B(()=>{let n=nt(t),r=ft(At(t));return Z(he(n,z(t,e)),Sd(pn(r)))})}function Lm(e,t){return B(()=>{let n;return n=un(t,Pt(),1-Pt()),n=Hn(ce(n,he(1,n))),kt(oH(e,n),-1)})}function lH(e,t){return B(()=>{let n=un(e,Pt(),1),r=un(t,Pt(),1);return fe(z(e,Hn(ce(n,r))),-1)})}function uH(e,t){return B(()=>{let n=Hn(Z(Pt(),t));return kt(he(t,z(e,n)),-1)})}function bw(e,t){return B(()=>{let n=pc(e,-1),r=pc(t,-1),a=z(n,r);return ft(fe(a,-1))})}var hc={meanSquaredError:Ao,meanAbsoluteError:Om,meanAbsolutePercentageError:Mu,meanSquaredLogarithmicError:nH,squaredHinge:rH,hinge:aH,categoricalHinge:sH,logcosh:iH,categoricalCrossentropy:Rp,sparseCategoricalCrossentropy:dc,binaryCrossentropy:Lm,kullbackLeiblerDivergence:lH,poisson:uH,cosineProximity:bw};function rb(e){if(typeof e=="string"){if(e in hc)return hc[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new V(t)}else return e}function xw(e,t){return B(()=>{let n=z(.5,jn(t)),r=ca(kn(t,n),e.dtype);return kt(Gn(e,r),-1)})}function vw(e,t){return B(()=>ca(Gn(qs(e,-1),qs(t,-1)),"float32"))}function nT(e,t){return B(()=>oe(fe(gr(Gn(e,1),Gn(t,1))),"float32"))}function pH(e,t){return B(()=>oe(fe(gr(Gn(e,1),Gn(t,0))),"float32"))}function dH(e,t){return B(()=>oe(fe(gr(Gn(e,0),Gn(t,1))),"float32"))}function rT(e,t){return B(()=>{let n=nT(e,t),r=dH(e,t),a=Z(n,r);return oe(Jt(kn(a,0),ce(n,a),0),"float32")})}function hH(e,t){return B(()=>{let n=nT(e,t),r=pH(e,t),a=Z(n,r);return oe(Jt(kn(a,0),ce(n,a),0),"float32")})}function aT(e,t){return Lm(e,t)}function sT(e,t){return e.rank===t.rank&&(e=ms(e,[e.rank-1])),t=qs(t,-1),t.dtype!==e.dtype&&(t=oe(t,e.dtype)),oe(Gn(e,t),"float32")}function cH(e,t){return B(()=>{let n=e.sub(t).square().sum(),r=e.sub(e.mean()).square().sum();return ve(1).sub(n.div(r))})}var mH=Ao,fH=Ao,gH=Om,yH=Om,bH=Mu,xH=Mu,ww=Rp,vH=bw,iT=dc,cc={binaryAccuracy:xw,categoricalAccuracy:vw,precision:rT,categoricalCrossentropy:ww,sparseCategoricalCrossentropy:iT,mse:mH,MSE:fH,mae:gH,MAE:yH,mape:bH,MAPE:xH,cosine:vH};function wH(e){if(typeof e=="string"&&e in cc)return cc[e];if(typeof e!="string"&&e!=null)return e;throw new V(`Unknown metric ${e}`)}function Eh(e){if(Pr(e!==null,`Unknown LossOrMetricFn ${e}`),typeof e=="string")return e;{let t;for(let n of Object.keys(hc))if(hc[n]===e){t=n;break}if(t!==void 0)return t;for(let n of Object.keys(cc))if(cc[n]===e){t=n;break}return t!==void 0?t:e.name}}function kH(e){let t={Adagrad:()=>_s.adagrad(.01),Adadelta:()=>_s.adadelta(1,.95,Pt()),Adam:()=>_s.adam(.001,.9,.999,Pt()),Adamax:()=>_s.adamax(.002,.9,.999,Pt(),0),RMSProp:()=>_s.rmsprop(.001,.9,0,Pt()),SGD:()=>_s.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new V(`Unknown Optimizer ${e}`)}function Hk(e,t,n=!1){if(e==null||typeof e!="object"||Object.getPrototypeOf(e)!==Object.prototype||!Lb(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let r=JSON.stringify(e);r.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function Lb(e){if(e===null)return!0;if(typeof e=="object")if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if(typeof n!="string"||!Lb(e[n]))return!1;return!0}else if(Array.isArray(e)){for(let t of e)if(!Lb(t))return!1;return!0}else return!1;else{let t=typeof e;return t==="string"||t==="number"||t==="boolean"}}function IH(e,t,n,r=console.log){let a=NH(e),s=["Layer (type)","Input Shape","Output shape","Param #"];a?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(p=>Math.floor(t*p)));let i;if(!a){s.push("Receives inputs"),i=[];for(let p in e.nodesByDepth)i.push(...e.nodesByDepth[p])}r("_".repeat(t)),mc(s,n,r),r("=".repeat(t));let o=e.layers;for(let p=0;p<o.length;++p)a?TH(o[p],n,r):CH(o[p],n,i,r),r((p===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let l=SH(e),u=oc(e.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}function SH(e){let t;return e.collectedTrainableWeights!=null?t=oc(e.collectedTrainableWeights):t=oc(e.trainableWeights),t}function NH(e){let t=!0,n=[],r=[];for(let a in e.nodesByDepth)n.push(e.nodesByDepth[a]);for(let a of n){if(a.length>1||a.length===1&&a[0].inboundLayers.length>1){t=!1;break}r.push(...a)}if(t)for(let a of e.layers){let s=!1;for(let i of a.inboundNodes)if(r.indexOf(i)!==-1)if(s){t=!1;break}else s=!0;if(!t)break}return t}function mc(e,t,n=console.log){let r="";for(let a=0;a<e.length;++a)a>0&&(r=r.slice(0,r.length-1)+" "),r+=e[a],r=r.slice(0,t[a]),r+=" ".repeat(t[a]-r.length);n(r)}function TH(e,t,n){let r,a;try{a=e.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{a="multiple"}try{r=JSON.stringify(e.outputShape)}catch{r="multiple"}let s=e.name,i=e.getClassName(),o=[`${s} (${i})`,a,r,e.countParams().toString()];mc(o,t,n)}function CH(e,t,n,r){let a,s;try{s=e.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{s="multiple"}try{a=JSON.stringify(e.outputShape)}catch{a="multiple"}let i=[];for(let h of e.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(h)===-1))for(let d=0;d<h.inboundLayers.length;++d){let c=h.inboundLayers[d].name,m=h.nodeIndices[d],f=h.tensorIndices[d];i.push(`${c}[${m}][${f}]`)}let o=e.name,l=e.getClassName(),u=i.length===0?"":i[0],p=[`${o} (${l})`,s,a,e.countParams().toString(),u];mc(p,t,r);for(let h=1;h<i.length;++h)mc(["","","","",i[h]],t,r)}function oT(e,t,n){return(e==="inboundNodes"||e==="outputLayers"||e==="inputLayers")&&t===0&&typeof n=="string"}function Dp(e,t){if(e===null)return null;if(typeof e=="string")return Fs(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let s=e[a];oT(t,a,s)?n.push(s):n.push(Dp(s,t))}return n}else{let n={};for(let r of Object.keys(e)){let a=e[r];if(r==="name"&&typeof a=="string")n[r]=a;else{let s=Fs(r);n[s]=Dp(a,s)}}return n}}function zb(e,t){if(e==null)return null;if(typeof e=="string")return sa(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let s=e[a];oT(t,a,s)?n.push(s):n.push(zb(s,t))}return n}else{let n={};for(let r of Object.keys(e)){let a=e[r],s=sa(r);(r==="name"||r==="className")&&typeof a=="string"?n[s]=a:n[s]=zb(a,r)}return n}}var kw="4.22.0",_H=e=>{let t=Object.keys(e);if(t.length===0)return!1;let n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))},EH=class Or extends Pe{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){let b=this.getClassName().toLowerCase();this.name=Tm(b)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],Wa(this.inputs).length!==this.inputs.length)throw new V(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);Wa(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let b of this.outputs){let x=b.sourceLayer,v=b.nodeIndex,I=b.tensorIndex;this.outputLayers.push(x),this.outputLayersNodeIndices.push(v),this.outputLayersTensorIndices.push(I)}for(let b of this.inputs){let x=b.sourceLayer,v=b.nodeIndex,I=b.tensorIndex;Pr(v===0,"input layer has >1 nodes"),Pr(I===0,"input layer has >1 tensors"),this.inputLayers.push(x),this.inputLayersNodeIndices.push(v),this.inputLayersTensorIndices.push(I)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){let x=this.inputLayers[b];if(!(x instanceof Du))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${b} (0-based) originates from layer type ${x.getClassName()}.`);this.inputNames.push(x.name),this.feedInputShapes.push(x.batchInputShape),this.feedInputNames.push(x.name)}for(let b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);let n={},r={},a={},s={},i={},o=[],l=(b,x,v,I,N,C)=>{(I==null||N==null||C==null)&&(I=b.sourceLayer,N=b.nodeIndex,C=b.tensorIndex);let E=I.inboundNodes[N];if(v.indexOf(E)!==-1)throw new Wr(`The tensor ${b.name} at layer "${I.name}" is part of a cycle.`);if(x.indexOf(E)!==-1)return;this.containerNodes.add(Or.nodeKey(I,N)),I.id in i||(i[I.id]=Object.keys(i).length),v.indexOf(E)===-1&&v.push(E);let A=E.inboundLayers.length;for(let R=0;R<A;R++){let F=E.inputTensors[R],S=E.inboundLayers[R],M=E.nodeIndices[R],W=E.tensorIndices[R];l(F,x,v,S,M,W)}for(x.push(E);v.indexOf(E)>=0;)v.splice(v.indexOf(E),1);o.push(E)},u=[],p=[];for(let b of this.outputs)l(b,u,p);let h=o.slice().reverse();for(let b of h){r[b.id]=b,b.id in n||(n[b.id]=0);let x=n[b.id],v=a[b.outboundLayer.id]==null?0:a[b.outboundLayer.id];x=Math.max(x,v),a[b.outboundLayer.id]=x,s[b.outboundLayer.id]=b.outboundLayer,n[b.id]=x;for(let I=0;I<b.inboundLayers.length;I++){let N=b.inboundLayers[I],C=b.nodeIndices[I],E=N.inboundNodes[C],A=n[E.id]==null?0:n[E.id];n[E.id]=Math.max(x+1,A),r[E.id]=E}}let d={};for(let b in n){let x=n[b];x in d||(d[x]=[]),d[x].push(r[b])}let c={};for(let b in a){let x=a[b];x in c||(c[x]=[]),c[x].push(s[b])}let m=Object.keys(c).map(b=>parseInt(b,10)).sort(Th);this.layers=[];for(let b of m){let x=c[b];x.sort((v,I)=>{let N=i[v.id],C=i[I.id];return N<C?-1:N>C?1:0});for(let v of x)v instanceof Or&&this.internalContainerRefs.push(v),this.layers.push(v)}this.layersByDepth=c,m=Object.keys(d).map(b=>parseInt(b,10)).sort(Th);let f=this.inputs.slice(),g=[];for(let b of m)for(let x of d[b]){let v=x.outboundLayer;if(v!=null){for(let I of x.inputTensors)if(f.indexOf(I)===-1)throw new Wr(`Graph disconnected: cannot obtain value for tensor ${I} at layer "${v.name}". The following previous layers were accessed without issue: ${g}`);for(let I of x.outputTensors)f.push(I);g.push(v.name)}}this.nodesByDepth=d;let y=this.layers.map(b=>b.name);for(let b of y){let x=y.filter(v=>v===b).length;if(x!==1)throw new Wr(`The name "${b}" is used ${x} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new Mm({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let n of this.layers)t.numDisposedVariables+=n.dispose().numDisposedVariables;for(let n of this.internalContainerRefs)t.numDisposedVariables+=n.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(n=>{n._trainableWeights.forEach(r=>r.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new V("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(let n of this.layers)t=t.concat(n.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let n of this.layers)t.push(...n.nonTrainableWeights);if(!this.trainable){let n=[];for(let r of this.layers)n.push(...r.trainableWeights);return n.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,n=!0){let r={},a=0,s=_H(t);s&&this.parseWeights(t);for(let o of this.layers)for(let[l,u]of o.weights.entries()){let p=s?`${u.name.split("/").slice(0,-1).join("/")+"/"}${l}`:u.originalName;if(r[p]!=null)throw new V(`Duplicate weight name: ${p}`);r[p]=u,a++}let i=[];for(let o in t){let l=o;if(r[o]==null){let u=o.split("/");l=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(r[l]!=null)i.push([r[l],t[o]]);else if(n)throw new V(`Provided weight data has no target variable: ${o}`);delete r[l]}if(n){let o=[];for(let l in r)o.push(l);if(o.length>0)throw new V(`${o.length} of ${a} weights are not set: ${o}`)}dw(i)}parseWeights(t){for(let n in Object.keys(t)){let r=n.split("/"),a=["vars","layer_checkpoint_dependencies"],s=r.map(i=>i.startsWith("_")?i.slice(1):i).filter(i=>!a.includes(i)).join("/");s!==n&&(t[s]=t[n],delete t[n])}}updatedConfig(){let t=this.getConfig(),n={};return n.className=this.getClassName(),n.config=t,n.kerasVersion=`tfjs-layers ${kw}`,n.backend="TensorFlow.js",n}toJSON(t,n=!0){let r=zb(this.updatedConfig());return n?JSON.stringify(r):r}call(t,n){return B(()=>{t=et(t);let r=new Qo;for(let a=0;a<this.inputs.length;++a)r.add(this.inputs[a],t[a]);return pp(this.outputs,r,n)})}computeMask(t,n){return B(()=>{t=et(t);let r;return n==null?r=Ys(null,t.length):r=et(n),this.runInternalGraph(t,r)[1]})}computeOutputShape(t){let n=ic(t);if(n.length!==this.inputLayers.length)throw new V(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);let r={};for(let o=0;o<n.length;o++){let l=this.inputLayers[o],u=n[o],p=l.name+"_0_0";r[p]=u}let a=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(Th);if(a.length>1)for(let o of a){let l=this.nodesByDepth[o];for(let u of l){let p=u.outboundLayer;if(this.inputLayers.map(f=>f.id).indexOf(p.id)!==-1)continue;let h=[];for(let f=0;f<u.inboundLayers.length;f++){let g=u.inboundLayers[f],y=u.nodeIndices[f],b=u.tensorIndices[f],x=`${g.name}_${y}_${b}`,v=r[x];h.push(v)}let d=p.computeOutputShape(_n(h)),c=ic(d),m=p.inboundNodes.indexOf(u);for(let f=0;f<c.length;f++){let g=`${p.name}_${m}_${f}`;r[g]=c[f]}}}let s=[],i=[];for(let o=0;o<this.outputLayers.length;o++){let l=this.outputLayers[o],u=this.outputLayersNodeIndices[o],p=this.outputLayersTensorIndices[o],h=`${l.name}_${u}_${p}`;i.push(h)}for(let o=0;o<i.length;o++){let l=i[o];Pr(l in r),s.push(r[l])}return _n(s)}runInternalGraph(t,n){n==null&&(n=Ys(null,t.length));let r={};for(let l=0;l<this.inputs.length;++l){let u=this.inputs[l],p=t[l],h=n[l];r[u.id]=[p,h]}let a=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(Th);for(let l of a){let u=this.nodesByDepth[l];for(let p of u){let h=p.outboundLayer,d=p.inputTensors,c=p.outputTensors,m=new Array;for(let f of d)f.id in r&&m.push(r[f.id]);if(m.length===d.length){let f={},g,y,b,x;if(p.callArgs!=null&&(f=p.callArgs),m.length===1){let[v,I]=m[0];f.mask==null&&(f.mask=I),b=et(h.call(v,f)),x=et(h.computeMask(v,I)),g=[v],y=[I]}else g=m.map(v=>v[0]),y=m.map(v=>v[1]),f.mask==null&&(f.mask=y),b=et(h.call(g,f)),x=et(h.computeMask(g,y));if(h.activityRegularizer)throw new ze("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let v=0;v<c.length;++v){let I=c[v],N=b[v],C=x[v];r[I.id]=[N,C]}}}}let s=[],i=[],o=[];for(let l of this.outputs){Pr(l.id in r,`Could not compute output ${l.name} : ${l.id}`);let[u,p]=r[l.id];o.push(u.shape),s.push(u),i.push(p)}return[s,i,o]}buildNodeConversionMap(t){let n={},r;for(let a of this.layers){r=a instanceof Or?1:0;for(let s=0;s<a.inboundNodes.length;s++){let i=Or.nodeKey(a,s);this.containerNodes.has(i)&&(n[i]=r,r+=1)}}return n}getLayer(t,n){if(n!=null)return this.findLayer(n);if(t==null)throw new V("Provide either a layer name or layer index");if(typeof t=="number")return this.findLayer(t);for(let r of this.layers)if(r.name===t)return r;throw new V(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new V(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return B(()=>{let t=[];for(let n of this.layers)for(let r=0;r<n.inboundNodes.length;++r){let a=Or.nodeKey(n,r);this.containerNodes.has(a)&&t.push(...n.calculateLosses())}return t})}getConfig(){let t={name:this.name},n=this.buildNodeConversionMap(this.layers),r=[];for(let i of this.layers){let o=i.getClassName(),l=i.getConfig(),u=[];for(let h=0;h<i.inboundNodes.length;h++){let d=i.inboundNodes[h],c=Or.nodeKey(i,h),m={};if(this.containerNodes.has(c)){if(d.callArgs)try{JSON.stringify(d.callArgs),m=d.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),m={}}if(d.inboundLayers.length>0){let f=[];for(let g=0;g<d.inboundLayers.length;g++){let y=d.inboundLayers[g],b=d.nodeIndices[g],x=d.tensorIndices[g],v=Or.nodeKey(y,b),I=n[v];I==null&&(I=0),f.push([y.name,I,x,m])}u.push(f)}}}let p={};p.name=i.name,p.className=o,p.config=l,p.inboundNodes=u,r.push(p)}t.layers=r;let a=[];for(let i=0;i<this.inputLayers.length;i++){let o=this.inputLayers[i],l=this.inputLayersNodeIndices[i],u=Or.nodeKey(o,l);if(!this.containerNodes.has(u))continue;let p=n[u];p==null&&(p=0);let h=this.inputLayersTensorIndices[i];a.push([o.name,p,h])}t.inputLayers=a;let s=[];for(let i=0;i<this.outputLayers.length;i++){let o=this.outputLayers[i],l=this.outputLayersNodeIndices[i],u=Or.nodeKey(o,l);if(!this.containerNodes.has(u))continue;let p=n[u];p==null&&(p=0);let h=this.outputLayersTensorIndices[i];s.push([o.name,p,h])}return t.outputLayers=s,t}static fromConfig(t,n,r={},a=!1){let s={},i={};function o(g,y){g.name in i?i[g.name].push(y):i[g.name]=[y]}function l(g,y){let b=[],x;for(let v of y){let I=v[0],N=v[1],C=v[2];if(x=v[3]==null?{}:v[3],!(I in s)){o(g,y);return}let E=s[I];if(E.inboundNodes.length<=N){o(g,y);return}let A=E.inboundNodes[N];b.push(A.outputTensors[C])}b.length>0&&g.apply(_n(b),x)}function u(g){let y=g.name,b=Nr(g,n.customObjects!=null?n.customObjects:{});b.setFastWeightInitDuringBuild(a),s[y]=b,g.inboundNodes.forEach(x=>{if(!(x instanceof Array))throw new V(`Corrupted configuration, expected array for nodeData: ${x}`);o(b,x)})}let p=n.name,h=n.layers;for(let g of h)u(g);for(;!QU(i);)for(let g of h){let y=s[g.name];if(y.name in i){let b=i[y.name];delete i[y.name];for(let x of b)l(y,x)}}let d=[],c=[],m=n.inputLayers;for(let g of m){let y=g[0],b=g[1],x=g[2];Pr(y in s);let v=s[y].inboundNodes[b].outputTensors;d.push(v[x])}let f=n.outputLayers;for(let g of f){let y=g[0],b=g[1],x=g[2];Pr(y in s);let v=s[y].inboundNodes[b].outputTensors;c.push(v[x])}return new t({inputs:d,outputs:c,name:p})}get stateful(){if(this._stateful)throw new V("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let t of this.layers)if(t.stateful)return!0;return!1}resetStates(){B(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}};function $H(e,t,n){let r=t.length;if(e==null||Array.isArray(e)&&e.length===0)return t.map(a=>null);if(r===1)return Array.isArray(e)&&e.length===1?e:typeof e=="object"&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}else if(typeof e=="object"&&Object.keys(e).length>0&&typeof e[Object.keys(e)[0]]=="object"){let a=[];return t.forEach(s=>{s in e?a.push(e[s]):a.push(null)}),a}else throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function lT(e,t){return $H(e,t,"classWeight")}async function uT(e,t,n,r){if(t!=null||r!=null)throw new Error("Support sampleWeight is not implemented yet");if(n!=null){let a=B(()=>{if(e.shape.length===1)return Ur(e);if(e.shape.length===2){if(e.shape[1]>1)return qs(e,1);if(e.shape[1]===1)return P(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(await a.data());Ce(a);let i=[];return s.forEach(o=>{if(n[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);i.push(n[o])}),Qe(i,"float32")}else return null}function AH(e,t){return z(e,t)}var FH=32;function pT(e,t){let n,r,a=t;n=a.xs,r=a.ys,w.assert(n!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let s=jk("input",e.inputNames,n),i=jk("output",e.outputNames,r),o=s[0].shape[0];w.assert(s.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),w.assert(i.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let l=0;l<s.length;l++)w.assert(s[l].shape[0]===o,()=>`Batch size mismatch: input ${e.inputNames[l]} has ${s[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);for(let l=0;l<i.length;l++)w.assert(i[l].shape[0]===o,()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);return{xs:s,ys:i}}function jk(e,t,n){if(n instanceof Re)return[n];if(Array.isArray(n))return w.assert(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{let r=[];for(let a of t){if(n[a]==null)throw new V(`The feature data generated by the dataset lacks the required ${e} key '${a}'.`);r.push(n[a])}return r}}function RH(e){if(e.length===3)throw new ze("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}async function DH(e,t,n){let r=n.batchesPerEpoch!=null;if(w.assert(e.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),w.assert(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),w.assert(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),w.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),w.assert(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let a=n.validationData!=null,s,i;if(a)if(qk(n.validationData))w.assert(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{let g=RH(n.validationData);s=g.xs,i=g.ys}let o=e.makeTrainFunction(),l=e.getDedupedMetricsNames(),u;a?u=l.slice().concat(l.map(g=>"val_"+g)):u=l.slice();let p=eT(n.callbacks,n.yieldEvery),h=n.verbose==null?1:n.verbose,{callbackList:d,history:c}=tT(p,h,n.epochs,null,null,MH(t,n),null,a,u);d.setModel(e),e.history=c,await d.onTrainBegin(),e.stopTraining_=!1;let m=n.initialEpoch==null?0:n.initialEpoch,f=await t.iterator();for(;m<n.epochs;){let g={};await d.onEpochBegin(m);let y=0,b=0;for(r||(f=await t.iterator());!r||y<n.batchesPerEpoch;){let x=await f.next();if(r&&x.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(x.value!=null){let{xs:v,ys:I}=pT(e,x.value),N={};N.batch=b,N.size=v[0].shape[0],await d.onBatchBegin(b,N);let C=[];if(n.classWeight!=null){let R=lT(n.classWeight,e.outputNames);for(let F=0;F<R.length;++F)C.push(await uT(I[F],null,R[F]))}let E=v.concat(I).concat(C),A=o(E);Ce(E);for(let R=0;R<l.length;++R){let F=l[R],S=A[R];N[F]=S,zt(S)}await d.onBatchEnd(b,N),Z2(N),b++,y++}if(r?y>=n.batchesPerEpoch:x.done){if(a){let v;qk(n.validationData)?v=et(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):v=et(e.evaluate(s,i,{batchSize:n.validationBatchSize==null?FH:n.validationBatchSize,verbose:0}));for(let I=0;I<e.metricsNames.length;++I)g[`val_${e.metricsNames[I]}`]=v[I]}break}if(e.stopTraining_)break}if(await d.onEpochEnd(m,g),m++,e.stopTraining_)break}return await d.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function MH(e,t){let n=null;return t.batchesPerEpoch!=null?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function qk(e){return typeof e.iterator=="function"}function OH(e){return typeof e.next=="function"}async function LH(e,t,n){n=n||{};let r=n.batches!=null,a=e.testFunction,s=[];if(n.verbose>0)throw new ze("Verbose mode is not implemented yet.");w.assert(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);let i=OH(t)?t:await t.iterator(),o=0,l=0;for(;!r||l<n.batches;){let u=await i.next();if(s=B(()=>{if(u.value){let{xs:p,ys:h}=pT(e,u.value),d=p.concat(h),c=B(()=>a(d));if(Ce(d),l===0)for(let f=0;f<c.length;++f)s.push(ve(0));let m=d[0].shape[0];for(let f=0;f<c.length;++f){let g=c[f],y=s[f];s[f]=B(()=>Z(s[f],z(m,g))),l>0&&Ce(y)}Ce(c),o+=m,++l}return s}),u.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<s.length;++u){let p=s[u];s[u]=ce(s[u],o),Ce(p)}return _n(s)}function ab(e){w.assert(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function ap(e,t,n){return e==null?[null]:Array.isArray(e)?e.map(r=>Ps(r,t,n-t)):Ps(e,t,n-t)}function Pb(e,t){return B(()=>e==null?null:Array.isArray(e)?e.map(n=>Pb(n,t)):W2(e,t.dtype==="int32"?t:oe(t,"int32")))}function sb(e,t){let n=[],r=0,a=null;for(;r<e;)a=r+t,a>=e&&(a=e),n.push([r,a]),r=a;return n}function dT(e){let t=[];e instanceof Re&&(e=[e]);for(let n=0;n<e.length;++n){let r=e[n];if(r.rank===1)t.push(Md(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function vr(e,t){if(e==null)return;let n=[];if(t instanceof Re)n.push(t.id);else if(Array.isArray(t))t.forEach(a=>n.push(a.id));else if(t!=null)for(let a in t){let s=t[a];n.push(s.id)}let r=[];if(e instanceof Re)n.indexOf(e.id)===-1&&r.push(e);else if(Array.isArray(e))e.forEach(a=>{n.indexOf(a.id)===-1&&r.push(a)});else if(e!=null)for(let a in e){let s=e[a];n.indexOf(s.id)===-1&&r.push(s)}r.forEach(a=>{a.isDisposed||a.dispose()})}function zH(e){return e instanceof Re}function Bb(e){return Array.isArray(e)}function Kk(e){return!zH(e)&&!Bb(e)}function Xk(e,t,n,r=!0,a=""){if(t==null||t.length===0){if(e!=null){let i=!1;if(Bb(e)&&e.length>0)i=!0;else if(Kk(e)){for(let o in e)if(e.hasOwnProperty(o)){i=!0;break}}else i=!0;if(i)throw new V(`Error when checking model ${a} expected no data, but got ${e}`)}return[]}if(e==null)return t.map(i=>null);let s;if(Kk(e)){e=e,s=[];for(let i of t){if(e[i]==null)throw new V(`No data provided for "${i}". Need data for each key in: ${t}`);s.push(e[i])}}else if(Bb(e)){if(e=e,e.length!==t.length)throw new V(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);s=e}else{if(e=e,t.length>1)throw new V(`The model ${a} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);s=[e]}if(s=dT(s),n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;let o=s[i];if(o.shape.length!==n[i].length)throw new V(`Error when checking ${a}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${o.shape}`);for(let l=0;l<n[i].length;++l){if(l===0&&!r)continue;let u=o.shape[l],p=n[i][l];if(p!=null&&p>=0&&u!==p)throw new V(`${a} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${a} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return s}function PH(e,t,n){let r=Wa(e.map(s=>s.shape[0]));r.sort();let a=Wa(t.map(s=>s.shape[0]));if(a.sort(),r.length>1)throw new V(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(s=>s.shape))}`);if(a.length>1)throw new V(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(s=>s.shape))}`);if(r.length>0&&a.length>0&&!w.arraysEqual(r,a))throw new V(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${a[0]} target sample(s).`)}function BH(e,t,n){let r=[Ao,Lm,Rp];for(let a=0;a<e.length;++a){let s=e[a],i=t[a],o=n[a];if(i!=null){if(i===Rp&&s.shape[s.shape.length-1]===1)throw new V(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(i)!==-1){let l=s.shape.slice(1),u=o.slice(1);for(let p=0;p<l.length;++p){let h=l[p],d=u[p];if(d!=null&&h!==d)throw new V(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function Zk(e,t,n,r=!0,a=""){let s;if(Array.isArray(e)){if(e.length!==t.length)throw new V(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);s=e}else{if(t.length>1)throw new V(`The model expects ${t.length} ${a} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);s=[e]}if(n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;let o=s[i];if(o.shape.length!==n[i].length)throw new V(`Error when checking ${a}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let l=0;l<n[i].length;++l){if(l===0&&!r)continue;let u=o.shape[l],p=n[i][l];if(p!=null&&p!==u)throw new V(`Error when checking ${a}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function WH(e,t){if(e==null||Array.isArray(e)&&e.length===0)return t.map(r=>[]);let n;if(typeof e=="string"||typeof e=="function")n=[e];else if(Array.isArray(e)||typeof e=="object")n=e;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(n))return t.map(r=>n);{let r=[];for(let a of t){let s=n.hasOwnProperty(a)?n[a]:[];Array.isArray(s)||(s=[s]),r.push(s)}return r}}var VH="layers-model",pa=class extends EH{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new V("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");IH(this,e,t,n)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=kH(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof va))throw new V("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(let s in e.loss)if(this.outputNames.indexOf(s)===-1)throw new V(`Unknown entry in loss dictionary: "${s}". Only expected the following keys: ${this.outputNames}`);for(let s of this.outputNames)e.loss[s]==null&&console.warn(`Output "${s}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${s} during training`),t.push(rb(e.loss[s]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new V(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(s=>rb(s))}else{let s=rb(e.loss);this.outputs.forEach(i=>{t.push(s)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){let i=this.internalOutputShapes[s],o=this.outputNames[s];this.feedOutputNames.push(o),this.feedOutputShapes.push(i),this.feedLossFns.push(this.lossFunctions[s])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],zs("loss",()=>{for(let s=0;s<this.outputs.length;++s){if(n.indexOf(s)!==-1)continue;let i=this.lossFunctions[s];this.outputs.length>1&&(this.metricsTensors.push([i,s]),this.metricsNames.push(this.outputNames[s]+"_loss"))}});let r=WH(e.metrics,this.outputNames),a=(s,i,o)=>{this.outputNames.length>1&&(i=this.outputNames[s]+"_"+i),this.metricsNames.push(i),this.metricsTensors.push([o,s])};zs("metric",()=>{for(let s=0;s<this.outputs.length;++s){if(n.indexOf(s)!==-1)continue;let i=r[s];(o=>{let l="",u,p,h;for(let d of o){if(typeof d=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(d)!==-1){let m=this.internalOutputShapes[s];m[m.length-1]===1||this.lossFunctions[s]===Lm?["accuracy","acc"].indexOf(d)!==-1?p=xw:["crossentropy","ce"].indexOf(d)!==-1&&(p=aT):this.lossFunctions[s]===dc?["accuracy","acc"].indexOf(d)!==-1?p=sT:["crossentropy","ce"].indexOf(d)!==-1&&(p=iT):["accuracy","acc"].indexOf(d)!==-1?p=vw:["crossentropy","ce"].indexOf(d)!==-1&&(p=ww);let f;["accuracy","acc"].indexOf(d)!==-1?f="acc":["crossentropy","ce"].indexOf(d)!==-1&&(f="ce"),h=p,u=l+f}else h=wH(d),u=l+Eh(d);let c;zs(u,()=>{c=h}),a(s,u,c)}})(i)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){let r=n.batchSize==null?32:n.batchSize;ab(r);let a=this.standardizeUserDataXY(e,t,!0,r);try{let s=a[0].concat(a[1]);this.makeTestFunction();let i=this.testFunction,o=this.testLoop(i,s,r,n.verbose,n.steps);return _n(o)}finally{vr(a[0],e),vr(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),LH(this,e,t)}checkNumSamples(e,t,n,r="steps"){let a;if(n!=null){if(a=null,t!=null)throw new V(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?a=e[0].shape[0]:a=e.shape[0];else throw new V(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return a}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new V("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),r=n?t:[t],a=this.retrieveSymbolicTensors(r),s=new Qo;if(e instanceof Re&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new V(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let o=0;o<this.inputs.length;++o)s.add(this.inputs[o],e[o])}else for(let o of this.inputs){let l=e[o.name];if(l==null)throw new V(`No value is provided for the model's input ${o.name}`);s.add(o,l)}let i=pp(a,s);return n?i:i[0]}retrieveSymbolicTensors(e){let t=Ys(null,e.length),n=e.length;for(let r of this.layers){let a=Array.isArray(r.output)?r.output:[r.output],s=a.map(i=>i.name);for(let i=0;i<e.length;++i){let o=s.indexOf(e[i]);if(o!==-1&&(t[i]=a[o],n--),n===0)break}if(n===0)break}if(n>0){let r=[];throw t.forEach((a,s)=>{a==null&&r.push(e[s])}),new V(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,n=!1){return B(()=>{let r=this.checkNumSamples(e);if(n)throw new ze("Verbose predictLoop() is not implemented yet.");let a=sb(r,t),s=this.outputs.map(i=>[]);for(let i=0;i<a.length;++i)B(()=>{let o=a[i][0],l=a[i][1],u=ap(e,o,l),p=[];if(Array.isArray(u))for(let d=0;d<u.length;++d)p.push({key:this.inputs[d],value:u[d]});else p.push({key:this.inputs[0],value:u});let h=new Qo(p);return pp(this.outputs,h)}).forEach((o,l)=>s[l].push(o));return _n(s.map(i=>ot(i,0)))})}predict(e,t={}){let n=dT(e);Zk(n,this.inputNames,this.feedInputShapes,!1);try{let r=t.batchSize==null?32:t.batchSize;return ab(r),this.predictLoop(n,r)}finally{vr(n,e)}}predictOnBatch(e){Zk(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(this.optimizer_==null)throw new Wr("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let a=[];for(let s=0;s<this.feedOutputShapes.length;++s){let i=this.feedOutputShapes[s];this.feedLossFns[s]===dc?a.push(i.slice(0,i.length-1).concat([1])):a.push(i)}if(e=Xk(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=Xk(t,this.feedOutputNames,a,!1,"target"),PH(e,t,null),BH(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new V(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,a=!0,s){let[i,o]=this.standardizeUserDataXY(e,t,a,s);if(n!=null)throw new Error("sample weight is not supported yet.");let l=null;if(r!=null){let u=lT(r,this.outputNames);l=[];for(let p=0;p<u.length;++p)l.push(await uT(o[p],null,u[p]))}return[i,o,l]}testLoop(e,t,n,r=0,a){return B(()=>{let s=this.checkNumSamples(t,n,a,"steps"),i=[];if(r>0)throw new ze("Verbose mode is not implemented yet.");if(a!=null)throw new ze("steps mode in testLoop() is not implemented yet");{let o=sb(s,n),l=Qe(Cr(0,s));for(let u=0;u<o.length;++u){let p=o[u][0],h=o[u][1],d=Ps(l,p,h-p),c=Pb(t,d),m=e(c);if(u===0)for(let f=0;f<m.length;++f)i.push(ve(0));for(let f=0;f<m.length;++f){let g=m[f];i[f]=Z(i[f],z(h-p,g))}}for(let u=0;u<i.length;++u)i[u]=ce(i[u],s)}return i})}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let r=e[n],a=r;if(Mk(e,r)>1){let s=Mk(e.slice(0,n),r);a+=`_${s}`}t.push(a)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),s=[],i=()=>{let l=[];for(let d=0;d<this.inputs.length;++d)l.push({key:this.inputs[d],value:n[d]});let u=new Qo(l),p=pp(this.outputs,u,{training:!0}),h;for(let d=0;d<this.lossFunctions.length;++d){let c=this.lossFunctions[d],m=c(r[d],p[d]);a[d]!=null&&(m=AH(m,a[d]));let f=kt(m);t.push(f),d===0?h=m:h=Z(h,m)}for(let d=0;d<this.metricsTensors.length;++d){let c;if(this.outputs.length>1&&d<this.outputs.length)c=t[d];else{let m=this.metricsTensors[d][0],f=this.metricsTensors[d][1];c=kt(m(r[f],p[f]))}zt(c),s.push(c)}return h=kt(h),this.calculateLosses().forEach(d=>{h=Z(h,d)}),h},o=this.collectedTrainableWeights.map(l=>l.read());return[this.optimizer_.minimize(i,!0,o)].concat(s)}}makeTestFunction(){this.testFunction=e=>B(()=>{let t=[],n,r=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let l=0;l<this.inputs.length;++l)s.push({key:this.inputs[l],value:r[l]});let i=new Qo(s),o=pp(this.outputs,i);for(let l=0;l<this.lossFunctions.length;++l){let u=this.lossFunctions[l],p=kt(u(a[l],o[l]));l===0?n=p:n=Z(n,p),t.push(n)}for(let l=0;l<this.metricsTensors.length;++l){let u=this.metricsTensors[l][0],p=this.metricsTensors[l][1],h=kt(u(a[p],o[p]));t.push(h)}return t})}async fit(e,t,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,a,s,i,o,l,u,p,h;try{let d=n.batchSize==null?32:n.batchSize;ab(d);let c=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,!1,d);r=c[0],a=c[1],h=c[2];let m=!1,f;if(n.validationData!=null&&n.validationData.length>0){if(m=!0,n.validationData.length===2)o=n.validationData[0],l=n.validationData[1];else throw n.validationData.length===3?new ze("validationData including sample weights is not supported yet."):new V(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let N=await this.standardizeUserData(o,l,null,null,!0,d);u=N[0],p=N[1],f=u.concat(p)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){m=!0;let N=Math.floor(r[0].shape[0]*(1-n.validationSplit)),C=r[0].shape[0];u=ap(r,N,C),s=r,r=ap(r,0,N),p=ap(a,N,C),i=a,a=ap(a,0,N),f=u.concat(p)}else n.validationSteps!=null&&(m=!0);let g=r.concat(a).concat(h);this.checkTrainableWeightsConsistency();let y=this.makeTrainFunction(),b=this.getDedupedMetricsNames(),x,v;m?(this.makeTestFunction(),x=this.testFunction,v=b.slice().concat(b.map(N=>"val_"+N))):(x=null,f=[],v=b.slice());let I=eT(n.callbacks,n.yieldEvery);return await this.fitLoop(y,g,b,d,n.epochs,n.verbose,I,x,f,n.shuffle,v,n.initialEpoch,null,null)}finally{this.isTraining=!1,vr(r,e),vr(a,t),vr(s,e),vr(i,t),vr(u,o),vr(p,l),h!=null&&Ce(h)}}async fitLoop(e,t,n,r,a,s,i,o,l,u,p,h,d,c){r==null&&(r=32),a==null&&(a=1),u==null&&(u=!0),h==null&&(h=0);let m=!1;if(o!=null&&l!=null&&(m=!0),c!=null&&(m=!0,d==null))throw new V("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let f=this.checkNumSamples(t,r,d,"steps_per_epoch"),g;f!=null&&(g=Cr(0,f)),s==null&&(s=1);let{callbackList:y,history:b}=tT(i,s,a,h,f,d,r,m,p);y.setModel(this),this.history=b,await y.onTrainBegin(),this.stopTraining_=!1;for(let x=h;x<a;++x){await y.onEpochBegin(x);let v={};if(d!=null)throw new ze("stepsPerEpoch mode is not implemented yet.");{if(u==="batch")throw new ze("batch shuffling is not implemneted yet");u&&w.shuffle(g);let I=Qe(g),N=sb(f,r);for(let C=0;C<N.length;++C){let E={};if(await y.onBatchBegin(C,E),B(()=>{let A=N[C][0],R=N[C][1],F=Ps(I,A,R-A);E.batch=C,E.size=R-A;let S=Pb(t,F),M=e(S);for(let W=0;W<n.length;++W){let U=n[W],H=M[W];E[U]=H,zt(H)}if(C===N.length-1&&m){let W=this.testLoop(o,l,r);for(let U=0;U<n.length;++U){let H=n[U],q=W[U];zt(q),v["val_"+H]=q}}}),await y.onBatchEnd(C,E),Z2(E),this.stopTraining_)break}I.dispose()}if(await y.onEpochEnd(x,v),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return DH(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),r=n[0],a=n[1],s=this.makeTrainFunction()(r.concat(a)),i=[];for(let o of s){let l=await o.data();i.push(l[0])}return Ce(s),vr(n[0],e),vr(n[1],t),_n(i)}getNamedWeights(e){let t=[],n=e!=null&&e.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let s=0;s<r.length;++s)n&&!r[s].trainable||t.push({name:r[s].originalName,tensor:a[s]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let t=rc().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-rc().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=sa(this.loss);else if(Array.isArray(this.loss)){for(let t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>sa(t))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let r of t)if(typeof n[r]=="string")e[r]=sa(n[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[sa(Eh(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>sa(Eh(e)));{let e={};for(let t in this.metrics)e[t]=sa(Eh(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let t=Dp(e.optimizer_config),n=Nr(t),r;if(typeof e.loss=="string")r=Fs(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(s=>Fs(s));else if(e.loss!=null){r={};for(let s in e.loss)r[s]=Fs(e.loss[s])}let a;if(Array.isArray(e.metrics))a=e.metrics.map(s=>Fs(s));else if(e.metrics!=null){a={};for(let s in e.metrics)a[s]=Fs(e.metrics[s])}this.compile({loss:r,metrics:a,optimizer:n})}async save(e,t){if(typeof e=="string"){let a=an.getSaveHandlers(e);if(a.length===0)throw new V(`Cannot find any save handlers for URL '${e}'`);if(a.length>1)throw new V(`Found more than one (${a.length}) save handlers for URL '${e}'`);e=a[0]}if(e.save==null)throw new V("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await an.encodeWeights(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:VH,generatedBy:`TensorFlow.js tfjs-layers v${kw}`,convertedBy:null};if(t!=null&&t.includeOptimizer&&this.optimizer!=null){r.trainingConfig=this.getTrainingConfig();let a="optimizer",{data:s,specs:i}=await an.encodeWeights(await this.optimizer.getWeights(),a);n.specs.push(...i),n.data=an.concatenateArrayBuffers([n.data,s])}return this.userDefinedMetadata!=null&&(Hk(this.userDefinedMetadata,this.name,!0),r.userDefinedMetadata=this.userDefinedMetadata),r.weightData=n.data,r.weightSpecs=n.specs,e.save(r)}setUserDefinedMetadata(e){Hk(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};pa.className="Model";ne.registerClass(pa);var hT=class extends pa{};hT.className="Functional";ne.registerClass(hT);async function UH(e,t){"modelTopology"in e||(e={modelTopology:e}),e=e;let n=e.modelTopology;n.model_config!=null&&(n=n.model_config);let r=Dp(n),a=Nr(r,t);if(e.weightsManifest!=null){let s=await an.loadWeights(e.weightsManifest,e.pathPrefix,a.weights.map(o=>o.originalName)),i={};for(let o of a.weights)i[o.originalName]=s[o.originalName];a.loadWeights(i),Ce(s)}return a}async function GH(e,t){if(t==null&&(t={}),typeof e=="string"){let n=an.getLoadHandlers(e,t);if(n.length===0)n.push(an.browserHTTPRequest(e,t));else if(n.length>1)throw new V(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return HH(e,void 0,t)}async function HH(e,t,n){if(n==null&&(n={}),e.load==null)throw new V("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let r=await e.load(),a=r.modelTopology;a.model_config!=null&&(a=a.model_config);let s=n.strict==null?!0:n.strict,i=r.weightData!=null&&r.weightSpecs!=null&&s,o=Nr(Dp(a),t,i),l=r.trainingConfig;if(l!=null&&o.loadTrainingConfig(l),r.userDefinedMetadata!=null&&o.setUserDefinedMetadata(r.userDefinedMetadata),r.weightData!=null){if(r.weightSpecs==null)throw new V("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:u,optimizerWeights:p}=jH(r.weightData,r.weightSpecs);o.loadWeights(u,s),o.optimizer!=null&&p.length>0&&await o.optimizer.setWeights(p),Ce(u),Ce(p.map(h=>h.tensor))}return o}function jH(e,t){let n=an.decodeWeights(e,t),r={},a=[];return t.forEach(s=>{s.group==="optimizer"?a.push({name:s.name,tensor:n[s.name]}):r[s.name]=n[s.name]}),{modelWeights:r,optimizerWeights:a}}var zm=class Wb extends pa{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:Tm("sequential_"),t.layers!=null)for(let n of t.layers)this.add(n)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new V(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let n=t instanceof Wb||t instanceof pa,r;if(n){if(r=t,r.outputs.length!==1)throw new V("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(r.inputs.length!==1)throw new V("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new V("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let a=H2({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(a)}if(n)this.outputs=r.outputs,this.inputs=r.inputs;else{if(t.inboundNodes.length!==1)throw new V(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new V("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=G2(this.outputs[0])}this.inboundNodes=[],new Mm({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Ys(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(a=>a.shape),outputShapes:this.outputs[0].shape})}else{let a=t.apply(this.outputs[0]);if(Array.isArray(a))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[a],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,n){return this.model==null&&this.build(),this.model.call(t,n)}build(t){if(Ke(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new pa({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,n,r=console.log){this.built||this.build(),super.summary(t,n,r)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,n,r={}){if(!this.built)throw new Wr("The model needs to be compiled before being used.");return this.model.evaluate(t,n,r)}async evaluateDataset(t,n){if(!this.built)throw new Wr("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,n)}predict(t,n={}){return this.model==null&&this.build(),this.model.predict(t,n)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,n,r={}){if(!this.built)throw new Wr("The model needs to be compiled before being used.");return this.model.fit(t,n,r)}async fitDataset(t,n){if(!this.built)throw new Wr("The model needs to be compiled before being used.");return this.model.fitDataset(t,n)}async trainOnBatch(t,n){return this.model.trainOnBatch(t,n)}static fromConfig(t,n,r={},a=!1){let s,i={};if(n instanceof Array){if(n[0].className==null||n[0].className==="Merge")throw new V("Legacy serialization format not supported yet.");s=n}else w.assert(n.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=n.layers,delete n.layers,i=n;let o=new t(i);if(!(o instanceof Wb))throw new ze(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(let l of s){let u=Nr(l,void 0,a);a&&u.setFastWeightInitDuringBuild(!0),o.add(u)}return o}set stopTraining(t){if(this.model==null)throw new V("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new V("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let t=[];for(let n of this.layers){let r={};r.className=n.getClassName(),r.config=n.getConfig(),t.push(r)}return{name:this.name,layers:t}}};zm.className="Sequential";ne.registerClass(zm);function qH(e){return new pa(e)}function KH(e){return new zm(e)}function cT(e){return H2(e)}function XH(e,t){yw.registerCallbackConstructor(e,t)}var hn=class extends ne.Serializable{getConfig(){return{}}},mT=class extends hn{apply(e,t=1){return mG(e,t)}};mT.className="elu";ne.registerClass(mT);var fT=class extends hn{apply(e){return um(e)}};fT.className="selu";ne.registerClass(fT);var gT=class extends hn{apply(e){return nt(e)}};gT.className="relu";ne.registerClass(gT);var yT=class extends hn{apply(e){return B(()=>Ja(6,nt(e)))}};yT.className="relu6";ne.registerClass(yT);var bT=class extends hn{apply(e){return e}};bT.className="linear";ne.registerClass(bT);var xT=class extends hn{apply(e){return fr(e)}};xT.className="sigmoid";ne.registerClass(xT);var vT=class extends hn{apply(e){return gG(e)}};vT.className="hardSigmoid";ne.registerClass(vT);var wT=class extends hn{apply(e){return _o(e)}};wT.className="softplus";ne.registerClass(wT);var kT=class extends hn{apply(e){return fG(e)}};kT.className="softsign";ne.registerClass(kT);var IT=class extends hn{apply(e){return Za(e)}};IT.className="tanh";ne.registerClass(IT);var Iw=class extends hn{apply(e,t=-1){return cs(e,t)}};Iw.className="softmax";ne.registerClass(Iw);var ST=class extends hn{apply(e,t=-1){return nm(e,t)}};ST.className="logSoftmax";ne.registerClass(ST);var NT=class extends hn{apply(e){return B(()=>B(()=>{let t=Math.sqrt(2),n=z(.5,Z(1,Qc(ce(e,t))));return z(e,n)}))}};NT.className="gelu";ne.registerClass(NT);var TT=class extends hn{apply(e){return B(()=>z(.5,z(e,Z(1,Za(z(Yt(ce(2,Math.PI)),Z(e,z(.044715,qr(e,3)))))))))}};TT.className="gelu_new";ne.registerClass(TT);var CT=class extends hn{apply(e){return B(()=>z(e,Za(_o(e))))}};CT.className="mish";ne.registerClass(CT);var _T=class extends hn{apply(e,t=1){return B(()=>z(fr(z(e,t)),e))}};_T.className="swish";ne.registerClass(_T);function es(e){return e.getClassName()}function ib(e,t={}){return Dd(e,ne.SerializationMap.getMap().classNameMap,t,"activation")}function ts(e){if(e==null){let t={};return t.className="linear",t.config={},ib(t)}if(typeof e=="string"){let t={};return t.className=e,t.config={},ib(t)}else return e instanceof hn?e:ib(e)}function Sw(e){if(e!=null&&typeof e!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}var ET=class extends ne.Serializable{},Pd=class extends ET{constructor(e){super(),Sw(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return B(()=>{let t=It([1]);return this.hasL1&&(t=Z(t,fe(z(this.l1,At(e))))),this.hasL2&&(t=Z(t,fe(z(this.l2,Od(e))))),P(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};Pd.className="L1L2";ne.registerClass(Pd);function ZH(e){return Sw(e),new Pd({l1:e!=null?e.l1:null,l2:0})}function JH(e){return Sw(e),new Pd({l2:e!=null?e.l2:null,l1:0})}var Jk={l1l2:"L1L2"};function dt(e){return tw(e)}function Yk(e,t={}){return Dd(e,ne.SerializationMap.getMap().classNameMap,t,"regularizer")}function vt(e){if(e==null)return null;if(typeof e=="string"){let t={className:e in Jk?Jk[e]:e,config:{}};return Yk(t)}else return e instanceof ET?e:Yk(e)}var Nw=class extends Pe{constructor(e){super(e==null?{}:e),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Te(e);let n=nt(e);return this.maxValue!=null&&(n=un(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};Nw.className="ReLU";ne.registerClass(Nw);var Tw=class extends Pe{constructor(e){super(e==null?{}:e),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Te(e);return Id(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};Tw.className="LeakyReLU";ne.registerClass(Tw);var Cw=class extends Pe{constructor(e){if(super(e==null?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=xt(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=vt(e.alphaRegularizer),this.alphaConstraint=Vt(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new V(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=Ke(e);let t=e.slice(1);if(this.sharedAxes!=null)for(let r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new Ft({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Te(e),Ed(e,this.alpha.read())}getConfig(){let e={alphaInitializer:St(this.alphaInitializer),alphaRegularizer:dt(this.alphaRegularizer),alphaConstraint:Wt(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};Cw.className="PReLU";ne.registerClass(Cw);var _w=class extends Pe{constructor(e){if(super(e==null?{}:e),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new ze(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Te(e);return Cu(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};_w.className="ELU";ne.registerClass(_w);var Ew=class extends Pe{constructor(e){super(e==null?{}:e),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){let n=Te(e);return z(n,oe(kn(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};Ew.className="ThresholdedReLU";ne.registerClass(Ew);var $w=class extends Pe{constructor(e){super(e==null?{}:e),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new Iw().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return B(()=>{let n=Te(e),r=t.mask;if(r!=null){let a=z(he(En(n.shape),oe(r,n.dtype)),ve(-1e9));n=Z(n,a)}return this.axis instanceof Array?this.axis.length>1?pn(he(n,Nd(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)})}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};$w.className="Softmax";ne.registerClass($w);function rl(e,t,n){if(typeof e=="number")return Ys(e,t);if(e.length!==t)throw new V(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){let a=e[r];if(!pG(a))throw new V(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)}return e}function Tr(e,t,n,r,a=1){if(e==null)return e;let s=t+(t-1)*(a-1),i;return n==="same"?i=e:i=e-s+1,Math.floor((i+r-1)/r)}function Br(e,t,n,r){if(e==null)return null;if(r==="valid")e=e*t+Qa([n-t,0]);else if(r==="same")e=e*t;else throw new V(`Unsupport padding mode: ${r}.`);return e}function Aw(e,t){return B(()=>(Ct(t),t==="channelsFirst"?Me(e,[0,2,3,1]):e))}function $T(e,t){return B(()=>(Ct(t),t==="channelsFirst"?Me(e,[0,2,3,4,1]):e))}function YH(e,t,n,r=1,a="valid",s,i=1){return B(()=>{if(s==null&&(s=_r()),Ct(s),e.shape.length!==3)throw new V(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(t.shape.length!==3)throw new V(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new V(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if(s==="channelsFirst"&&(e=Me(e,[0,2,1])),a==="causal")throw new ze("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=Xc(e,t,r,a==="same"?"same":"valid","NWC",i);return n!=null&&(o=Fr(o,n)),o})}function Qk(e,t,n,r=[1,1],a="valid",s,i,o=null){return B(()=>{if(s==null&&(s=_r()),Ct(s),e.rank!==3&&e.rank!==4)throw new V(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(t.rank!==3&&t.rank!==4)throw new V(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=Aw(e,s);if(a==="causal")throw new ze("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=ml.conv2d({x:l,filter:t,strides:r,pad:a==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),s==="channelsFirst"&&(l=Me(l,[0,3,1,2])),l})}function QH(e,t,n,r=[1,1,1],a="valid",s,i){return B(()=>{if(s==null&&(s=_r()),Ct(s),e.rank!==4&&e.rank!==5)throw new V(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(t.rank!==4&&t.rank!==5)throw new V(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=$T(e,s);if(a==="causal")throw new ze("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=sv(o,t,r,a==="same"?"same":"valid","NDHWC",i),n!=null&&(o=Fr(o,n)),s==="channelsFirst"&&(o=Me(o,[0,4,1,2,3])),o})}var AT=class FT extends Pe{constructor(t,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",FT.verifyArgs(n),this.rank=t,Zt(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new ze(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=rl(n.kernelSize,t,"kernelSize"),this.strides=rl(n.strides==null?1:n.strides,t,"strides"),this.padding=n.padding==null?"valid":n.padding,ur(this.padding),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,Ct(this.dataFormat),this.activation=ts(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=xt(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Vt(n.biasConstraint),this.biasRegularizer=vt(n.biasRegularizer),this.activityRegularizer=vt(n.activityRegularizer),this.dilationRate=rl(n.dilationRate==null?1:n.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new V(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new V(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new V(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(Pr("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!nw(t.kernelSize,"number",1,3))throw new V(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){let t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:es(this.activation),useBias:this.useBias,biasInitializer:St(this.biasInitializer),biasRegularizer:dt(this.biasRegularizer),activityRegularizer:dt(this.activityRegularizer),biasConstraint:Wt(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}},Pm=class RT extends AT{constructor(t,n){super(t,n),this.kernel=null,RT.verifyArgs(n),this.filters=n.filters,Zt(this.filters,"filters"),this.kernelInitializer=xt(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Vt(n.kernelConstraint),this.kernelRegularizer=vt(n.kernelRegularizer)}build(t){t=Ke(t);let n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new V(`The channel dimension of the input should be defined. Found ${t[n]}`);let r=t[n],a=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:r}}],this.built=!0}call(t,n){return B(()=>{t=Te(t);let r,a=this.bias==null?null:this.bias.read(),s=M2(this.activation.getClassName());if(s!=null&&this.rank===2)r=Qk(t,this.kernel.read(),a,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)r=YH(t,this.kernel.read(),a,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)r=Qk(t,this.kernel.read(),a,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)r=QH(t,this.kernel.read(),a,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new ze("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(r=this.activation.apply(r))}return r})}computeOutputShape(t){t=Ke(t);let n=[],r=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let s=0;s<r.length;++s){let i=Tr(r[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);n.push(i)}let a=[t[0]];return this.dataFormat==="channelsLast"?(a=a.concat(n),a.push(this.filters)):(a.push(this.filters),a=a.concat(n)),a}getConfig(){let t={filters:this.filters,kernelInitializer:St(this.kernelInitializer),kernelRegularizer:dt(this.kernelRegularizer),kernelConstraint:Wt(this.kernelConstraint)},n=super.getConfig();return Object.assign(t,n),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new V(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}},Bm=class DT extends Pm{constructor(t){super(2,t),DT.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!nw(t.kernelSize,"number",1,2))throw new V(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}};Bm.className="Conv2D";ne.registerClass(Bm);var Wm=class MT extends Pm{constructor(t){super(3,t),MT.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new V(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}};Wm.className="Conv3D";ne.registerClass(Wm);var Fw=class extends Bm{constructor(e){if(super(e),this.inputSpec=[new Ft({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new V(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Ke(e),e.length!==4)throw new V("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new V("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ft({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return B(()=>{let n=Te(e);if(n.shape.length!==4)throw new V(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let r=n.shape,a=r[0],s,i;this.dataFormat==="channelsFirst"?(s=2,i=3):(s=1,i=2);let o=r[s],l=r[i],u=this.kernelSize[0],p=this.kernelSize[1],h=this.strides[0],d=this.strides[1],c=Br(o,h,u,this.padding),m=Br(l,d,p,this.padding),f=[a,c,m,this.filters];this.dataFormat!=="channelsLast"&&(n=Me(n,[0,2,3,1]));let g=Zc(n,this.kernel.read(),f,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(g=Me(g,[0,3,1,2])),this.bias!=null&&(g=Fr(g,this.bias.read(),this.dataFormat)),this.activation!=null&&(g=this.activation.apply(g)),g})}computeOutputShape(e){e=Ke(e);let t=e.slice(),n,r,a;this.dataFormat==="channelsFirst"?(n=1,r=2,a=3):(n=3,r=1,a=2);let s=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[r]=Br(t[r],o,s,this.padding),t[a]=Br(t[a],l,i,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};Fw.className="Conv2DTranspose";ne.registerClass(Fw);var Rw=class extends Wm{constructor(e){if(super(e),this.inputSpec=[new Ft({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new V(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Ke(e),e.length!==5)throw new V("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new V("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ft({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return B(()=>{let n=Te(e);if(n.shape.length!==5)throw new V(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let r=n.shape,a=r[0],s,i,o;this.dataFormat==="channelsFirst"?(o=2,s=3,i=4):(o=1,s=2,i=3);let l=r[o],u=r[s],p=r[i],h=this.kernelSize[0],d=this.kernelSize[1],c=this.kernelSize[2],m=this.strides[0],f=this.strides[1],g=this.strides[2],y=Br(l,m,h,this.padding),b=Br(u,f,d,this.padding),x=Br(p,g,c,this.padding),v=[a,y,b,x,this.filters];this.dataFormat!=="channelsLast"&&(n=Me(n,[0,2,3,4,1]));let I=iv(n,this.kernel.read(),v,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(I=Me(I,[0,4,1,2,3])),this.bias!==null&&(I=Fr(I,this.bias.read(),this.dataFormat)),this.activation!==null&&(I=this.activation.apply(I)),I})}computeOutputShape(e){e=Ke(e);let t=e.slice(),n,r,a,s;this.dataFormat==="channelsFirst"?(n=1,r=2,a=3,s=4):(n=4,r=1,a=2,s=3);let i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],p=this.strides[1],h=this.strides[2];return t[n]=this.filters,t[r]=Br(t[r],u,i,this.padding),t[a]=Br(t[a],p,o,this.padding),t[s]=Br(t[s],h,l,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};Rw.className="Conv3DTranspose";ne.registerClass(Rw);var OT=class extends Pm{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new V("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new V("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new V(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=xt(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=vt(t.depthwiseRegularizer),this.depthwiseConstraint=Vt(t.depthwiseConstraint),this.pointwiseInitializer=xt(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=vt(t.pointwiseRegularizer),this.pointwiseConstraint=Vt(t.pointwiseConstraint)}build(e){if(e=Ke(e),e.length<this.rank+2)throw new V(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new V(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),a=[];for(let i=0;i<this.rank;++i)a.push(1);a.push(n*this.depthMultiplier,this.filters);let s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new Ft({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return B(()=>{e=Te(e);let n;if(this.rank===1)throw new ze("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Me(e,[0,2,3,1])),n=Au(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=Fr(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=Me(n,[0,3,1,2])),n})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=St(this.depthwiseInitializer),e.pointwiseInitializer=St(this.pointwiseInitializer),e.depthwiseRegularizer=dt(this.depthwiseRegularizer),e.pointwiseRegularizer=dt(this.pointwiseRegularizer),e.depthwiseConstraint=Wt(this.depthwiseConstraint),e.pointwiseConstraint=Wt(this.pointwiseConstraint),e}};OT.className="SeparableConv";var Dw=class extends OT{constructor(e){super(2,e)}};Dw.className="SeparableConv2D";ne.registerClass(Dw);var Mw=class LT extends Pm{constructor(t){super(1,t),LT.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!nw(t.kernelSize,"number",1,1))throw new V(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}};Mw.className="Conv1D";ne.registerClass(Mw);var Ow=class extends Pe{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return B(()=>{if(e=Te(e),this.dataFormat==="channelsLast"){let n=_h(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return _h(n,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=_h(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return _h(n,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};Ow.className="Cropping2D";ne.registerClass(Ow);var Lw=class extends Pe{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ct(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,oG(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){let t=e[2]==null?null:this.size[0]*e[2],n=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,n]}else{let t=e[1]==null?null:this.size[0]*e[1],n=e[2]==null?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return B(()=>{let n=Te(e),r=n.shape;if(this.dataFormat==="channelsFirst"){n=Me(n,[0,2,3,1]);let a=this.size[0]*r[2],s=this.size[1]*r[3],i=this.interpolation==="nearest"?er.resizeNearestNeighbor(n,[a,s]):er.resizeBilinear(n,[a,s]);return Me(i,[0,3,1,2])}else{let a=this.size[0]*r[1],s=this.size[1]*r[2];return this.interpolation==="nearest"?er.resizeNearestNeighbor(n,[a,s]):er.resizeBilinear(n,[a,s])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};Lw.className="UpSampling2D";ne.registerClass(Lw);function e6(e,t,n=[1,1],r="valid",a,s){return B(()=>{a==null&&(a=_r()),Ct(a);let i=Aw(e,a);if(e.rank!==4)throw new V(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(t.rank!==4)throw new V(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=Co(i,t,n,r==="same"?"same":"valid","NHWC",s),a==="channelsFirst"&&(i=Me(i,[0,3,1,2])),i})}var zw=class extends AT{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=xt(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Vt(e.depthwiseConstraint),this.depthwiseRegularizer=vt(e.depthwiseRegularizer)}build(e){if(e=Ke(e),e.length<4)throw new V(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new V(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return B(()=>{e=Te(e);let n=e6(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=Fr(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(e){e=Ke(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=Tr(t,this.kernelSize[0],this.padding,this.strides[0]),s=Tr(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,a,s]:[e[0],a,s,r]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=St(this.depthwiseInitializer),e.depthwiseRegularizer=dt(this.depthwiseRegularizer),e.depthwiseConstraint=Wt(this.depthwiseRegularizer),e}};zw.className="DepthwiseConv2D";ne.registerClass(zw);function zT(e,t,n,r){if(Array.isArray(e)){if(t!=null||n!=null)throw new V("When inputs is an array, neither initialState or constants should be provided");r!=null&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function a(s){return s==null||Array.isArray(s)?s:[s]}return t=a(t),n=a(n),{inputs:e,initialState:t,constants:n}}function PT(e,t,n,r=!1,a,s,i=!1,o=!1){return B(()=>{let l=t.shape.length;if(l<3)throw new V(`Input should be at least 3D, but is ${l}D.`);let u=[1,0].concat(Cr(2,l));if(t=Me(t,u),s!=null)throw new ze("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),a!=null&&(a=oe(oe(a,"bool"),"float32"),a.rank===l-1&&(a=Xt(a,-1)),a=Me(a,u)),r&&(t=or(t,0),a!=null&&(a=or(a,0)));let p=[],h,d=n,c=t.shape[0],m=Tt(t),f;a!=null&&(f=Tt(a));for(let y=0;y<c;++y){let b=m[y],x=B(()=>e(b,d));if(a==null)h=x[0],d=x[1];else{let v=B(()=>{let I=f[y],N=he(jn(I),I),C=Z(z(x[0],I),z(d[0],N)),E=d.map((A,R)=>Z(z(x[1][R],I),z(A,N)));return{output:C,newStates:E}});h=v.output,d=v.newStates}o&&p.push(h)}let g;return o&&(g=Dt(p,1)),[h,g,d]})}var wa=class BT extends Pe{constructor(t){super(t);let n;if(t.cell==null)throw new V("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?n=new Gm({cells:t.cell}):n=t.cell,n.stateSize==null)throw new V("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new Ft({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Cr(0,t).map(n=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){Mb(t)&&(t=t[0]),t=t;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);let r=n[0],a;if(this.returnSequences?a=[t[0],t[1],r]:a=[t[0],r],this.returnState){let s=[];for(let i of n)s.push([t[0],i]);return[a].concat(s)}else return a}computeMask(t,n){return B(()=>{Array.isArray(n)&&(n=n[0]);let r=this.returnSequences?n:null;if(this.returnState){let a=this.states.map(s=>null);return[r].concat(a)}else return r})}get states(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let r=0;r<t;++r)n.push(null);return n}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new ze("Constants support is not implemented in RNN yet.");Mb(t)&&(t=t[0]),t=t;let n=this.stateful?t[0]:null,r=t.slice(2);this.inputSpec[0]=new Ft({shape:[n,null,...r]});let a=[t[0]].concat(t.slice(2));this.cell.build(a);let s;if(Array.isArray(this.cell.stateSize)?s=this.cell.stateSize:s=[this.cell.stateSize],this.stateSpec!=null){if(!w.arraysEqual(this.stateSpec.map(i=>i.shape[i.shape.length-1]),s))throw new V(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map(i=>new Ft({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(t,n=!1){B(()=>{if(!this.stateful)throw new Ra("Cannot call resetStates() on an RNN Layer that is not stateful.");let r=this.inputSpec[0].shape[0];if(r==null)throw new V("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(a=>It([r,a])):this.states_=[It([r,this.cell.stateSize])];else if(t==null)Ce(this.states_),this.keptStates!=null&&(Ce(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(a=>It([r,a])):this.states_[0]=It([r,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new V(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);n===!0?this.keptStates.push(this.states_.slice()):Ce(this.states_);for(let a=0;a<this.states_.length;++a){let s=t[a],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[a]:this.cell.stateSize,o=[r,i];if(!w.arraysEqual(s.shape,o))throw new V(`State ${a} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${s.shape}`);this.states_[a]=s}}this.states_=this.states_.map(a=>zt(a.clone()))})}apply(t,n){let r=n==null?null:n.initialState,a=n==null?null:n.constants;n==null&&(n={});let s=zT(t,r,a,this.numConstants);t=s.inputs,r=s.initialState,a=s.constants;let i=[],o=[];if(r!=null){n.initialState=r,i=i.concat(r),this.stateSpec=[];for(let l of r)this.stateSpec.push(new Ft({shape:l.shape}));o=o.concat(this.stateSpec)}if(a!=null&&(n.constants=a,i=i.concat(a),this.numConstants=a.length),i[0]instanceof Er){let l=[t].concat(i),u=this.inputSpec.concat(o),p=this.inputSpec;this.inputSpec=u;let h=super.apply(l,n);return this.inputSpec=p,h}else return super.apply(t,n)}call(t,n){return B(()=>{let r=n==null?null:n.mask,a=n==null?null:n.training,s=n==null?null:n.initialState;t=Te(t),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(t));let i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==i)throw new V(`RNN Layer has ${i} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let o={training:a},l=PT((c,m)=>{let f=this.cell.call([c].concat(m),o);return[f[0],f.slice(1)]},t,s,this.goBackwards,r,null,this.unroll,this.returnSequences),u=l[0],p=l[1],h=l[2];this.stateful&&this.resetStates(h,a);let d=this.returnSequences?p:u;return this.returnState?[d].concat(h):d})}getInitialState(t){return B(()=>{let n=It(t.shape);return n=fe(n,[1,2]),n=Md(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(r=>r>1?Rb(n,[1,r]):n):this.cell.stateSize>1?[Rb(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){let t=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);let r=this.cell.getConfig();return this.getClassName()===BT.className&&(n.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),t),n)}static fromConfig(t,n,r={}){let a=n.cell,s=Nr(a,r);return new t(Object.assign(n,{cell:s}))}};wa.className="RNN";ne.registerClass(wa);var Bd=class extends Pe{},Vm=class extends Bd{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Zt(this.units,"units"),this.activation=ts(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=xt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=xt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=xt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=vt(e.kernelRegularizer),this.recurrentRegularizer=vt(e.recurrentRegularizer),this.biasRegularizer=vt(e.biasRegularizer),this.kernelConstraint=Vt(e.kernelConstraint),this.recurrentConstraint=Vt(e.recurrentConstraint),this.biasConstraint=Vt(e.biasConstraint),this.dropout=fl([1,Qa([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=fl([1,Qa([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Ke(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return B(()=>{if(e=e,e.length!==2)throw new V(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let r=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ns({ones:()=>jn(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ns({ones:()=>jn(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let a,s=this.dropoutMask,i=this.recurrentDropoutMask;s!=null?a=Hr(z(e,s),this.kernel.read()):a=Hr(e,this.kernel.read()),this.bias!=null&&(a=Fr(a,this.bias.read())),i!=null&&(n=z(n,i));let o=Z(a,Hr(n,this.recurrentKernel.read()));return this.activation!=null&&(o=this.activation.apply(o)),[o,o]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:es(this.activation),useBias:this.useBias,kernelInitializer:St(this.kernelInitializer),recurrentInitializer:St(this.recurrentInitializer),biasInitializer:St(this.biasInitializer),kernelRegularizer:dt(this.kernelRegularizer),recurrentRegularizer:dt(this.recurrentRegularizer),biasRegularizer:dt(this.biasRegularizer),activityRegularizer:dt(this.activityRegularizer),kernelConstraint:Wt(this.kernelConstraint),recurrentConstraint:Wt(this.recurrentConstraint),biasConstraint:Wt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}};Vm.className="SimpleRNNCell";ne.registerClass(Vm);var Pw=class extends wa{constructor(e){e.cell=new Vm(e),super(e)}call(e,t){return B(()=>{this.cell.dropoutMask!=null&&(Ce(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ce(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})})}static fromConfig(e,t){return new e(t)}};Pw.className="SimpleRNN";ne.registerClass(Pw);var Um=class extends Bd{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new V("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Zt(this.units,"units"),this.activation=ts(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=ts(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=xt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=xt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=xt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=vt(e.kernelRegularizer),this.recurrentRegularizer=vt(e.recurrentRegularizer),this.biasRegularizer=vt(e.biasRegularizer),this.kernelConstraint=Vt(e.kernelConstraint),this.recurrentConstraint=Vt(e.recurrentConstraint),this.biasConstraint=Vt(e.biasConstraint),this.dropout=fl([1,Qa([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=fl([1,Qa([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Ke(e);let t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return B(()=>{if(e=e,e.length!==2)throw new V(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training==null?!1:t.training,r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ns({ones:()=>jn(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ns({ones:()=>jn(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let a=this.dropoutMask,s=this.recurrentDropoutMask,i,o,l;0<this.dropout&&this.dropout<1&&(e=z(e,a[0]));let u=Hr(e,this.kernel.read());this.useBias&&(u=Fr(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=z(r,s[0]));let p=this.recurrentKernel.read(),[h,d]=$n(p,[2*this.units,this.units],p.rank-1),c=Hr(r,h),[m,f,g]=$n(u,3,u.rank-1),[y,b]=$n(c,2,c.rank-1);i=this.recurrentActivation.apply(Z(m,y)),o=this.recurrentActivation.apply(Z(f,b));let x=Hr(z(o,r),d);l=this.activation.apply(Z(g,x));let v=Z(z(i,r),z(Z(1,ft(i)),l));return[v,v]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:es(this.activation),recurrentActivation:es(this.recurrentActivation),useBias:this.useBias,kernelInitializer:St(this.kernelInitializer),recurrentInitializer:St(this.recurrentInitializer),biasInitializer:St(this.biasInitializer),kernelRegularizer:dt(this.kernelRegularizer),recurrentRegularizer:dt(this.recurrentRegularizer),biasRegularizer:dt(this.biasRegularizer),activityRegularizer:dt(this.activityRegularizer),kernelConstraint:Wt(this.kernelConstraint),recurrentConstraint:Wt(this.recurrentConstraint),biasConstraint:Wt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}};Um.className="GRUCell";ne.registerClass(Um);var Bw=class extends wa{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Um(e),super(e)}call(e,t){return B(()=>{this.cell.dropoutMask!=null&&(Ce(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ce(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};Bw.className="GRU";ne.registerClass(Bw);var Wd=class extends Bd{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Zt(this.units,"units"),this.activation=ts(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=ts(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=xt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=xt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=xt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=vt(e.kernelRegularizer),this.recurrentRegularizer=vt(e.recurrentRegularizer),this.biasRegularizer=vt(e.biasRegularizer),this.kernelConstraint=Vt(e.kernelConstraint),this.recurrentConstraint=Vt(e.recurrentConstraint),this.biasConstraint=Vt(e.biasConstraint),this.dropout=fl([1,Qa([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=fl([1,Qa([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=Ke(e);let n=e[e.length-1];this.kernel=this.addWeight("kernel",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){let a=this.biasInitializer,s=this.units;r=new(t=class extends br{apply(i,o){let l=a.apply([s]),u=new _m().apply([s]),p=a.apply([s*2]);return Lk(Lk(l,u),p)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return B(()=>{let n=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new V(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1],a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ns({ones:()=>jn(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ns({ones:()=>jn(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,i=this.recurrentDropoutMask,o,l,u,p;0<this.dropout&&this.dropout<1&&(e=z(e,s[0]));let h=Hr(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=z(r,i[0])),h=Z(h,Hr(r,this.recurrentKernel.read())),this.useBias&&(h=Fr(h,this.bias.read()));let[d,c,m,f]=$n(h,4,h.rank-1);o=this.recurrentActivation.apply(d),l=this.recurrentActivation.apply(c),u=Z(z(l,a),z(o,this.activation.apply(m))),p=this.recurrentActivation.apply(f);let g=z(p,this.activation.apply(u));return[g,g,u]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:es(this.activation),recurrentActivation:es(this.recurrentActivation),useBias:this.useBias,kernelInitializer:St(this.kernelInitializer),recurrentInitializer:St(this.recurrentInitializer),biasInitializer:St(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:dt(this.kernelRegularizer),recurrentRegularizer:dt(this.recurrentRegularizer),biasRegularizer:dt(this.biasRegularizer),activityRegularizer:dt(this.activityRegularizer),kernelConstraint:Wt(this.kernelConstraint),recurrentConstraint:Wt(this.recurrentConstraint),biasConstraint:Wt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}};Wd.className="LSTMCell";ne.registerClass(Wd);var Ww=class extends wa{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Wd(e),super(e)}call(e,t){return B(()=>{this.cell.dropoutMask!=null&&(Ce(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ce(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};Ww.className="LSTM";ne.registerClass(Ww);var Gm=class extends Bd{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return B(()=>{e=e;let n=e.slice(1),r=[];for(let i of this.cells.slice().reverse())Array.isArray(i.stateSize)?r.push(n.splice(0,i.stateSize.length)):r.push(n.splice(0,1));r.reverse();let a=[],s;for(let i=0;i<this.cells.length;++i){let o=this.cells[i];n=r[i],i===0?s=[e[0]].concat(n):s=[s[0]].concat(n),s=o.call(s,t),a.push(s.slice(1))}n=[];for(let i of a.slice().reverse())n.push(...i);return[s[0]].concat(n)})}build(e){Mb(e)&&(e=e[0]),e=e;let t;this.cells.forEach((n,r)=>{zs(`RNNCell_${r}`,()=>{n.build(e),Array.isArray(n.stateSize)?t=n.stateSize[0]:t=n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){let e=super.getConfig(),t=r=>({className:r.getClassName(),config:r.getConfig()}),n={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),n)}static fromConfig(e,t,n={}){let r=[];for(let a of t.cells)r.push(Nr(a,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.cells)t.push(...n.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return Ob(e)}setWeights(e){let t=[];for(let n of this.cells){let r=n.weights.length,a=e.splice(r);for(let s=0;s<n.weights.length;++s)t.push([n.weights[s],a[s]])}dw(t)}};Gm.className="StackedRNNCells";ne.registerClass(Gm);function ns(e){let{ones:t,rate:n,training:r=!1,count:a=1,dropoutFunc:s}=e,i=()=>s!=null?s(t(),n):V2(t(),n),o=()=>Ld(i,t,r);return!a||a<=1?zt(o().clone()):Array(a).fill(void 0).map(o).map(l=>zt(l.clone()))}var t6=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]]);return n},WT=class extends wa{constructor(e){if(e.unroll)throw new ze("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new ze("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Ft({ndim:5})]}call(e,t){return B(()=>{if(this.cell.dropoutMask!=null&&(Ce(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ce(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new V("ConvRNN2D cell does not support constants");let n=t==null?null:t.mask,r=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return B(()=>{let{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)],s=It(a);return Array.isArray(t)?Array(t.length).fill(s):[s]})}resetStates(e,t=!1){B(()=>{if(!this.stateful)throw new Ra("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(n[0]==null)throw new V("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>It(a)):this.states_=[It(a)];else if(e==null)Ce(this.states_),this.keptStates!=null&&(Ce(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>It(a)):this.states_[0]=It(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new V(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Ce(this.states_);for(let s=0;s<this.states_.length;++s){let i=e[s],o=a;if(!w.arraysEqual(i.shape,o))throw new V(`State ${s} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${i.shape}`);this.states_[s]=i}}this.states_=this.states_.map(s=>zt(s.clone()))})}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:r,padding:a,strides:s,dilationRate:i}=this.cell,o=t==="channelsFirst",l=e[o?3:2],u=e[o?4:3],p=Tr(l,r[0],a,s[0],i[0]),h=Tr(u,r[1],a,s[1],i[1]);return[...e.slice(0,2),...o?[n,p,h]:[p,h,n]]}};WT.className="ConvRNN2D";var Hm=class extends Wd{constructor(e){let{filters:t,kernelSize:n,strides:r,padding:a,dataFormat:s,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,Zt(this.filters,"filters"),this.kernelSize=rl(n,2,"kernelSize"),this.kernelSize.forEach(o=>Zt(o,"kernelSize")),this.strides=rl(r||1,2,"strides"),this.strides.forEach(o=>Zt(o,"strides")),this.padding=a||"valid",ur(this.padding),this.dataFormat=s||"channelsLast",Ct(this.dataFormat),this.dilationRate=rl(i||1,2,"dilationRate"),this.dilationRate.forEach(o=>Zt(o,"dilationRate"))}build(e){var t;e=Ke(e);let n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new V(`The channel dimension of the input should be defined. Found ${e[n]}`);let r=e[n],a=4,s=this.kernelSize.concat([r,this.filters*a]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let i=this.kernelSize.concat([this.filters,this.filters*a]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let o;if(this.unitForgetBias){let l=this.biasInitializer,u=this.filters;o=new(t=class extends br{apply(p,h){let d=l.apply([u]),c=En([u]),m=l.apply([u*2]);return rw([d,c,m])}},t.className="CustomInit",t)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*a],null,o,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return B(()=>{if(e.length!==3)throw new V(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,r=e[0],a=e[1],s=e[2],i=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ns({ones:()=>jn(r),rate:this.dropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let o=this.dropoutMask,l=(J,Y,ee)=>!Y||!Y[ee]?J:z(Y[ee],J),u=l(r,o,0),p=l(r,o,1),h=l(r,o,2),d=l(r,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ns({ones:()=>jn(a),rate:this.recurrentDropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let c=this.recurrentDropoutMask,m=l(a,c,0),f=l(a,c,1),g=l(a,c,2),y=l(a,c,3),b=3,[x,v,I,N]=$n(this.kernel.read(),i,b),[C,E,A,R]=this.useBias?$n(this.bias.read(),i):[null,null,null,null];u=this.inputConv(u,x,C,this.padding),p=this.inputConv(p,v,E,this.padding),h=this.inputConv(h,I,A,this.padding),d=this.inputConv(d,N,R,this.padding);let[F,S,M,W]=$n(this.recurrentKernel.read(),i,b);m=this.recurrentConv(m,F),f=this.recurrentConv(f,S),g=this.recurrentConv(g,M),y=this.recurrentConv(y,W);let U=this.recurrentActivation.apply(Z(u,m)),H=this.recurrentActivation.apply(Z(p,f)),q=Z(z(H,s),z(U,this.activation.apply(Z(h,g)))),K=z(this.recurrentActivation.apply(Z(d,y)),this.activation.apply(q));return[K,K,q]})}getConfig(){let e=super.getConfig(),{units:t}=e,n=t6(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){let a=bn(e,t,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?Fr(a,n,this.dataFormat):a}recurrentConv(e,t){return bn(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};Hm.className="ConvLSTM2DCell";ne.registerClass(Hm);var Vw=class extends WT{constructor(e){let t=new Hm(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}};Vw.className="ConvLSTM2D";ne.registerClass(Vw);var jm=class extends Pe{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(this.noiseShape[r]==null?t[r]:this.noiseShape[r]);return n}call(e,t){return B(()=>{this.invokeCallHook(e,t);let n=Te(e);if(0<this.rate&&this.rate<1){let r=t.training==null?!1:t.training,a=this.getNoiseShape(n);return Ld(()=>V2(n,this.rate,a,this.seed),()=>n,r)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};jm.className="Dropout";ne.registerClass(jm);var Uw=class extends jm{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};Uw.className="SpatialDropout1D";ne.registerClass(Uw);var Gw=class extends Pe{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Zt(this.units,"units"),this.activation=ts(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=xt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=xt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Vt(e.kernelConstraint),this.biasConstraint=Vt(e.biasConstraint),this.kernelRegularizer=vt(e.kernelRegularizer),this.biasRegularizer=vt(e.biasRegularizer),this.activityRegularizer=vt(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=Ke(e);let t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=Ke(e);let t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return B(()=>{this.invokeCallHook(e,t);let n=Te(e),r=M2(this.activation.getClassName()),a;return r!=null?a=Hr(n,this.kernel.read(),r,this.bias?this.bias.read():null):(a=Hr(n,this.kernel.read()),this.bias!=null&&(a=Fr(a,this.bias.read())),this.activation!=null&&(a=this.activation.apply(a))),a})}getConfig(){let e={units:this.units,activation:es(this.activation),useBias:this.useBias,kernelInitializer:St(this.kernelInitializer),biasInitializer:St(this.biasInitializer),kernelRegularizer:dt(this.kernelRegularizer),biasRegularizer:dt(this.biasRegularizer),activityRegularizer:dt(this.activityRegularizer),kernelConstraint:Wt(this.kernelConstraint),biasConstraint:Wt(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};Gw.className="Dense";ne.registerClass(Gw);var Hw=class extends Pe{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Ke(e);for(let t of e.slice(1))if(t==null)throw new V(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Va(e,1)]}call(e,t){return B(()=>{this.invokeCallHook(e,t);let n=Te(e);if(this.dataFormat==="channelsFirst"&&n.rank>1){let r=[0];for(let a=2;a<n.rank;++a)r.push(a);r.push(1),n=Me(n,r)}return cG(n)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};Hw.className="Flatten";ne.registerClass(Hw);var jw=class extends Pe{constructor(e){super(e),this.supportsMasking=!0,this.activation=ts(e.activation)}call(e,t){return B(()=>{this.invokeCallHook(e,t);let n=Te(e);return this.activation.apply(n)})}getConfig(){let e={activation:es(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};jw.className="Activation";ne.registerClass(jw);var qw=class extends Pe{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return B(()=>(e=Te(e),dG(e,this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};qw.className="RepeatVector";ne.registerClass(qw);var Kw=class extends Pe{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",r=t.slice(),a=1,s=null;for(let o=0;o<r.length;++o){let l=r[o];if(this.isUnknown(l))if(s===null)s=o;else throw new V("Can only specifiy one unknown dimension.");else a*=l}let i=Va(e);if(s!==null){if(a===0||i%a!==0)throw new V(n);r[s]=i/a}else if(i!==a)throw new V(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return B(()=>{this.invokeCallHook(e,t);let n=Te(e),r=n.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return P(n,a)})}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};Kw.className="Reshape";ne.registerClass(Kw);var Xw=class extends Pe{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=Cr(1,e.dims.length+1);if(!w.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Ft({ndim:this.dims.length+1})]}computeOutputShape(e){e=Ke(e);let t=e.slice();return this.dims.forEach((n,r)=>{t[r+1]=e[n]}),t}call(e,t){return Me(Te(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};Xw.className="Permute";ne.registerClass(Xw);var Zw=class extends Pe{constructor(e){super(e==null?{}:e),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=Te(e);return Ep(Zs(n,this.maskValue),-1)}call(e,t){return B(()=>{this.invokeCallHook(e,t);let n=Te(e),r=Ep(Zs(n,this.maskValue),-1,!0);return z(n,oe(r,n.dtype))})}};Zw.className="Masking";ne.registerClass(Zw);var Jw=class extends Pe{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(et(e.inputLength))}this.inputDim=e.inputDim,Zt(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Zt(this.outputDim,"outputDim"),this.embeddingsInitializer=xt(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=vt(e.embeddingsRegularizer),this.activityRegularizer=vt(e.activityRegularizer),this.embeddingsConstraint=Vt(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return B(()=>this.maskZero?(e=Te(e),Zs(e,Ge(e))):null)}computeOutputShape(e){if(e=Ke(e),this.inputLength==null)return[...e,this.outputDim];let t=et(this.inputLength);if(t.length!==e.length-1)throw new V(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){let a=t[r],s=e[r+1];if(a!=null&&s!=null&&a!==s)throw new V(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);a==null&&(t[n]=s),n++}}return[e[0],...t,this.outputDim]}call(e,t){return B(()=>{this.invokeCallHook(e,t);let n=Te(e);n.dtype!=="int32"&&(n=ca(n,"int32"));let r=W2(this.embeddings.read(),P(n,[n.size]));return P(r,Ke(this.computeOutputShape(n.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:St(this.embeddingsInitializer),embeddingsRegularizer:dt(this.embeddingsRegularizer),activityRegularizer:dt(this.activityRegularizer),embeddingsConstraint:Wt(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};Jw.className="Embedding";ne.registerClass(Jw);var Fo=class extends Pe{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new ze}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;let n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){let a=e[e.length-t.length+r],s=t[r];if(a==null||s==null||a<0||s<0)n.push(null);else if(a===1)n.push(s);else if(s===1)n.push(a);else{if(a!==s)throw new V("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(a)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Ke(e)]),e=e,e.length<2)throw new V(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let a of e)a!=null&&a[0]!==null&&t.push(a[0]);if(t=Wa(t),t.length>1)throw new V(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=e[0]==null?null:e[0].slice(1);for(let a=1;a<e.length;++a){let s=e[a]==null?null:e[a].slice(1);n=this.computeElementwiseOpOutputShape(n,s)}let r=e.map(a=>a.length);e.indexOf(null)===-1&&Wa(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return B(()=>{if(e=e,this.reshapeRequired){let n=[],r=e.map(a=>a.rank);if(r.indexOf(null)===-1){let a=Qa(r);for(let s of e){let i=s.rank;for(let o=0;o<a-i;++o)s=Md(s,1);n.push(s)}return this.mergeFunction(n)}else{let a=!1;for(let o of e){let l=o.rank;if(l==null){let u=o.shape,p=u[0],h=u.slice(1).concat([p]),d=P(o,[p].concat(Va(u.slice(1))));d=Me(d,[1,0]),d=P(d,h),n.push(d),a=!0}else if(l>1){let u=Cr(1,l).concat([0]);n.push(Me(o,u)),a=!0}else n.push(o)}let s=this.mergeFunction(n),i=s.rank;if(a){if(i==null){let o=s.shape,l=o.length,u=o[l-1],p=[u].concat(o.slice(0,o.length-1));s=P(Me(P(s,[-1,u]),[1,0]),p)}else if(i>1){let o=[i-1].concat(Cr(0,i-1));s=Me(s,o)}}return s}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let r=1;r<e.length;++r){let a=e[r]==null?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,a)}let n=[];for(let r of e)r!=null&&r[0]!==null&&n.push(r[0]);return n=Wa(n),n.length===1?t=n.concat(t):t=[null].concat(t),t}computeMask(e,t){return B(()=>{if(t==null)return null;if(!Array.isArray(t))throw new V("`mask` should be an Array");if(!Array.isArray(e))throw new V("`inputs` should be an Array");if(t.length!==e.length)throw new V(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(r=>r==null))return null;t=t.map(r=>r==null?r:Xt(r,0));let n=t[0];for(let r=1;r<t.length-1;++r)n=gr(n,t[r]);return n})}},Yw=class extends Fo{constructor(e){super(e)}mergeFunction(e){return B(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Z(t,e[n]);return t})}};Yw.className="Add";ne.registerClass(Yw);var Qw=class extends Fo{constructor(e){super(e)}mergeFunction(e){return B(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=z(t,e[n]);return t})}};Qw.className="Multiply";ne.registerClass(Qw);var e0=class extends Fo{constructor(e){super(e)}mergeFunction(e){return B(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Z(t,e[n]);return z(1/e.length,t)})}};e0.className="Average";ne.registerClass(e0);var t0=class extends Fo{constructor(e){super(e)}mergeFunction(e){return B(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Yr(t,e[n]);return t})}};t0.className="Maximum";ne.registerClass(t0);var n0=class extends Fo{constructor(e){super(e)}mergeFunction(e){return B(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Ja(t,e[n]);return t})}};n0.className="Minimum";ne.registerClass(n0);var r0=class extends Fo{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new V("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(let r of e)if(r!=null){t=!1;break}if(t)return;let n=[];for(let r=0;r<e.length;++r){let a=e[r].slice();a.splice(this.axis,1);let s=!1;for(let i of n)if(w.arraysEqual(i,a)){s=!0;break}s||n.push(a)}if(n.length>1)throw new V("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return B(()=>rw(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new V("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(let a of t.slice(1)){if(n[r]==null||a[r]==null){n[r]=null;break}n[r]+=a[r]}return n}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new V("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new V("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new V(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return B(()=>{let n=!0;if(t.forEach(s=>{if(s!=null){n=!1;return}}),n)return null;let r=[];for(let s=0;s<e.length;++s)t[s]==null?r.push(oe(jn(e[s]),"bool")):t[s].rank<e[s].rank?r.push(Xt(t[s],-1)):r.push(t[s]);let a=ot(r,this.axis);return Kc(a,-1,!1)})}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};r0.className="Concatenate";ne.registerClass(r0);function sp(e,t){for(;e<0;)e+=t;return e}function n6(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new ze("batchDot is not implemented for tensors of 4D or higher rank yet");if(w.assert(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),w.assert(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof n=="number"&&(n=[n,n]),e.dtype==="complex64"||t.dtype==="complex64")throw new ze("batchDot is not implemented for complex64-type Tensors yet.");let r=e.shape.length,a=t.shape.length;n==null&&(n=[r-1,a-2]);let s=n;return B(()=>{let i;if(r>a){i=r-a;let l=[];for(let u=0;u<i;++u)l.push(1);t=P(t,t.shape.concat(l))}else if(a>r){i=a-r;let l=[];for(let u=0;u<i;++u)l.push(1);e=P(e,e.shape.concat(l))}else i=0;let o;if(e.shape.length===2&&t.shape.length===2)s[0]===s[1]?o=fe(z(e,t),s[0]):o=fe(z(Me(e,[1,0]),t),s[1]);else{let l=s[0]!==e.shape.length-1,u=s[1]===t.shape.length-1;o=De(e,t,l,u)}if(i>0){let l;r>a?l=r+a-3:l=r-1;let u=[];for(let p=l;p<l+i;++p)u.push(p);o=ms(o,u)}return o.shape.length===1&&(o=Xt(o,1)),o})}var a0=class extends Fo{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){w.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new ze("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new V(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new V(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],n=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((a,s)=>sp(a,e[s].shape.length)):r=[sp(this.axes,t.shape.length),sp(this.axes,n.shape.length)],this.normalize&&(t=pc(t,r[0]),n=pc(n,r[1])),n6(t,n,r)}interpretAxes(e,t){let n;return Array.isArray(this.axes)?n=this.axes:n=[sp(this.axes,e.length),sp(this.axes,t.length)],n}computeOutputShape(e){w.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new ze("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);let a=t.concat(n);return a.length===1&&a.push(1),a}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};a0.className="Dot";ne.registerClass(a0);var s0=class extends Pe{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return B(()=>{this.invokeCallHook(e,t);let n=Te(e);return Ld(()=>Z(Cm(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}};s0.className="GaussianNoise";ne.registerClass(s0);var i0=class extends Pe{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return B(()=>{this.invokeCallHook(e,t);let n=Te(e);return this.rate>0&&this.rate<1?Ld(()=>{let r=Math.sqrt(this.rate/(1-this.rate));return z(n,Cm(n.shape,1,r))},()=>n,t.training||!1):n})}};i0.className="GaussianDropout";ne.registerClass(i0);var o0=class extends Pe{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Te(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return B(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return Ld(()=>{let r=Te(e),a=-1.6732632423543772*1.0507009873554805,s=ba(hs(n),this.rate);s=ca(s,"float32");let i=((1-this.rate)*(1+this.rate*a**2))**-.5,o=-i*a*this.rate,l=Z(z(r,s),z(Z(s,-1),a));return Z(z(l,i),o)},()=>Te(e),t.training||!1)}return e})}};o0.className="AlphaDropout";ne.registerClass(o0);function Mp(e,t,n,r,a,s=.001){let i;if(e.rank===2)i=Xx(e,t,n,r,a,s);else if(e.rank===3)i=Zx(e,t,n,r,a,s);else if(e.rank===4)i=Jx(e,t,n,r,a,s);else throw new ze(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return i}function r6(e,t,n,r,a=.001){return B(()=>{let s=Cd(e,r),i=s.mean,o=s.variance;return[Mp(e,i,o,n,t,a),i,o]})}function a6(e,t,n,r,a=.001){return B(()=>{let s=Cd(e,r),i=s.mean,o=s.variance,l=[];for(let c of Cr(0,e.rank))r.indexOf(c)!==-1?l.push(1):l.push(e.shape[c]);let u=P(i,l),p=P(o,l),h=t==null?null:P(t,l),d=n==null?null:P(n,l);return[Mp(e,u,p,d,h,a),i,o]})}function s6(e,t,n,r,a=.001){return w.arraysEqual(r.slice().sort(),Cr(0,e.rank-1))?r6(e,t,n,r,a):a6(e,t,n,r,a)}var l0=class extends Pe{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=xt(e.betaInitializer||"zeros"),this.gammaInitializer=xt(e.gammaInitializer||"ones"),this.movingMeanInitializer=xt(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=xt(e.movingVarianceInitializer||"ones"),this.betaConstraint=Vt(e.betaConstraint),this.gammaConstraint=Vt(e.gammaConstraint),this.betaRegularizer=vt(e.betaRegularizer),this.gammaRegularizer=vt(e.gammaRegularizer)}build(e){e=Ke(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(n==null)throw new V(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Ft({ndim:e.length,axes:{[t]:n}})];let r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return B(()=>{let n=t.training==null?!1:t.training,r=Te(e),a=r.shape,s=a.length,i=Cr(0,s),o=this.axis>=0?this.axis:this.axis+s;i.splice(o,1);let l=Ys(1,s);l[o]=a[o];let u=i.slice();u.sort();let p=!w.arraysEqual(u,Cr(0,s).slice(0,s-1)),h=()=>{if(p){let g=P(this.movingMean.read(),l),y=P(this.movingVariance.read(),l),b=this.center?P(this.beta.read(),l):null,x=this.scale?P(this.gamma.read(),l):null;return Mp(r,g,y,b,x,this.epsilon)}else return Mp(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return h();let[d,c,m]=s6(r,this.gamma.read(),this.beta.read(),i,this.epsilon),f=(g,y,b)=>{B(()=>{let x=1-b,v=g.read(),I=z(he(v,y),x);g.write(he(v,I))})};return f(this.movingMean,c,this.momentum),f(this.movingVariance,m,this.momentum),d})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:St(this.betaInitializer),gammaInitializer:St(this.gammaInitializer),movingMeanInitializer:St(this.movingMeanInitializer),movingVarianceInitializer:St(this.movingVarianceInitializer),betaRegularizer:dt(this.betaRegularizer),gammaRegularizer:dt(this.gammaRegularizer),betaConstraint:Wt(this.betaConstraint),gammaConstraint:Wt(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};l0.className="BatchNormalization";ne.registerClass(l0);var u0=class extends Pe{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=xt(e.betaInitializer||"zeros"),this.gammaInitializer=xt(e.gammaInitializer||"ones"),this.betaRegularizer=vt(e.betaRegularizer),this.gammaRegularizer=vt(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=Ke(e);let t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=t);for(let a of this.axis)if(a<0||a>=t)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==Wa(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(a=>e[a]),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){let n=Te(e),r=n.shape,a=r.length;return B(()=>{let{mean:s,variance:i}=Cd(n,this.axis,!0),o=Ys(1,a);for(let c of this.axis)o[c]=r[c];let l=c=>c!=null&&c.shape.length!==a?P(c,o):c,u=this.scale?l(this.gamma.read()):null,p=this.center?l(this.beta.read()):null,h=[],d=[];for(let c=0;c<a;++c)this.axis.indexOf(c)!==-1?(h.push(r[c]),d.push(1)):(h.push(1),d.push(r[c]));return s=Vn(s,h),i=Vn(i,h),u!=null&&(u=Vn(u,d)),p!=null&&(p=Vn(p,d)),Mp(n,s,i,p,u,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:St(this.betaInitializer),gammaInitializer:St(this.gammaInitializer),betaRegularizer:dt(this.betaRegularizer),gammaRegularizer:dt(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};u0.className="LayerNormalization";ne.registerClass(u0);function i6(e,t,n){return B(()=>{if(e.rank!==4)throw new V(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new V("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=_r()),n!=="channelsLast"&&n!=="channelsFirst")throw new V(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return n==="channelsFirst"?r=[[0,0],[0,0],t[0],t[1]]:r=[[0,0],t[0],t[1],[0,0]],Ar(e,r)})}var p0=class extends Pe{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?_r():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new V(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new V(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new V(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Ft({ndim:4})]}computeOutputShape(e){e=Ke(e);let t,n;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?n=e[3]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],e[1],t,n]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?n=e[2]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],t,n,e[3]])}call(e,t){return B(()=>i6(Te(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};p0.className="ZeroPadding2D";ne.registerClass(p0);function qm(e,t,n,r,a,s){return B(()=>{Ct(a),L2(s),ur(r),n==null&&(n=[1,1]),r==null&&(r="valid"),a==null&&(a=_r()),s==null&&(s="max"),e=Aw(e,a);let i,o=r==="same"?"same":"valid";return s==="max"?i=jt(e,t,n,o):i=ya(e,t,n,o),a==="channelsFirst"&&(i=Me(i,[0,3,1,2])),i})}function VT(e,t,n,r,a,s){return B(()=>{Ct(a),L2(s),ur(r),n==null&&(n=[1,1,1]),r==null&&(r="valid"),a==null&&(a=_r()),s==null&&(s="max"),e=$T(e,a);let i,o=r==="same"?"same":"valid";return s==="max"?i=wv(e,t,n,o):i=Kx(e,t,n,o),a==="channelsFirst"&&(i=Me(i,[0,4,1,2,3])),i})}var UT=class extends Pe{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new V(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(Zt(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new V(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);Zt(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,ur(this.padding),this.inputSpec=[new Ft({ndim:3})]}computeOutputShape(e){e=Ke(e);let t=Tr(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return B(()=>{this.invokeCallHook(e,t),e=Md(Te(e),2);let n=this.poolingFunction(Te(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return ms(n,[2])})}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},d0=class extends UT{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Ct(a),ur(r),qm(e,t,n,r,a,"max")}};d0.className="MaxPooling1D";ne.registerClass(d0);var h0=class extends UT{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Ct(a),ur(r),qm(e,t,n,r,a,"avg")}};h0.className="AveragePooling1D";ne.registerClass(h0);var GT=class extends Pe{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new V(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];Zt(this.poolSize,"poolSize"),Zt(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ct(this.dataFormat),ur(this.padding),this.inputSpec=[new Ft({ndim:4})]}computeOutputShape(e){e=Ke(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=Tr(t,this.poolSize[0],this.padding,this.strides[0]),n=Tr(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return B(()=>(this.invokeCallHook(e,t),this.poolingFunction(Te(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},c0=class extends GT{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Ct(a),ur(r),qm(e,t,n,r,a,"max")}};c0.className="MaxPooling2D";ne.registerClass(c0);var m0=class extends GT{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Ct(a),ur(r),qm(e,t,n,r,a,"avg")}};m0.className="AveragePooling2D";ne.registerClass(m0);var HT=class extends Pe{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new V(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Zt(this.poolSize,"poolSize"),Zt(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ct(this.dataFormat),ur(this.padding),this.inputSpec=[new Ft({ndim:5})]}computeOutputShape(e){e=Ke(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=Tr(t,this.poolSize[0],this.padding,this.strides[0]),n=Tr(n,this.poolSize[1],this.padding,this.strides[1]),r=Tr(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return B(()=>(this.invokeCallHook(e,t),this.poolingFunction(Te(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},f0=class extends HT{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Ct(a),ur(r),VT(e,t,n,r,a,"max")}};f0.className="MaxPooling3D";ne.registerClass(f0);var g0=class extends HT{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Ct(a),ur(r),VT(e,t,n,r,a,"avg")}};g0.className="AveragePooling3D";ne.registerClass(g0);var jT=class extends Pe{constructor(e){super(e),this.inputSpec=[new Ft({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new ze}},y0=class extends jT{constructor(e){super(e||{})}call(e,t){return B(()=>{let n=Te(e);return kt(n,1)})}};y0.className="GlobalAveragePooling1D";ne.registerClass(y0);var b0=class extends jT{constructor(e){super(e||{})}call(e,t){return B(()=>{let n=Te(e);return ar(n,1)})}};b0.className="GlobalMaxPooling1D";ne.registerClass(b0);var qT=class extends Pe{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ct(this.dataFormat),this.inputSpec=[new Ft({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new ze}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},x0=class extends qT{call(e,t){return B(()=>{let n=Te(e);return this.dataFormat==="channelsLast"?kt(n,[1,2]):kt(n,[2,3])})}};x0.className="GlobalAveragePooling2D";ne.registerClass(x0);var v0=class extends qT{call(e,t){return B(()=>{let n=Te(e);return this.dataFormat==="channelsLast"?ar(n,[1,2]):ar(n,[2,3])})}};v0.className="GlobalMaxPooling2D";ne.registerClass(v0);var KT=class extends Pe{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let r=t.layer,a=Nr(r,n);delete t.layer;let s={layer:a};return Object.assign(s,t),new e(s)}},w0=class extends KT{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=Ke(e),e.length<3)throw new V(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=Ke(e);let t=[e[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return B(()=>(e=Te(e),PT((n,r)=>[Te(this.layer.call(n,t)),[]],e,[],!1,null,null,!1,!0)[1]))}};w0.className="TimeDistributed";ne.registerClass(w0);function o6(e){$o(iG,"BidirectionalMergeMode",e)}var l6="concat",k0=class extends KT{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=Nr(n),t.goBackwards=t.goBackwards!==!0;let r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=Nr(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?l6:e.mergeMode,o6(this.mergeMode),e.weights)throw new ze("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let n,r,a;return this.returnState&&(a=t.slice(1)),n=t[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,r=[n]):this.mergeMode==null?r=[n,n.slice()]:r=[n],this.returnState?this.mergeMode==null?r.concat(a).concat(a.slice()):[n].concat(a).concat(a.slice()):_n(r)}apply(e,t){let n=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});let a=zT(e,n,r,this.numConstants);if(e=a.inputs,n=a.initialState,r=a.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(n==null||n.length===0)&&r==null)return super.apply(e,t);let s=[],i=[];if(n!=null){let l=n.length;if(l%2>0)throw new V("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,s.push(...n);let u=n.map(p=>new Ft({shape:p.shape}));this.forwardLayer.stateSpec=u.slice(0,l/2),this.backwardLayer.stateSpec=u.slice(l/2),i.push(...u)}if(r!=null)throw new ze("Support for constants in Bidirectional layers is not implemented yet.");let o=s[0]instanceof Er;for(let l of s)if(l instanceof Er!==o)throw new V("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){let l=[e].concat(s),u=this.inputSpec.concat(i),p=this.inputSpec;this.inputSpec=u;let h=super.apply(l,t);return this.inputSpec=p,h}else return super.apply(e,t)}call(e,t){return B(()=>{let n=t.initialState,r,a;if(n==null)r=this.forwardLayer.call(e,t),a=this.backwardLayer.call(e,t);else{let o=n.slice(0,n.length/2),l=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:o})),a=this.backwardLayer.call(e,Object.assign(t,{initialState:l}))}let s;this.returnState&&(Array.isArray(r)&&(s=r.slice(1).concat(a.slice(1))),r=r[0],a=a[0]),this.returnSequences&&(a=or(a,1));let i;return this.mergeMode==="concat"?i=rw([r,a]):this.mergeMode==="sum"?i=Z(r,a):this.mergeMode==="ave"?i=z(.5,Z(r,a)):this.mergeMode==="mul"?i=z(r,a):this.mergeMode==null&&(i=[r,a]),this.returnState?this.mergeMode==null?i.concat(s):[i].concat(s):i})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){zs(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),zs(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[t,t]:n=t:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let r=this.forwardLayer.states.map(a=>null);return Array.isArray(n)?n.concat(r).concat(r):[n].concat(r).concat(r)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=Nr(t.layer);if(delete t.layer,t.numConstants!=null)throw new ze("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let r=t;return r.layer=n,new e(r)}};k0.className="Bidirectional";ne.registerClass(k0);var I0=class extends Pe{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return B(()=>(e=Te(e),e.dtype!=="float32"&&(e=ca(e,"float32")),Z(z(e,this.scale),this.offset)))}};I0.className="Rescaling";ne.registerClass(I0);var{resizeBilinear:u6,cropAndResize:p6}=er,S0=class extends Pe{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,a,s,i,o){return B(()=>{let l,u=!1,p=t/s,h=n/i,d=(r+t)/s,c=(a+n)/i,m=[p,h,d,c],f=[];e.rank===3?(u=!0,l=Dt([e])):l=e;for(let x=0;x<l.shape[0];x++)f.push(m);let g=yn(f,[f.length,4]),y=Js(0,f.length,1,"int32"),b=p6(l,g,y,[r,a],"nearest");return ca(u?Te(Tt(b)):b,o)})}upsize(e,t,n,r){return B(()=>{let a=u6(e,[t,n]);return ca(a,r)})}call(e,t){return B(()=>{let n=Te(e),r=n.dtype,a=n.shape,s=a[a.length-3],i=a[a.length-2],o=0;s!==this.height&&(o=Math.floor((s-this.height)/2));let l=0;return i!==this.width&&(l=Math.floor((i-this.width)/2),l===0&&(l=1)),o>=0&&l>=0?this.centerCrop(n,o,l,this.height,this.width,s,i,r):this.upsize(e,this.height,this.width,r)})}getConfig(){let e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Ke(e);let t=e.length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}};S0.className="CenterCrop";ne.registerClass(S0);function d6(e,t,n,r){let a=Te(e);if(a.dtype!=="int32"&&(a=ca(a,"int32")),t==="int")return a;let s=a.shape;if(a.rank===0&&(a=Xt(a,-1)),t==="oneHot"&&a.shape[a.shape.length-1]!==1&&(a=Xt(a,-1)),a.rank>2)throw new V(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${s} which would result in output rank ${a.rank}.`);let i=["multiHot","oneHot"].includes(t),o=a,l;if(typeof r!="undefined"&&t==="count"?l=ac(o,r,n,i):l=ac(o,[],n,i),t!=="tfIdf")return l;if(r)return z(l,r);throw new V("When outputMode is 'tfIdf', weights must be provided.")}var N0=class extends Pe{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=Ke(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return B(()=>{e=Te(e),e.dtype!=="int32"&&(e=ca(e,"int32"));let n;if(typeof t.countWeights!="undefined"){if(this.outputMode!=="count")throw new V(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);n=Te(t.countWeights)}let r=ar(e),a=ll(e),s=kn(this.numTokens,r).bufferSync().get(0),i=ba(a,0).bufferSync().get(0);if(!(s&&i))throw new V(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return d6(e,this.outputMode,this.numTokens,n)})}};N0.className="CategoryEncoding";ne.registerClass(N0);var h6=["bilinear","nearest"],eI=new Set(h6),T0=class extends Pe{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(eI.has(e.interpolation))this.interpolation=e.interpolation;else throw new V(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=Ke(e);let t=e[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return B(()=>{let n=[this.height,this.width];if(this.interpolation==="bilinear")return er.resizeBilinear(e,n,!this.cropToAspectRatio);if(this.interpolation==="nearest")return er.resizeNearestNeighbor(e,n,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...eI]} are supported`)})}};T0.className="Resizing";ne.registerClass(T0);var XT=class{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}};XT.className="RandomSeed";var ZT=class extends Pe{constructor(e){super(e),this.randomGenerator=new XT(e.seed)}getConfig(){let e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}};ZT.className="BaseRandomLayer";var c6=["bilinear","nearest"],tI=new Set(c6),C0=class extends ZT{constructor(e){super(e);let{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new V(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new V(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new V(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(n)if(tI.has(n))this.interpolation=n;else throw new V(`Invalid interpolation parameter: ${n} is not implemented`)}getConfig(){let e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Ke(e);let t=e[2];return[this.imgHeight,-1,t]}call(e,t){return B(()=>{let n=Te(e);this.imgHeight=n.shape[n.shape.length-3];let r=n.shape[n.shape.length-2];this.widthFactor=hs([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let a=this.widthFactor.dataSync()[0]*r;a=Math.round(a);let s=[this.imgHeight,a];switch(this.interpolation){case"bilinear":return er.resizeBilinear(e,s);case"nearest":return er.resizeNearestNeighbor(e,s);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...tI]} are supported`)}})}};C0.className="RandomWidth";ne.registerClass(C0);function m6(e){return new Du(e)}function f6(e){return new _w(e)}function g6(e){return new Nw(e)}function y6(e){return new Tw(e)}function b6(e){return new Cw(e)}function x6(e){return new $w(e)}function v6(e){return new Ew(e)}function w6(e){return new Mw(e)}function k6(e){return new Bm(e)}function I6(e){return new Fw(e)}function S6(e){return new Wm(e)}function N6(e){return new Rw(e)}function T6(e){return new Dw(e)}function C6(e){return new Ow(e)}function _6(e){return new Lw(e)}function E6(e){return new zw(e)}function $6(e){return new jw(e)}function A6(e){return new Gw(e)}function F6(e){return new jm(e)}function R6(e){return new Uw(e)}function D6(e){return new Hw(e)}function M6(e){return new qw(e)}function O6(e){return new Kw(e)}function L6(e){return new Xw(e)}function z6(e){return new Jw(e)}function P6(e){return new Yw(e)}function B6(e){return new e0(e)}function W6(e){return new r0(e)}function V6(e){return new t0(e)}function U6(e){return new n0(e)}function G6(e){return new Qw(e)}function H6(e){return new a0(e)}function j6(e){return new l0(e)}function q6(e){return new u0(e)}function K6(e){return new p0(e)}function _0(e){return new h0(e)}function X6(e){return _0(e)}function Z6(e){return _0(e)}function E0(e){return new m0(e)}function J6(e){return E0(e)}function Y6(e){return E0(e)}function $0(e){return new g0(e)}function Q6(e){return $0(e)}function ej(e){return $0(e)}function tj(e){return new y0(e)}function nj(e){return new x0(e)}function JT(e){return new b0(e)}function YT(e){return new v0(e)}function QT(e){return new d0(e)}function eC(e){return new c0(e)}function rj(e){return new f0(e)}function aj(e){return new Bw(e)}function sj(e){return new Um(e)}function ij(e){return new Ww(e)}function oj(e){return new Wd(e)}function lj(e){return new Pw(e)}function uj(e){return new Vm(e)}function pj(e){return new Vw(e)}function dj(e){return new Hm(e)}function hj(e){return new wa(e)}function cj(e){return new Gm(e)}function mj(e){return new k0(e)}function fj(e){return new w0(e)}var gj=JT,yj=YT,bj=QT,xj=eC;function vj(e){return new s0(e)}function wj(e){return new i0(e)}function kj(e){return new o0(e)}function Ij(e){return new Zw(e)}function Sj(e){return new I0(e)}function Nj(e){return new S0(e)}function Tj(e){return new T0(e)}function Cj(e){return new N0(e)}function _j(e){return new C0(e)}var tC={};_e(tC,{MAPE:()=>Pj,MSE:()=>Vj,binaryAccuracy:()=>Ej,binaryCrossentropy:()=>$j,categoricalAccuracy:()=>Fj,categoricalCrossentropy:()=>Rj,cosineProximity:()=>Oj,mape:()=>Bj,meanAbsoluteError:()=>Lj,meanAbsolutePercentageError:()=>zj,meanSquaredError:()=>Wj,mse:()=>Uj,precision:()=>Dj,r2Score:()=>Gj,recall:()=>Mj,sparseCategoricalAccuracy:()=>Aj});function Ej(e,t){return xw(e,t)}function $j(e,t){return aT(e,t)}function Aj(e,t){return sT(e,t)}function Fj(e,t){return vw(e,t)}function Rj(e,t){return ww(e,t)}function Dj(e,t){return rT(e,t)}function Mj(e,t){return hH(e,t)}function Oj(e,t){return bw(e,t)}function Lj(e,t){return Om(e,t)}function zj(e,t){return Mu(e,t)}function Pj(e,t){return Mu(e,t)}function Bj(e,t){return Mu(e,t)}function Wj(e,t){return Ao(e,t)}function Vj(e,t){return Ao(e,t)}function Uj(e,t){return Ao(e,t)}function Gj(e,t){return cH(e,t)}var nC={};_e(nC,{modelFromJSON:()=>UH});var rC={};_e(rC,{l1:()=>jj,l1l2:()=>Hj,l2:()=>qj});function Hj(e){return new Pd(e)}function jj(e){return ZH(e)}function qj(e){return JH(e)}var aC=class extends gl{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof pa))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function $h(e,t){return e<t}function nI(e,t){return e>t}var sC=class extends aC{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new ze("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=$h:this.mode==="max"?this.monitorFunc=nI:this.monitor.indexOf("acc")!==-1?this.monitorFunc=nI:this.monitorFunc=$h,this.monitorFunc===$h&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===$h?1/0:-1/0}async onEpochEnd(e,t){await Aa(t);let n=this.getMonitorValue(t);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});let t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};function Kj(e){return new sC(e)}var Xj={earlyStopping:Kj},Zj=G();Zj.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var zn;(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"})(zn||(zn={}));var rI;(function(e){let t;(function(n){n[n.LEGACY=0]="LEGACY",n[n.V1=1]="V1",n[n.V2=2]="V2"})(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(rI||(rI={}));var A0={};function Jj(e,t){let n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};A0[e]=n}function iC(e){return A0[e]}function Yj(e){delete A0[e]}function k(e,t,n,r,a){let s=t.inputParams[e];if(s&&s.inputIndexStart!==void 0){let o=s.inputIndexStart,l=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?o+1:s.inputIndexEnd,u=o<0?t.inputNames.length+o:o;if(s.type==="tensor")return nn(t.inputNames[u],n,r,a);if(s.type==="tensors"){let d=t.inputs.slice(o,l);return t.inputNames.slice(o,l).filter((c,m)=>{var f;return((f=d[m])===null||f===void 0?void 0:f.op)!=="NoOp"}).map(c=>nn(c,n,r,a))}let p=nn(t.inputNames[u],n,r,a),h=p.dataSync();return s.type==="number"?h[0]:w.toNestedArray(p.shape,h)}let i=t.attrParams[e];return i&&i.value}function nn(e,t,n,r){let[a,s]=Bn(e,n);if(r!=null){let o=r.getHashTableHandleByName(a);if(o!=null)return o}let i=n.currentContextIds.find(o=>!!t[fc(a,o)]);return i!==void 0?t[fc(a,i)][s]:void 0}function aI(e,t,n){return t[fc(e,n.currentContextId)]}function ia(e,t){let[n,r,a]=Bn(e,t);return[fc(n,t&&t.currentContextId),r,a]}function fc(e,t){return t?`${e}-${t}`:e}function Bn(e,t){if(e==="")return["",0,void 0];let n=t!=null&&t.parseNodeNameCache!=null;if(n){let s=t.parseNodeNameCache.get(e);if(s!=null)return s}let r=e.split(":"),a;if(r.length===1)a=[e,0,void 0];else{let s=r[0],i=r.length===3?r[1]:void 0,o=Number(r[r.length-1]);a=[s,o,i]}return n&&t.parseNodeNameCache.set(e,a),a}function Uh(e,t,n){let r=k("pad",e,t,n);if(r==="explicit"){r=k("explicitPaddings",e,t,n);let a=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)a[s][0]=r[s*2],a[s][1]=r[s*2+1];return a}return r}function oa(e){return e.kept?e:Ur(e)}var oC={};_e(oC,{json:()=>Qj});var Qj=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],lC={};_e(lC,{json:()=>eq});var eq=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],uC={};_e(uC,{json:()=>tq});var tq=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],pC={};_e(pC,{json:()=>nq});var nq=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],dC={};_e(dC,{json:()=>rq});var rq=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],hC={};_e(hC,{json:()=>aq});var aq=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],cC={};_e(cC,{json:()=>sq});var sq=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],mC={};_e(mC,{json:()=>iq});var iq=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],fC={};_e(fC,{json:()=>oq});var oq=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],gC={};_e(gC,{json:()=>lq});var lq=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],yC={};_e(yC,{json:()=>uq});var uq=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],bC={};_e(bC,{json:()=>pq});var pq=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],xC={};_e(xC,{json:()=>dq});var dq=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],vC={};_e(vC,{json:()=>hq});var hq=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],wC={};_e(wC,{json:()=>cq});var cq=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],kC={};_e(kC,{json:()=>mq});var mq=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],IC={};_e(IC,{json:()=>fq});var fq=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],SC={};_e(SC,{json:()=>gq});var gq=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],NC={};_e(NC,{json:()=>yq});var yq=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],sI=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[oC,lC,uC,pC,dC,hC,cC,mC,fC,gC,yC,bC,xC,vC,wC,kC,IC,SC,NC],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,r)=>(n[r.tfOpName]=r,n),{})}transformGraph(e,t={}){let n=e.node,r=[],a=[],s=[],i=n.reduce((m,f)=>(m[f.name]=this.mapNode(f),f.op.startsWith("Placeholder")?r.push(m[f.name]):f.op==="Const"?a.push(m[f.name]):(f.input==null||f.input.length===0)&&s.push(m[f.name]),m),{}),o=[],l=[],u={},p={};t!=null&&(u=this.mapSignatureEntries(t.inputs),p=this.mapSignatureEntries(t.outputs));let h=Object.keys(i);h.forEach(m=>{let f=i[m];f.inputNames.forEach((g,y)=>{let[b,,x]=ia(g),v=i[b];if(v.outputs!=null){let I=v.outputs.indexOf(x);if(I!==-1){let N=`${b}:${I}`;f.inputNames[y]=N}}f.inputs.push(v),v.children.push(f)})}),Object.keys(p).length===0?h.forEach(m=>{let f=i[m];f.children.length===0&&l.push(f)}):Object.keys(p).forEach(m=>{let[f]=ia(m),g=i[f];g!=null&&(g.signatureKey=p[m],l.push(g))}),Object.keys(u).length>0?Object.keys(u).forEach(m=>{let[f]=ia(m),g=i[f];g&&(g.signatureKey=u[m],o.push(g))}):o=r;let d={};e.library!=null&&e.library.function!=null&&(d=e.library.function.reduce((m,f)=>(m[f.signature.name]=this.mapFunction(f),m),{}));let c={nodes:i,inputs:o,outputs:l,weights:a,placeholders:r,signature:t,functions:d};return s.length>0&&(c.initNodes=s),c}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){let t=iC(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((r,a)=>(r[a.name]={type:a.type,inputIndexStart:a.start,inputIndexEnd:a.end},r),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((r,a)=>{let s=a.type,i;switch(a.type){case"string":i=Vb(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Vb(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":i=Xb(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Xb(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":i=Gb(e.attr,a.tfName,a.defaultValue||0),i===void 0&&a.tfDeprecatedName&&(i=Gb(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":i=Kb(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Kb(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":i=Ub(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Ub(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":i=Jb(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Jb(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":i=qb(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=qb(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":i=Zb(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Zb(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":i=Hb(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Hb(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":i=jb(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=jb(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":i=iI(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=iI(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${e.op}`)}return r[a.name]={value:i,type:s},r},{})),n}mapFunction(e){let t=e.nodeDef,n=[],r=[],a={};t!=null&&(a=t.reduce((u,p)=>(u[p.name]=this.mapNode(p),p.op==="Const"&&r.push(u[p.name]),u),{}));let s=[],i=[];e.signature.inputArg.forEach(u=>{let[p]=ia(u.name),h={name:p,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:F0(u.type),type:"dtype"}},children:[]};h.signatureKey=u.name,s.push(h),a[p]=h}),Object.keys(a).forEach(u=>{let p=a[u];p.inputNames.forEach((h,d)=>{let[c,,m]=ia(h),f=a[c];if(f.outputs!=null){let g=f.outputs.indexOf(m);if(g!==-1){let y=`${c}:${g}`;p.inputNames[d]=y}}p.inputs.push(f),f.children.push(p)})});let o=e.ret;e.signature.outputArg.forEach(u=>{let[p,h]=ia(o[u.name]),d=a[p];d!=null&&(d.defaultOutput=h,i.push(d))});let l=this.mapArgsToSignature(e);return{nodes:a,inputs:s,outputs:i,weights:r,placeholders:n,signature:l}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}};function bq(e){let t=G().global;if(typeof t.atob!="undefined")return t.atob(e);if(typeof Buffer!="undefined")return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function TC(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):bq(e);return t?n:n.toLowerCase()}function Vb(e,t,n,r=!1){let a=e[t];return a!=null?TC(a.s,r):n}function Ub(e,t,n){let r=e[t];return r?r.b:n}function Gb(e,t,n){let r=e[t]||{},a=r.i!=null?r.i:r.f!=null?r.f:n;return typeof a=="number"?a:parseInt(a,10)}function F0(e){switch(typeof e=="string"&&(e=zn[e]),e){case zn.DT_FLOAT:case zn.DT_HALF:return"float32";case zn.DT_INT32:case zn.DT_INT64:case zn.DT_INT8:case zn.DT_UINT8:return"int32";case zn.DT_BOOL:return"bool";case zn.DT_DOUBLE:return"float32";case zn.DT_STRING:return"string";case zn.DT_COMPLEX64:case zn.DT_COMPLEX128:return"complex64";default:return null}}function iI(e,t,n){let r=e[t];return r&&r.func?r.func.name:n}function Hb(e,t,n){let r=e[t];return r&&r.type?F0(r.type):n}function jb(e,t,n){let r=e[t];return r&&r.list&&r.list.type?r.list.type.map(a=>F0(a)):n}function CC(e){if(!e.unknownRank)return e.dim!=null?e.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function qb(e,t,n){let r=e[t];return r&&r.shape?CC(r.shape):n}function Kb(e,t,n){let r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(a=>typeof a=="number"?a:parseInt(a,10)):n}function Xb(e,t,n,r=!1){let a=e[t];return a&&a.list&&a.list.s?a.list.s.map(s=>TC(s,r)):n}function Zb(e,t,n){let r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map(a=>CC(a)):n}function Jb(e,t,n){let r=e[t];return r&&r.list&&r.list.b?r.list.b:n}var xq=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,a)=>(r[a]=this.getAttr(a),r),{}))}getInput(e){return nn(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(n.tensor!=null)return nn(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return Gb(this.node.rawAttrs,e,t);if(n.s!=null)return Vb(this.node.rawAttrs,e,t);if(n.b!=null)return Ub(this.node.rawAttrs,e,t);if(n.shape!=null)return qb(this.node.rawAttrs,e,t);if(n.type!=null)return Hb(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return Kb(this.node.rawAttrs,e,t);if(n.list.s!=null)return Xb(this.node.rawAttrs,e,t);if(n.list.shape!=null)return Zb(this.node.rawAttrs,e,t);if(n.list.b!=null)return Jb(this.node.rawAttrs,e,t);if(n.list.type!=null)return jb(this.node.rawAttrs,e,t)}return t}},en={};_e(en,{OP_SCOPE_SUFFIX:()=>Rx,abs:()=>At,acos:()=>Px,acosh:()=>Bx,add:()=>Z,addN:()=>WS,all:()=>Kc,any:()=>Ep,argMax:()=>qs,argMin:()=>Wx,asin:()=>Vx,asinh:()=>Ux,atan:()=>Gx,atan2:()=>Hx,atanh:()=>jx,avgPool:()=>ya,avgPool3d:()=>Kx,basicLSTMCell:()=>HS,batchNorm:()=>To,batchNorm2d:()=>Xx,batchNorm3d:()=>Zx,batchNorm4d:()=>Jx,batchToSpaceND:()=>vd,bincount:()=>Yx,bitwiseAnd:()=>jS,booleanMaskAsync:()=>MN,broadcastArgs:()=>qS,broadcastTo:()=>Ls,buffer:()=>Oe,cast:()=>oe,ceil:()=>Qx,clipByValue:()=>un,clone:()=>Ur,complex:()=>ha,concat:()=>ot,concat1d:()=>ev,concat2d:()=>tv,concat3d:()=>nv,concat4d:()=>rv,conv1d:()=>Xc,conv2d:()=>bn,conv2dTranspose:()=>Zc,conv3d:()=>sv,conv3dTranspose:()=>iv,cos:()=>wd,cosh:()=>Jc,cosineWindow:()=>vm,cumprod:()=>Fp,cumsum:()=>Yc,denseBincount:()=>ac,depthToSpace:()=>ov,depthwiseConv2d:()=>Co,diag:()=>XS,dilation2d:()=>lv,div:()=>ce,divNoNan:()=>uv,dot:()=>pv,dropout:()=>Pv,einsum:()=>As,elu:()=>Cu,enclosingPowerOfTwo:()=>Bv,ensureShape:()=>JS,equal:()=>Gn,erf:()=>Qc,euclideanNorm:()=>cv,exp:()=>pn,expandDims:()=>Xt,expm1:()=>mv,eye:()=>em,fft:()=>Ad,fill:()=>Un,floor:()=>Eu,floorDiv:()=>qc,fused:()=>ml,gather:()=>$u,gatherND:()=>PN,greater:()=>kn,greaterEqual:()=>ba,ifft:()=>cl,imag:()=>kd,image:()=>er,inTopKAsync:()=>BN,irfft:()=>cm,isFinite:()=>fv,isInf:()=>gv,isNaN:()=>yv,leakyRelu:()=>Id,less:()=>ul,lessEqual:()=>ds,linalg:()=>Uv,linspace:()=>nN,localResponseNormalization:()=>bv,log:()=>Hn,log1p:()=>Sd,logSigmoid:()=>xv,logSoftmax:()=>nm,logSumExp:()=>Nd,logicalAnd:()=>gr,logicalNot:()=>Td,logicalOr:()=>rm,logicalXor:()=>vv,losses:()=>YN,lowerBound:()=>aN,matMul:()=>De,max:()=>ar,maxPool:()=>jt,maxPool3d:()=>wv,maxPoolWithArgmax:()=>sN,maximum:()=>Yr,mean:()=>kt,meshgrid:()=>iN,min:()=>ll,minimum:()=>Ja,mirrorPad:()=>kv,mod:()=>Iv,moments:()=>Cd,movingAverage:()=>ON,mul:()=>z,multiRNNCell:()=>oN,multinomial:()=>lN,neg:()=>ft,norm:()=>_u,notEqual:()=>Zs,oneHot:()=>pl,ones:()=>En,onesLike:()=>jn,op:()=>L,outerProduct:()=>uN,pad:()=>Ar,pad1d:()=>pN,pad2d:()=>dN,pad3d:()=>hN,pad4d:()=>cN,pool:()=>Sv,pow:()=>qr,prelu:()=>Ed,print:()=>zx,prod:()=>Nv,raggedGather:()=>mN,raggedRange:()=>fN,raggedTensorToTensor:()=>gN,rand:()=>yN,randomGamma:()=>wN,randomNormal:()=>sm,randomStandardNormal:()=>kN,randomUniform:()=>hs,randomUniformInt:()=>IN,range:()=>Js,real:()=>dl,reciprocal:()=>$v,relu:()=>nt,relu6:()=>im,reshape:()=>P,reverse:()=>or,reverse1d:()=>SN,reverse2d:()=>NN,reverse3d:()=>TN,reverse4d:()=>CN,rfft:()=>Fd,round:()=>om,rsqrt:()=>lm,scalar:()=>ve,scatterND:()=>LN,searchSorted:()=>am,selu:()=>um,separableConv2d:()=>Au,setdiff1dAsync:()=>_N,sigmoid:()=>fr,sign:()=>Av,signal:()=>JN,sin:()=>pm,sinh:()=>dm,slice:()=>Ue,slice1d:()=>$d,slice2d:()=>hm,slice3d:()=>Fu,slice4d:()=>hl,softmax:()=>cs,softplus:()=>_o,spaceToBatchND:()=>_d,sparse:()=>QN,sparseToDense:()=>zN,spectral:()=>ZN,split:()=>$n,sqrt:()=>Yt,square:()=>it,squaredDifference:()=>mm,squeeze:()=>ms,stack:()=>Dt,step:()=>Eo,stridedSlice:()=>Fv,string:()=>e2,sub:()=>he,sum:()=>fe,tan:()=>Rv,tanh:()=>Za,tensor:()=>yn,tensor1d:()=>Qe,tensor2d:()=>Gr,tensor3d:()=>fm,tensor4d:()=>Ya,tensor5d:()=>EN,tensor6d:()=>$N,tensorScatterUpdate:()=>FN,tile:()=>Vn,topk:()=>Mv,transpose:()=>Me,truncatedNormal:()=>bm,unique:()=>Ov,unsortedSegmentSum:()=>xm,unstack:()=>Tt,upperBound:()=>RN,variable:()=>Lv,where:()=>Jt,whereAsync:()=>zv,zeros:()=>It,zerosLike:()=>Ge});var vq=(e,t,n,r=en)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(k("a",e,t,n),k("b",e,t,n))];case"AddN":return[r.addN(k("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(k("a",e,t,n),k("b",e,t,n))];case"Mul":return[r.mul(k("a",e,t,n),k("b",e,t,n))];case"RealDiv":case"Div":return[r.div(k("a",e,t,n),k("b",e,t,n))];case"DivNoNan":return[r.divNoNan(k("a",e,t,n),k("b",e,t,n))];case"FloorDiv":return[r.floorDiv(k("a",e,t,n),k("b",e,t,n))];case"Sub":return[r.sub(k("a",e,t,n),k("b",e,t,n))];case"Minimum":return[r.minimum(k("a",e,t,n),k("b",e,t,n))];case"Maximum":return[r.maximum(k("a",e,t,n),k("b",e,t,n))];case"Pow":return[r.pow(k("a",e,t,n),k("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(k("a",e,t,n),k("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},wq=(e,t,n,r=en)=>{switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(k("x",e,t,n))];case"Acos":return[r.acos(k("x",e,t,n))];case"Acosh":return[r.acosh(k("x",e,t,n))];case"Asin":return[r.asin(k("x",e,t,n))];case"Asinh":return[r.asinh(k("x",e,t,n))];case"Atan":return[r.atan(k("x",e,t,n))];case"Atan2":return[r.atan2(k("x",e,t,n),k("y",e,t,n))];case"Atanh":return[r.atanh(k("x",e,t,n))];case"Ceil":return[r.ceil(k("x",e,t,n))];case"Complex":return[r.complex(k("real",e,t,n),k("imag",e,t,n))];case"Cos":return[r.cos(k("x",e,t,n))];case"Cosh":return[r.cosh(k("x",e,t,n))];case"Elu":return[r.elu(k("x",e,t,n))];case"Erf":return[r.erf(k("x",e,t,n))];case"Exp":return[r.exp(k("x",e,t,n))];case"Expm1":return[r.expm1(k("x",e,t,n))];case"Floor":return[r.floor(k("x",e,t,n))];case"Log":return[r.log(k("x",e,t,n))];case"Log1p":return[r.log1p(k("x",e,t,n))];case"Imag":return[r.imag(k("x",e,t,n))];case"Neg":return[r.neg(k("x",e,t,n))];case"Reciprocal":return[r.reciprocal(k("x",e,t,n))];case"Real":return[r.real(k("x",e,t,n))];case"Relu":return[r.relu(k("x",e,t,n))];case"Round":return[r.round(k("x",e,t,n))];case"Selu":return[r.selu(k("x",e,t,n))];case"Sigmoid":return[r.sigmoid(k("x",e,t,n))];case"Sin":return[r.sin(k("x",e,t,n))];case"Sign":return[r.sign(k("x",e,t,n))];case"Sinh":return[r.sinh(k("x",e,t,n))];case"Softplus":return[r.softplus(k("x",e,t,n))];case"Sqrt":return[r.sqrt(k("x",e,t,n))];case"Square":return[r.square(k("x",e,t,n))];case"Tanh":return[r.tanh(k("x",e,t,n))];case"Tan":return[r.tan(k("x",e,t,n))];case"ClipByValue":return[r.clipByValue(k("x",e,t,n),k("clipValueMin",e,t,n),k("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(k("x",e,t,n))];case"Rsqrt":return[r.rsqrt(nn(e.inputNames[0],t,n))];case"LeakyRelu":return[r.leakyRelu(k("x",e,t,n),k("alpha",e,t,n))];case"Prelu":return[r.prelu(k("x",e,t,n),k("alpha",e,t,n))];case"IsNan":return[r.isNaN(nn(e.inputNames[0],t,n))];case"IsInf":return[r.isInf(nn(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite(nn(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function mr(e,t,n=""){if(!(typeof e=="number"||typeof t=="number")){w.assert(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let r=0;r<e.length;r++){let a=e[r],s=t[r];w.assert(a<0||s<0||a===s,()=>n+` Shapes ${e} and ${t} must match`)}}}function oI(e){return!(typeof e=="number"||e.some(t=>t<0))}function ip(e,t,n){let r=Yb(e,n),a=!oI(r);if(a&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(a&&t.forEach(s=>{r=Yb(s.shape,r)}),!oI(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function Yb(e,t){if(typeof e=="number")return t;if(typeof t=="number")return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let r=0;r<e.length;++r){let a=e[r],s=t[r];if(a>=0&&s>=0&&a!==s)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=a>=0?a:s}return n}var kq=class{constructor(e,t,n,r,a,s,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=a,this.dynamicSize=s,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=ve(0),zt(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),mr(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,zt(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,r)=>this.write(n,t[r]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return yn([],[0].concat(this.elementShape));let n=this.readMany(e);return mr(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Dt(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return yn([],[0].concat(this.elementShape));let t=[];for(let r=0;r<this.size();r++)t.push(r);let n=this.readMany(t);return mr(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),ot(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,Tt(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,r=e.map(o=>(n+=o,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let a=n===0?0:t.size/n,s=[];B(()=>{t=P(t,[1,n,a]);for(let o=0;o<e.length;++o){let l=[0,o===0?0:r[o-1],0],u=[1,e[o],a];s[o]=P(Ue(t,l,u),this.elementShape)}return s});let i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,s)}},Km=class Qb{get id(){return this.idTensor.id}constructor(t,n,r,a=-1){this.tensors=t,this.elementShape=n,this.elementDtype=r,t!=null&&t.forEach(s=>{if(r!==s.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${s.dtype}`);mr(n,s.shape,"TensorList shape mismatch: "),zt(s)}),this.idTensor=ve(0),this.maxNumElements=a,zt(this.idTensor)}copy(){return new Qb([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(n=>{(t==null||!t.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,n,r=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);mr(t,this.elementShape,"TensorList shape mismatch: ");let a=ip(this.elementShape,this.tensors,t);return B(()=>{let s=this.tensors.map(i=>P(i,a));return Dt(s,0)})}popBack(t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let r=ip(this.elementShape,this.tensors,t),a=this.tensors.pop();return a.kept=!1,mr(a.shape,t,"TensorList shape mismatch: "),P(a,r)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(mr(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");zt(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);let n=new Qb([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=t;for(let r=0;r<Math.min(this.tensors.length,t);++r)n.tensors[r]=this.tensors[r];return n}getItem(t,n,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);mr(this.tensors[t].shape,n,"TensorList shape mismatch: ");let a=ip(this.elementShape,this.tensors,n);return P(this.tensors[t],a)}setItem(t,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);mr(this.elementShape,n.shape,"TensorList shape mismatch: "),zt(n),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=n}gather(t,n,r){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);mr(this.elementShape,r,"TensorList shape mismatch: "),t=t.slice(0,this.size());let a=ip(this.elementShape,this.tensors,r);return t.length===0?yn([],[0].concat(a)):B(()=>{let s=t.map(i=>P(this.tensors[i],a));return Dt(s,0)})}concat(t,n){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);mr(this.elementShape,n,"TensorList shape mismatch: ");let r=ip(this.elementShape,this.tensors,n);return this.size()===0?yn([],[0].concat(r)):B(()=>{let a=this.tensors.map(s=>P(s,r));return ot(a,0)})}};function Iq(e,t,n){let r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);let a=e.shape.slice(1);mr(a,t,"TensorList shape mismatch: ");let s=Tt(e);return new Km(s,t,r)}function Sq(e,t,n,r){return new Km([],e,t,r)}function Nq(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let a=Math.max(...t);if(r!=null&&r!==-1&&a>=r)throw new Error(`Max index must be < array size (${a}  vs. ${r})`);let s=new Km([],n,e.dtype,r),i=Tt(e,0);return t.forEach((o,l)=>{s.setItem(o,i[l])}),s}function Tq(e,t,n){let r=0,a=t.map(p=>(r+=p,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${e.shape}`);let s=e.shape.slice(1),i=Yb(s,n),o=r===0?0:e.size/r,l=B(()=>{let p=[];e=P(e,[1,r,o]);for(let h=0;h<t.length;++h){let d=[0,h===0?0:a[h-1],0],c=[1,t[h],o];p[h]=P(Ue(e,d,c),i)}return e.dispose(),p}),u=new Km([],n,e.dtype,t.length);for(let p=0;p<l.length;p++)u.setItem(p,l[p]);return u}var Cq=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{let r=k("thenBranch",e,t,n),a=k("elseBranch",e,t,n),s=k("cond",e,t,n),i=k("args",e,t,n);return(await s.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[a].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{let r=k("body",e,t,n),a=k("cond",e,t,n),s=k("args",e,t,n),i=await n.functionMap[a].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),o=s.map(p=>p.id),l=await i[0].data();i.forEach(p=>{!p.kept&&o.indexOf(p.id)===-1&&p.dispose()});let u=s;for(;l[0];){let p=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);let h=u.map(c=>c.id);p.forEach(c=>{!c.kept&&o.indexOf(c.id)===-1&&h.indexOf(c.id)===-1&&c.dispose()});let d=await n.functionMap[a].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await d[0].data(),d.forEach(c=>{!c.kept&&o.indexOf(c.id)===-1&&h.indexOf(c.id)===-1&&c.dispose()})}return u}case"LoopCond":{let r=k("pred",e,t,n);return[oa(r)]}case"Switch":{let r=k("pred",e,t,n),a=k("data",e,t,n);return a.kept||(a=oa(a)),(await r.data())[0]?[void 0,a]:[a,void 0]}case"Merge":{let r=e.inputNames.find(a=>nn(a,t,n)!==void 0);if(r){let a=nn(r,t,n);return[oa(a)]}return}case"Enter":{let r=k("frameName",e,t,n),a=k("tensor",e,t,n);return n.enterFrame(r),[oa(a)]}case"Exit":{let r=k("tensor",e,t,n);return n.exitFrame(),[oa(r)]}case"NextIteration":{let r=k("tensor",e,t,n);return n.nextIteration(),[oa(r)]}case"TensorArrayV3":{let r=k("size",e,t,n),a=k("dtype",e,t,n),s=k("elementShape",e,t,n),i=k("dynamicSize",e,t,n),o=k("clearAfterRead",e,t,n),l=k("identicalElementShapes",e,t,n),u=k("name",e,t,n),p=new kq(u,a,r,s,l,i,o);return n.addTensorArray(p),[p.idTensor,ve(1)]}case"TensorArrayWriteV3":{let r=k("tensorArrayId",e,t,n),a=k("index",e,t,n),s=k("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(a,s),[i.idTensor]}case"TensorArrayReadV3":{let r=k("tensorArrayId",e,t,n),a=k("index",e,t,n);return[n.getTensorArray(r.id).read(a)]}case"TensorArrayGatherV3":{let r=k("tensorArrayId",e,t,n),a=k("indices",e,t,n),s=k("dtype",e,t,n);return[n.getTensorArray(r.id).gather(a,s)]}case"TensorArrayScatterV3":{let r=k("tensorArrayId",e,t,n),a=k("indices",e,t,n),s=k("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(a,s),[i.idTensor]}case"TensorArrayConcatV3":{let r=k("tensorArrayId",e,t,n),a=n.getTensorArray(r.id),s=k("dtype",e,t,n);return[a.concat(s)]}case"TensorArraySplitV3":{let r=k("tensorArrayId",e,t,n),a=k("tensor",e,t,n),s=k("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(s,a),[i.idTensor]}case"TensorArraySizeV3":{let r=k("tensorArrayId",e,t,n),a=n.getTensorArray(r.id);return[ve(a.size(),"int32")]}case"TensorArrayCloseV3":{let r=k("tensorArrayId",e,t,n),a=n.getTensorArray(r.id);return a.clearAndClose(),[a.idTensor]}case"TensorListSetItem":{let r=k("tensorListId",e,t,n),a=k("index",e,t,n),s=k("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(a,s),[i.idTensor]}case"TensorListGetItem":{let r=k("tensorListId",e,t,n),a=k("index",e,t,n),s=k("elementShape",e,t,n),i=k("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(a,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let r=k("indices",e,t,n),a=k("tensor",e,t,n),s=k("elementShape",e,t,n),i=k("numElements",e,t,n),o=Nq(a,r,s,i);return n.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r=k("elementShape",e,t,n),a=k("elementDType",e,t,n),s;e.op==="TensorListReserve"?s="numElements":s="maxNumElements";let i=k(s,e,t,n),o=e.op==="TensorListReserve"?-1:i,l=Sq(r,a,i,o);return n.addTensorList(l),[l.idTensor]}case"TensorListGather":{let r=k("tensorListId",e,t,n),a=k("indices",e,t,n),s=k("elementShape",e,t,n),i=k("elementDType",e,t,n);return[n.getTensorList(r.id).gather(a,i,s)]}case"TensorListStack":{let r=k("tensorListId",e,t,n),a=k("elementShape",e,t,n),s=k("elementDType",e,t,n),i=k("numElements",e,t,n);return[n.getTensorList(r.id).stack(a,s,i)]}case"TensorListFromTensor":{let r=k("tensor",e,t,n),a=k("elementShape",e,t,n),s=k("elementDType",e,t,n),i=Iq(r,a,s);return n.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let r=k("tensorListId",e,t,n),a=n.getTensorList(r.id),s=k("dtype",e,t,n),i=k("elementShape",e,t,n);return[a.concat(s,i)]}case"TensorListPushBack":{let r=k("tensorListId",e,t,n),a=k("tensor",e,t,n),s=n.getTensorList(r.id);return s.pushBack(a),[s.idTensor]}case"TensorListPopBack":{let r=k("tensorListId",e,t,n),a=k("elementShape",e,t,n),s=k("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(a,s)]}case"TensorListSplit":{let r=k("tensor",e,t,n),a=k("elementShape",e,t,n),s=k("lengths",e,t,n),i=Tq(r,s,a);return n.addTensorList(i),[i.idTensor]}case"TensorListLength":{let r=k("tensorListId",e,t,n),a=n.getTensorList(r.id);return[ve(a.size(),"int32")]}case"TensorListResize":{let r=k("tensorListId",e,t,n),a=k("size",e,t,n),s=n.getTensorList(r.id).resize(a);return n.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function lI(e,t,n){let[r,a]=k("fusedOps",e,t,n),s=r==="biasadd",i=!s,o=a==="prelu",l=r==="fusedbatchnorm",u=k("numArgs",e,t,n);if(s){if(o&&u!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&s&&u!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let p=k("strides",e,t,n),h=Uh(e,t,n),d=k("dataFormat",e,t,n).toUpperCase(),c=k("dilations",e,t,n),[m,f]=k("args",e,t,n);i&&(f=m,m=void 0);let g=k("leakyreluAlpha",e,t,n);return{stride:p,pad:h,dataFormat:d,dilations:c,biasArg:m,preluArg:f,activationFunc:a,leakyreluAlpha:g}}var _q=(e,t,n,r=en)=>{switch(e.op){case"Conv1D":{let a=k("stride",e,t,n),s=k("pad",e,t,n),i=k("dataFormat",e,t,n).toUpperCase(),o=k("dilation",e,t,n);return[r.conv1d(k("x",e,t,n),k("filter",e,t,n),a,s,i,o)]}case"Conv2D":{let a=k("strides",e,t,n),s=Uh(e,t,n),i=k("dataFormat",e,t,n).toUpperCase(),o=k("dilations",e,t,n);return[r.conv2d(k("x",e,t,n),k("filter",e,t,n),[a[1],a[2]],s,i,[o[1],o[2]])]}case"_FusedConv2D":{let{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:p,leakyreluAlpha:h}=lI(e,t,n);return[r.fused.conv2d({x:k("x",e,t,n),filter:k("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:p,preluActivationWeights:u,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{let{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:p,leakyreluAlpha:h}=lI(e,t,n);return[r.fused.depthwiseConv2d({x:k("x",e,t,n),filter:k("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:p,preluActivationWeights:u,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let a=k("outputShape",e,t,n),s=k("strides",e,t,n),i=Uh(e,t,n);return[r.conv2dTranspose(k("x",e,t,n),k("filter",e,t,n),a,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let a=k("strides",e,t,n),s=Uh(e,t,n),i=k("dilations",e,t,n),o=k("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(k("input",e,t,n),k("filter",e,t,n),[a[1],a[2]],s,o,[i[1],i[2]])]}case"Conv3D":{let a=k("strides",e,t,n),s=k("pad",e,t,n),i=k("dataFormat",e,t,n).toUpperCase(),o=k("dilations",e,t,n);return[r.conv3d(k("x",e,t,n),k("filter",e,t,n),[a[1],a[2],a[3]],s,i,[o[1],o[2],o[3]])]}case"AvgPool":{let a=k("strides",e,t,n),s=k("pad",e,t,n),i=k("kernelSize",e,t,n);return[r.avgPool(k("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPool":{let a=k("strides",e,t,n),s=k("pad",e,t,n),i=k("kernelSize",e,t,n);return[r.maxPool(k("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPoolWithArgmax":{let a=k("strides",e,t,n),s=k("pad",e,t,n),i=k("kernelSize",e,t,n),o=k("includeBatchInIndex",e,t,n),{result:l,indexes:u}=r.maxPoolWithArgmax(k("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s,o);return[l,u]}case"AvgPool3D":{let a=k("strides",e,t,n),s=k("pad",e,t,n),i=k("kernelSize",e,t,n);return[r.avgPool3d(k("x",e,t,n),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"MaxPool3D":{let a=k("strides",e,t,n),s=k("pad",e,t,n),i=k("kernelSize",e,t,n);return[r.maxPool3d(k("x",e,t,n),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"Dilation2D":{let a=k("strides",e,t,n),s=k("pad",e,t,n),i=k("dilations",e,t,n),o=a[1],l=a[2],u=i[1],p=i[2];return[r.dilation2d(k("x",e,t,n),k("filter",e,t,n),[o,l],s,[u,p],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Eq=(e,t,n,r=en)=>{switch(e.op){case"Fill":{let a=k("shape",e,t,n),s=k("dtype",e,t,n),i=k("value",e,t,n);return[r.fill(a,i,s)]}case"LinSpace":{let a=k("start",e,t,n),s=k("stop",e,t,n),i=k("num",e,t,n);return[r.linspace(a,s,i)]}case"Multinomial":{let a=k("logits",e,t,n),s=k("numSamples",e,t,n),i=k("seed",e,t,n);return[r.multinomial(a,s,i)]}case"OneHot":{let a=k("indices",e,t,n),s=k("depth",e,t,n),i=k("onValue",e,t,n),o=k("offValue",e,t,n),l=k("dtype",e,t,n);return[r.oneHot(a,s,i,o,l)]}case"Ones":return[r.ones(k("shape",e,t,n),k("dtype",e,t,n))];case"OnesLike":return[r.onesLike(k("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(k("shape",e,t,n),k("dtype",e,t,n),k("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(k("shape",e,t,n),k("minval",e,t,n),k("maxval",e,t,n),k("dtype",e,t,n))];case"RandomUniformInt":return[r.randomUniformInt(k("shape",e,t,n),k("minval",e,t,n),k("maxval",e,t,n),k("seed",e,t,n))];case"Range":{let a=k("start",e,t,n),s=k("stop",e,t,n),i=k("step",e,t,n);return[r.range(a,s,i,k("dtype",e,t,n))]}case"TruncatedNormal":{let a=k("shape",e,t,n),s=k("mean",e,t,n),i=k("stdDev",e,t,n),o=k("seed",e,t,n);return[r.truncatedNormal(a,s,i,k("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(k("shape",e,t,n),k("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(k("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function ob(e,t,n){let r=k("boxes",e,t,n),a=k("scores",e,t,n),s=k("maxOutputSize",e,t,n),i=k("iouThreshold",e,t,n),o=k("scoreThreshold",e,t,n),l=k("softNmsSigma",e,t,n);return{boxes:r,scores:a,maxOutputSize:s,iouThreshold:i,scoreThreshold:o,softNmsSigma:l}}var $q=async(e,t,n,r,a=en)=>{switch(e.op){case"NonMaxSuppressionV5":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u,softNmsSigma:p}=ob(e,t,n),h=await a.image.nonMaxSuppressionWithScoreAsync(s,i,o,l,u,p);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u}=ob(e,t,n),p=k("padToMaxOutputSize",e,t,n),h=await a.image.nonMaxSuppressionPaddedAsync(s,i,o,l,u,p);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u}=ob(e,t,n);return[await a.image.nonMaxSuppressionAsync(s,i,o,l,u)]}case"Where":{let s=a.cast(k("condition",e,t,n),"bool"),i=[await a.whereAsync(s)];return s.dispose(),i}case"ListDiff":return a.setdiff1dAsync(k("x",e,t,n),k("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}},Aq=(e,t,n,r=en)=>{switch(e.op){case"LowerBound":{let a=k("sortedSequence",e,t,n),s=k("values",e,t,n);return[r.lowerBound(a,s)]}case"TopKV2":{let a=k("x",e,t,n),s=k("k",e,t,n),i=k("sorted",e,t,n),o=r.topk(a,s,i);return[o.values,o.indices]}case"UpperBound":{let a=k("sortedSequence",e,t,n),s=k("values",e,t,n);return[r.upperBound(a,s)]}case"Unique":{let a=k("x",e,t,n),s=r.unique(a);return[s.values,s.indices]}case"UniqueV2":{let a=k("x",e,t,n),s=k("axis",e,t,n),i=r.unique(a,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Fq=(e,t,n,r=en)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let a=k("default",e,t,n);return[nn(e.name,t,n)||a];case"Placeholder":return[nn(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let p=k("x",e,t,n);return[oa(p)]}case"IdentityN":return k("x",e,t,n).map(p=>oa(p));case"Snapshot":let s=k("x",e,t,n);return[oa(s)];case"Shape":return[r.tensor1d(k("x",e,t,n).shape,"int32")];case"ShapeN":return k("x",e,t,n).map(p=>r.tensor1d(p.shape));case"Size":return[r.scalar(k("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(k("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":let i=k("x",e,t,n),o=k("data",e,t,n),l=k("message",e,t,n),u=k("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let p=0;p<o.length;p++)console.log(Array.prototype.slice.call(o[p].dataSync()).slice(0,u));return[i];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Rq=class{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=ve(0),this.tensorMap=new Map,zt(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return ve(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),B(()=>{let r=Tt(t),a=n.length,s=r.length;w.assert(a===s,()=>`The number of elements doesn't match, keys has ${a} elements, the values has ${s} elements.`);for(let i=0;i<a;i++){let o=n[i],l=r[i];zt(l),this.tensorMap.set(o,l)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return B(()=>{let r=[];for(let a=0;a<n.length;a++){let s=n[a],i=this.findWithDefault(s,t);r.push(i)}return Dt(r)})}findWithDefault(e,t){let n=this.tensorMap.get(e);return n!=null?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}},Dq=async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{let a=r.getHashTableHandleByName(e.name);if(a!=null)return[a];{let s=k("keyDType",e,t,n),i=k("valueDType",e,t,n),o=new Rq(s,i);return r.addHashTable(e.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let a=k("tableHandle",e,t,n,r),s=k("keys",e,t,n),i=k("values",e,t,n);return[await r.getHashTableById(a.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let a=k("tableHandle",e,t,n,r),s=k("keys",e,t,n),i=k("defaultValue",e,t,n);return[await r.getHashTableById(a.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let a=k("tableHandle",e,t,n,r);return[r.getHashTableById(a.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Mq=(e,t,n,r=en)=>{switch(e.op){case"ResizeBilinear":{let a=k("images",e,t,n),s=k("size",e,t,n),i=k("alignCorners",e,t,n),o=k("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(a,[s[0],s[1]],i,o)]}case"ResizeNearestNeighbor":{let a=k("images",e,t,n),s=k("size",e,t,n),i=k("alignCorners",e,t,n),o=k("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(a,[s[0],s[1]],i,o)]}case"CropAndResize":{let a=k("image",e,t,n),s=k("boxes",e,t,n),i=k("boxInd",e,t,n),o=k("cropSize",e,t,n),l=k("method",e,t,n),u=k("extrapolationValue",e,t,n);return[r.image.cropAndResize(a,s,i,o,l,u)]}case"ImageProjectiveTransformV3":{let a=k("images",e,t,n),s=k("transforms",e,t,n),i=k("outputShape",e,t,n),o=k("fillValue",e,t,n),l=k("interpolation",e,t,n),u=k("fillMode",e,t,n);return[r.image.transform(a,s,l.toLowerCase(),u.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Oq=(e,t,n,r=en)=>{switch(e.op){case"Equal":return[r.equal(k("a",e,t,n),k("b",e,t,n))];case"NotEqual":return[r.notEqual(k("a",e,t,n),k("b",e,t,n))];case"Greater":return[r.greater(k("a",e,t,n),k("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(k("a",e,t,n),k("b",e,t,n))];case"Less":return[r.less(k("a",e,t,n),k("b",e,t,n))];case"LessEqual":return[r.lessEqual(k("a",e,t,n),k("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(k("a",e,t,n),k("b",e,t,n))];case"LogicalNot":return[r.logicalNot(k("a",e,t,n))];case"LogicalOr":return[r.logicalOr(k("a",e,t,n),k("b",e,t,n))];case"Select":case"SelectV2":return[r.where(k("condition",e,t,n),k("a",e,t,n),k("b",e,t,n))];case"BitwiseAnd":return[r.bitwiseAnd(k("a",e,t,n),k("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Lq=(e,t,n,r=en)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(k("a",e,t,n),k("b",e,t,n),k("transposeA",e,t,n),k("transposeB",e,t,n))];case"Einsum":return[r.einsum(k("equation",e,t,n),...k("tensors",e,t,n))];case"Transpose":return[r.transpose(k("x",e,t,n),k("perm",e,t,n))];case"_FusedMatMul":let[a,s]=k("fusedOps",e,t,n),i=a==="biasadd",o=s==="prelu",l=k("numArgs",e,t,n),u=k("leakyreluAlpha",e,t,n);if(i){if(o&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[p,h]=k("args",e,t,n);return[r.fused.matMul({a:k("a",e,t,n),b:k("b",e,t,n),transposeA:k("transposeA",e,t,n),transposeB:k("transposeB",e,t,n),bias:p,activation:s,preluActivationWeights:h,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(k("a",e,t,n),k("numLower",e,t,n),k("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},zq=(e,t,n,r=en)=>{switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(k("x",e,t,n),k("axis",e,t,n),k("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(k("x",e,t,n),k("mean",e,t,n),k("variance",e,t,n),k("offset",e,t,n),k("scale",e,t,n),k("epsilon",e,t,n))];case"FusedBatchNormV3":return[r.batchNorm(k("x",e,t,n),k("mean",e,t,n),k("variance",e,t,n),k("offset",e,t,n),k("scale",e,t,n),k("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(k("x",e,t,n),k("radius",e,t,n),k("bias",e,t,n),k("alpha",e,t,n),k("beta",e,t,n))];case"Softmax":return[r.softmax(k("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(k("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Pq=(e,t,n,r=en)=>{switch(e.op){case"RaggedGather":{let{outputNestedSplits:a,outputDenseValues:s}=r.raggedGather(k("paramsNestedSplits",e,t,n),k("paramsDenseValues",e,t,n),k("indices",e,t,n),k("outputRaggedRank",e,t,n));return a.concat(s)}case"RaggedRange":{let{rtNestedSplits:a,rtDenseValues:s}=r.raggedRange(k("starts",e,t,n),k("limits",e,t,n),k("splits",e,t,n));return[a,s]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(k("shape",e,t,n),k("values",e,t,n),k("defaultValue",e,t,n),k("rowPartitionTensors",e,t,n),k("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Bq=(e,t,n,r=en)=>{switch(e.op){case"Max":{let o=k("axis",e,t,n),l=k("keepDims",e,t,n);return[r.max(k("x",e,t,n),o,l)]}case"Mean":{let o=k("axis",e,t,n),l=k("keepDims",e,t,n);return[r.mean(k("x",e,t,n),o,l)]}case"Min":{let o=k("axis",e,t,n),l=k("keepDims",e,t,n);return[r.min(k("x",e,t,n),o,l)]}case"Sum":{let o=k("axis",e,t,n),l=k("keepDims",e,t,n);return[r.sum(k("x",e,t,n),o,l)]}case"All":{let o=k("axis",e,t,n),l=k("keepDims",e,t,n);return[r.all(k("x",e,t,n),o,l)]}case"Any":{let o=k("axis",e,t,n),l=k("keepDims",e,t,n);return[r.any(k("x",e,t,n),o,l)]}case"ArgMax":{let o=k("axis",e,t,n);return[r.argMax(k("x",e,t,n),o)]}case"ArgMin":{let o=k("axis",e,t,n);return[r.argMin(k("x",e,t,n),o)]}case"Prod":{let o=k("axis",e,t,n),l=k("keepDims",e,t,n);return[r.prod(k("x",e,t,n),o,l)]}case"Cumprod":{let o=k("axis",e,t,n),l=k("exclusive",e,t,n),u=k("reverse",e,t,n);return[r.cumprod(k("x",e,t,n),o,l,u)]}case"Cumsum":{let o=k("axis",e,t,n),l=k("exclusive",e,t,n),u=k("reverse",e,t,n);return[r.cumsum(k("x",e,t,n),o,l,u)]}case"Bincount":let a=k("x",e,t,n),s=k("weights",e,t,n),i=k("size",e,t,n);return[r.bincount(a,s,i)];case"DenseBincount":{let o=k("x",e,t,n),l=k("weights",e,t,n),u=k("size",e,t,n),p=k("binaryOutput",e,t,n);return[r.denseBincount(o,l,u,p)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Wq=(e,t,n,r=en)=>{switch(e.op){case"ConcatV2":case"Concat":{let a=k("n",e,t,n),s=k("axis",e,t,n),i=k("tensors",e,t,n);return i=i.slice(0,a),[r.concat(i,s)]}case"Gather":{let a=k("x",e,t,n),s=k("indices",e,t,n);return[r.gather(a,r.cast(s,"int32"),0)]}case"GatherV2":{let a=k("axis",e,t,n),s=k("batchDims",e,t,n),i=k("x",e,t,n),o=k("indices",e,t,n);return[r.gather(i,r.cast(o,"int32"),a,s)]}case"Reverse":{let a=k("dims",e,t,n),s=[];for(let o=0;o<a.length;o++)a[o]&&s.push(o);let i=k("x",e,t,n);return[r.reverse(i,s)]}case"ReverseV2":{let a=k("axis",e,t,n),s=k("x",e,t,n);return[r.reverse(s,a)]}case"Slice":{let a=k("begin",e,t,n),s=k("size",e,t,n);return[r.slice(k("x",e,t,n),a,s)]}case"StridedSlice":{let a=k("begin",e,t,n),s=k("end",e,t,n),i=k("strides",e,t,n),o=k("beginMask",e,t,n),l=k("endMask",e,t,n),u=k("ellipsisMask",e,t,n),p=k("newAxisMask",e,t,n),h=k("shrinkAxisMask",e,t,n),d=k("x",e,t,n);return[r.stridedSlice(d,a,s,i,o,l,u,p,h)]}case"Pack":return B(()=>{let a=k("axis",e,t,n),s=k("tensors",e,t,n),i=s[0].shape,o=r.squeeze(s[0]).shape,l=s.map(u=>{let p=w.arraysEqual(u.shape,i);if(!p&&!w.arraysEqual(r.squeeze(u).shape,o))throw new Error("the input tensors shape does not match");return p?u:r.reshape(u,i)});return[r.stack(l,a)]});case"Unpack":{let a=k("axis",e,t,n),s=k("tensor",e,t,n);return r.unstack(s,a)}case"Tile":{let a=k("reps",e,t,n);return[r.tile(k("x",e,t,n),a)]}case"Split":case"SplitV":{let a=k("axis",e,t,n),s=k("numOrSizeSplits",e,t,n),i=k("x",e,t,n);return r.split(i,s,a)}case"ScatterNd":{let a=k("indices",e,t,n),s=k("values",e,t,n),i=k("shape",e,t,n);return[r.scatterND(a,s,i)]}case"GatherNd":{let a=k("x",e,t,n),s=k("indices",e,t,n);return[r.gatherND(a,s)]}case"SparseToDense":{let a=k("sparseIndices",e,t,n),s=k("outputShape",e,t,n),i=k("sparseValues",e,t,n),o=k("defaultValue",e,t,n);return[r.sparseToDense(a,i,s,i.dtype===o.dtype?o:r.cast(o,i.dtype))]}case"TensorScatterUpdate":{let a=k("indices",e,t,n),s=k("values",e,t,n),i=k("tensor",e,t,n);return[r.tensorScatterUpdate(i,a,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Vq=(e,t,n,r=en)=>{switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:a,outputValues:s,emptyRowIndicator:i,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(k("indices",e,t,n),k("values",e,t,n),k("denseShape",e,t,n),k("defaultValue",e,t,n));return[a,s,i,o]}case"SparseReshape":{let{outputIndices:a,outputShape:s}=r.sparse.sparseReshape(k("inputIndices",e,t,n),k("inputShape",e,t,n),k("newShape",e,t,n));return[a,s]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(k("data",e,t,n),k("indices",e,t,n),k("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(k("data",e,t,n),k("indices",e,t,n),k("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Uq=(e,t,n,r=en)=>{switch(e.op){case"FFT":return[r.fft(k("x",e,t,n))];case"IFFT":return[r.ifft(k("x",e,t,n))];case"RFFT":return[r.rfft(k("x",e,t,n))];case"IRFFT":return[r.irfft(k("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Gq=(e,t,n,r=en)=>{switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(k("input",e,t,n),k("pattern",e,t,n),k("rewrite",e,t,n),k("replaceGlobal",e,t,n))];case"StringNGrams":{let{nGrams:a,nGramsSplits:s}=r.string.stringNGrams(k("data",e,t,n),k("dataSplits",e,t,n),k("separator",e,t,n),k("nGramWidths",e,t,n),k("leftPad",e,t,n),k("rightPad",e,t,n),k("padWidth",e,t,n),k("preserveShortSequences",e,t,n));return[a,s]}case"StringSplit":{let{indices:a,values:s,shape:i}=r.string.stringSplit(k("input",e,t,n),k("delimiter",e,t,n),k("skipEmpty",e,t,n));return[a,s,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(k("input",e,t,n),k("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Hq=(e,t,n,r=en)=>{switch(e.op){case"Cast":return[r.cast(k("x",e,t,n),k("dtype",e,t,n))];case"ExpandDims":{let a=k("axis",e,t,n);return[r.expandDims(k("x",e,t,n),a)]}case"Squeeze":{let a=k("axis",e,t,n);return[r.squeeze(k("x",e,t,n),a)]}case"Reshape":return[r.reshape(k("x",e,t,n),k("shape",e,t,n))];case"EnsureShape":return[r.ensureShape(k("x",e,t,n),k("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(k("x",e,t,n),k("padding",e,t,n),k("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(k("x",e,t,n),k("padding",e,t,n),k("constantValue",e,t,n))];case"SpaceToBatchND":{let a=k("blockShape",e,t,n),s=k("paddings",e,t,n);return[r.spaceToBatchND(k("x",e,t,n),a,s)]}case"BatchToSpaceND":{let a=k("blockShape",e,t,n),s=k("crops",e,t,n);return[r.batchToSpaceND(k("x",e,t,n),a,s)]}case"DepthToSpace":{let a=k("blockSize",e,t,n),s=k("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(k("x",e,t,n),a,s)]}case"BroadcastTo":return[r.broadcastTo(k("x",e,t,n),k("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(k("s0",e,t,n),k("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function uI(e,t,n,r,a=B){let s=((i,o,l)=>{switch(i.category){case"arithmetic":return a(()=>vq(i,o,l));case"basic_math":return a(()=>wq(i,o,l));case"control":return Cq(i,o,l);case"convolution":return a(()=>_q(i,o,l));case"creation":return a(()=>Eq(i,o,l));case"dynamic":return $q(i,o,l);case"evaluation":return a(()=>Aq(i,o,l));case"image":return a(()=>Mq(i,o,l));case"graph":return a(()=>Fq(i,o,l));case"logical":return a(()=>Oq(i,o,l));case"matrices":return a(()=>Lq(i,o,l));case"normalization":return a(()=>zq(i,o,l));case"ragged":return a(()=>Pq(i,o,l));case"reduction":return a(()=>Bq(i,o,l));case"slice_join":return a(()=>Wq(i,o,l));case"sparse":return a(()=>Vq(i,o,l));case"spectral":return a(()=>Uq(i,o,l));case"string":return a(()=>Gq(i,o,l));case"transformation":return a(()=>Hq(i,o,l));case"hash_table":return Dq(i,o,l,r);case"custom":let u=iC(i.op);if(u&&u.customExecutor)return u.customExecutor(new xq(i,o,l));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return w.isPromise(s)?s.then(i=>[].concat(i)):[].concat(s)}var pI=class{constructor(e={},t={},n={},r={},a){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function dI(e,t,n,r){let a=new Set,s=[],i=null,o=null,l=new Set,u=new Set(Object.keys(e).map(d=>Bn(d)[0]));r=r||[];let p=new Set(r.map(d=>Bn(d.name)[0])),h=[...t];for(;h.length>0;){let d=h.pop();if((Rs(d)||Qq(d)||e5(d))&&i==null&&(i=d,o=i.children.map(c=>c.name).filter(c=>a.has(c))),a.add(d.name),n[d.name]==null&&!u.has(d.name)&&!p.has(d.name)){if(d.inputs.length===0){s.push(d.name);continue}d.inputs.forEach(c=>{l.has(c.name)||(l.add(c.name),h.push(c))})}}return{inputs:e,outputs:t,usedNodes:a,missingInputs:s,dynamicNode:i,syncInputs:o}}function jq(e,t){let{usedNodes:n,inputs:r}=t,a=Object.keys(r).map(g=>Bn(g)[0]).map(g=>e.nodes[g]),s=e.initNodes||[],i=g=>n.has(typeof g=="string"?g:g.name);function o(g){return[...new Map(g.map(y=>[y.name,y])).values()]}let l=o([...a,...e.weights,...s]).filter(i),u=o([...l,...Object.values(e.nodes)]).filter(i),p=new Map(u.map(g=>[g.name,g])),h={};for(let g of u){h[g.name]=h[g.name]||0;for(let y of g.children)i(y)||(h[y.name]=Number.POSITIVE_INFINITY),h[y.name]=(h[y.name]||0)+1}let d=Object.entries(h).filter(([,g])=>g===0).map(([g])=>g),c=[...d];for(;d.length>0;){let g=d.pop(),y=p.get(g);for(let b of y.children.filter(i))--h[b.name]===0&&(c.push(b.name),d.push(b.name))}let m=c.map(g=>p.get(g)),f=qq(m,l);return Kq(f,l),f}function qq(e,t){let n=new Map(e.map(s=>[s.name,s])),r=t.map(s=>s.name),a=new Set(r);for(;r.length>0;){let s=r.pop(),i=n.get(s);for(let o of i.children)!n.has(o.name)||a.has(o.name)||(a.add(o.name),r.push(o.name))}return e.filter(s=>a.has(s.name))}var Ah=class extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}};function Kq(e,t){let n=new Map(e.map((o,l)=>[o.name,l])),r=new Set(t.map(o=>o.name)),a=o=>r.has(typeof o=="string"?o:o.name),s=new Set(e.map(o=>o.name)),i=o=>s.has(typeof o=="string"?o:o.name);for(let o of e){for(let l of o.children.filter(i)){if(!n.has(l.name))throw new Ah(`Child ${l.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(l.name))throw new Ah(`Node ${o.name} is scheduled to run after its child ${l.name}.`)}if(!a(o))for(let l of o.inputs){if(!n.has(l.name))throw new Ah(`Input ${l.name} of node ${o.name} is unreachable.`);if(n.get(l.name)>n.get(o.name))throw new Ah(`Node ${o.name} is scheduled to run before its input ${l.name}.`)}}}function Xq(e){let t=new Map(e.map((o,l)=>[o.name,l])),n=Number.MAX_SAFE_INTEGER,r=e.map((o,l)=>Rs(o)?n:l),a=o=>{let l=r[t.get(o.name)];return l==null?-1:l},s=e.map((o,l)=>o.children.map(a).reduce((u,p)=>Math.max(u,p),r[l])),i=new Map;for(let o=0;o<e.length;++o){let l=s[o];if(l===n)continue;let u=e[o],p=e[l];i.has(p.name)||i.set(p.name,[]),i.get(p.name).push(u)}return i}var Zq=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Jq=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Yq=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Rs(e){return Zq.has(e.op)}function Qq(e){return Jq.has(e.op)}function e5(e){return Yq.has(e.op)}var hI=class _C{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){let n=Object.keys(t).map(r=>t[r].map(a=>a.id));this._weightIds=[].concat(...n),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{let n=t.signatureKey||t.name;return t.defaultOutput?`${n}:${t.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((t,n)=>(t[n]=this._functions[n].signature,t),{})}constructor(t,n){this.graph=t,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(r=>{this._functionExecutorMap[r]=new _C(t.functions[r],this)})}getCompilationKey(t,n){let r=t.map(s=>s.name).sort(),a=n.map(s=>s.name).sort();return r.join(this.SEPARATOR)+"--"+a.join(this.SEPARATOR)}compile(t,n){let r=dI(t,n,this.weightMap,this._initNodes),{missingInputs:a,dynamicNode:s,syncInputs:i}=r;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(a.length>0){let u=n.map(h=>h.name),p=Object.keys(t);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${p}]. Missing the following inputs: [${a}]`)}let o=jq(this.graph,r),l=Xq(o);return{orderedNodes:o,nodeLiveUntilMap:l}}cloneAndKeepTensor(t){if(t==null)return null;let n=t.clone();return zt(n),n}cloneTensorList(t){return t?t.map(n=>this.cloneAndKeepTensor(n)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([n,r])=>[n,this.cloneTensorList(r)]))}execute(t,n){this.disposeIntermediateTensors(),t=this.mapInputs(t);let r=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n);let a=r.map(d=>this.graph.nodes[Bn(d)[0]]),s=n.map(d=>Bn(d)[0]),i=new Set(s),o=s.map(d=>this.graph.nodes[d]);o.length===0&&(o=this._outputs);let l=this.getCompilationKey(a,o),u=this.compiledMap.get(l);u==null&&(u=this.compile(t,o),this.compiledMap.set(l,u));try{this.keepIntermediateTensors=G().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}let p={},h={};return B(()=>{let d=new pI(this.weightMap,p,h,this.functionExecutorMap,this.parseNodeNameCache),c=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(y=>{let[b,x]=Bn(y,d),v=[];v[x]=t[y],c[b]=v,this.keepIntermediateTensors&&(this.clonedTensorsMap[b]=this.cloneTensorList(v))});let m=this.getFrozenTensorIds(c),{orderedNodes:f,nodeLiveUntilMap:g}=u;for(let y of f){if(c[y.name])continue;let b=uI(y,c,d,this._resourceManager);if(w.isPromise(b))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);c[y.name]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[y.name]=this.cloneTensorList(b)),this.checkTensorForDisposalWithNodeLiveUntilInfo(y,c,d,m,i,g.get(y.name))}return this.parent==null&&d.dispose(m),n.map(y=>nn(y,c,d))})}getFrozenTensorIds(t){let n=[].concat.apply([],Object.keys(t).map(r=>t[r]).map(r=>r.map(a=>a.id)));return new Set(n)}checkTensorForDisposal(t,n,r,a,s,i,o){if(!(Rs(n)||i.has(t))){for(let l of r[t])l!=null&&(o[l.id]=(o[l.id]||0)+n.children.length);for(let l of n.inputs){if(Rs(l))continue;let u=aI(l.name,r,a);if(u!=null)for(let p of u){if(!p||p.kept||s.has(p.id))continue;let h=o[p.id];h===1?(p.dispose(),delete o[p.id]):h!=null&&o[p.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,n,r,a,s,i){function o(l){return Rs(l)||s.has(l.name)}if(!(Rs(t)||i==null))for(let l of i){if(o(l))continue;let u=aI(l.name,n,r);for(let p of u)!p||p.kept||a.has(p.id)||p.dispose()}}async executeAsync(t,n){return this._executeAsync(t,n)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(let n of t)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(t,n,r=!1,a={},s={}){this.disposeIntermediateTensors(),r||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=G().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}let i=new pI(this.weightMap,a,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let o=await this.executeWithControlFlow(t,i,n,r),l=n.map(d=>nn(d,o,i)),u=l.map(d=>d.id),p=Object.keys(t).map(d=>t[d].id),h=new Set([...u,...p,...this.weightIds]);return Object.values(o).forEach(d=>{d.forEach(c=>{c&&!c.isDisposed&&!h.has(c.id)&&c.dispose()})}),this.parent==null&&i.dispose(h),l}async executeFunctionAsync(t,n,r){let a=t.reduce((s,i,o)=>(s[this.inputs[o].name]=i,s),{});return this._executeAsync(a,this.outputNodes,!0,n,r)}async executeWithControlFlow(t,n,r,a){let s=Object.keys(t),i=s.map(v=>this.graph.nodes[Bn(v)[0]]),o=r.map(v=>Bn(v)[0]),l=new Set(o),u=o.map(v=>this.graph.nodes[v]);u.length===0&&(u=this._outputs);let{usedNodes:p,missingInputs:h,dynamicNode:d,syncInputs:c}=dI(t,u,this.weightMap,this._initNodes),m=[...i,...this.graph.weights,...this._initNodes||[]].map(v=>({node:v,contexts:n.currentContext})),f=Object.assign({},this.weightMap);Object.keys(t).forEach(v=>{let[I,N]=Bn(v),C=[];C[N]=t[v],f[I]=C});let g={},y=this.getFrozenTensorIds(f),b={};for(;m.length>0;){let v=this.processStack(i,m,n,f,b,y,l,g,p);await Promise.all(v)}d==null&&!a&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let x=u.filter(v=>!Rs(v)&&!nn(v.name,f,n)).map(v=>v.name);if(x.length>0){let v="";throw d!=null&&(v=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${c}]`),new Error(`Cannot compute the outputs [${x}] from the provided inputs [${s}]. Consider providing the following inputs: [${h}]. ${v}`)}return f}processStack(t,n,r,a,s,i,o,l,u){let p=[];for(;n.length>0;){let h=n.pop();r.currentContext=h.contexts;let d="";if(h.node.op==="Enter"&&k("isConstant",h.node,a,r)&&([d]=ia(h.node.name,r)),a[h.node.name]==null){let c=uI(h.node,a,r,this._resourceManager);d||([d]=ia(h.node.name,r));let m=r.currentContext;w.isPromise(c)?p.push(c.then(f=>(a[d]=f,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(f)),r.currentContext=m,this.checkTensorForDisposal(d,h.node,a,r,i,o,l),this.processChildNodes(h.node,n,r,a,s,u),f))):(a[d]=c,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(c)),this.checkTensorForDisposal(d,h.node,a,r,i,o,l),this.processChildNodes(h.node,n,r,a,s,u))}else this.processChildNodes(h.node,n,r,a,s,u)}return p}processChildNodes(t,n,r,a,s,i){t.children.forEach(o=>{let[l]=ia(o.name,r);s[l]||!i.has(o.name)||(o.op==="Merge"?o.inputNames.some(u=>!!nn(u,a,r))&&(s[l]=!0,n.push({contexts:r.currentContext,node:o})):o.inputNames.every(u=>!!nn(u,a,r))&&(s[l]=!0,n.push({contexts:r.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(n=>n.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(n=>{let r=t[n],[a]=Bn(n),s=this.graph.nodes[a];if(s.attrParams.shape&&s.attrParams.shape.value){let i=s.attrParams.shape.value,o=i.length===r.shape.length&&r.shape.every((l,u)=>i[u]===-1||i[u]===l);w.assert(o,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${i}], but was [${r.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&w.assert(r.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(t){var n,r;let a={};for(let s in t){let i=(r=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||r===void 0?void 0:r[s];i!=null?a[i.name]=t[s]:a[s]=t[s]}return a}checkInputs(t){let n=Object.keys(t).filter(r=>{let[a]=Bn(r);return this.graph.nodes[a]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(t){return t.map(n=>{var r,a;let s=(a=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||a===void 0?void 0:a[n];return s!=null?s.name:n},{})}checkOutputs(t){t.forEach(n=>{let[r]=Bn(n);if(!this.graph.nodes[r])throw new Error(`The output '${n}' is not found in the graph`)})}},t5=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}},n5="?tfjs-format=file",r5="model.json",R0=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},n=an){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,t==null&&(this.loadOptions={}),this.resourceManager=new t5}findIOHandler(){let e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return w.isPromise(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){let t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");let t=await AS(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;let n=this.artifacts.modelTopology,r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let a=this.artifacts.userDefinedMetadata;a.signature!=null&&(r=a.signature),a.structuredOutputKeys!=null&&(this.structuredOutputKeys=a.structuredOutputKeys)}if(this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new hI(sI.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){let a=sI.Instance.transformGraph(e.modelInitializer);this.initializer=new hI(a),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){let n=this.io.getSaveHandlers(e);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);e=n[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t=e instanceof Re?[e]:e,n={};return t.forEach((r,a)=>n[this.structuredOutputKeys[a]]=r),n}return e}predict(e,t){let n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){let n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof Re)&&!Array.isArray(e)){let a=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(a!=null)for(let s in a){let i=a[s];i.resourceId!=null&&(e[s]=this.resourceIdToCapturedInput[i.resourceId])}return e}e=Array.isArray(e)?e:[e];let n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((a,s)=>{var i,o,l;let u=(l=(o=(i=this.signature)===null||i===void 0?void 0:i.inputs)===null||o===void 0?void 0:o[s])===null||l===void 0?void 0:l.resourceId;return u!=null?a[s]=this.resourceIdToCapturedInput[u]:a[s]=e[r++],a},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){let a=n[r],s=t[a];this.resourceIdToCapturedInput[s.resourceId]=e[r]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Ce(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function a5(e,t={},n=an){if(e==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof e=="string"&&(e=i5(e));let r=new R0(e,t,n);return await r.load(),r}function s5(e){if(e==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){let[r,a]=e;if(!r)throw new Error("modelJSON must be the first element of the array");if(!a||!(a instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in r))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in r))throw new Error("Model JSON is missing 'weightsManifest'");let s=an.getWeightSpecs(r.weightsManifest),i=an.getModelArtifactsForJSONSync(r,s,a);t=an.fromMemorySync(i)}else if("load"in e)t=e;else if("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e)t=an.fromMemorySync(e);else throw new Error("Unknown model format");let n=new R0(t);return n.load(),n}function i5(e){return e.endsWith("/")||(e=e+"/"),`${e}${r5}${n5}`}var o5="4.22.0",EC={};_e(EC,{CSVDataset:()=>BC,Dataset:()=>Ou,FileDataSource:()=>qC,TextLineDataset:()=>PC,URLDataSource:()=>KC,array:()=>$5,csv:()=>U5,func:()=>G5,generator:()=>H5,microphone:()=>q5,version_data:()=>K5,webcam:()=>j5,zip:()=>A5});var l5=ss(Cc()),u5=ss(Cc());function p5(e,t){return gc(e,t)}function gc(e,t,n=new Map,r=new Set){if(e==null)return null;if(typeof Blob=="function"&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);let a=t(e);if(a.recurse&&a.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(a.recurse)if(yl(e)){let s=Array.isArray(e)?[]:{};r.add(e);for(let i in e){let o=e[i],l=gc(o,t,n,r);s[i]=l}return r.delete(e),e.__proto__&&(s.__proto__=e.__proto__),s}else throw new Error(`Can't recurse into non-iterable type: ${e}`);else return n.set(e,a.value),a.value}function d5(e,t=AC){return $C(e,t)}function $C(e,t,n=new Set){let r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");let a=t(e);if(a.recurse&&a.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(a.recurse)if(yl(r)){let s=Array.isArray(r)?[]:{};n.add(r);for(let i in r){let o=e.map(u=>u[i]),l=$C(o,t,n);s[i]=l}return n.delete(r),s}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return a.value}function AC(e){return e===null?null:yl(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function FC(e,t){let n=new Map;gc(e,t,n);for(let r of Array.from(n.keys())){let a=n.get(r);if(w.isPromise(a)){let s=await a;n.set(r,s)}}return gc(e,t,n)}function yl(e){let t=!1;if(G().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=YI();t=e instanceof n}return e!=null&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||typeof e=="object"&&!(e instanceof Re)&&!(e instanceof Promise)&&!t)}function h5(e){return e==null||c5(e)||Array.isArray(e)||typeof e=="object"&&e instanceof Re||w.isTypedArray(e)}function c5(e){return e===null||typeof e!="object"&&typeof e!="function"}function m5(e){return p5(e,f5)}function f5(e){return e instanceof Re?{value:e.clone(),recurse:!1}:yl(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var RC=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},DC=class MC extends RC{constructor(){super(MC.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){let t=this.capacity*2,n=new Array(t),r=this.length();for(let a=0;a<r;a++)n[a]=this.get(this.wrap(this.begin+a));this.data=n,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=r}};DC.INITIAL_CAPACITY=32;function OC(e){return new b5(e)}function D0(e){return new x5(e)}function g5(e,t){return new LC(e,t)}function y5(e,t=za.FAIL){return new _5(e,t)}var Qt=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new T5(this,e)}filter(e){return new S5(this,e)}map(e){return new N5(this,e)}mapAsync(e){return new cI(this,e)}serialMapAsync(e){return new cI(this,e).serial()}flatmap(e){return new C5(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new I5(this,e,t)}columnMajorBatch(e,t=!0,n=AC){return this.rowMajorBatch(e,t).map(r=>d5(r,n))}concatenate(e,t){return new LC(OC([this,e]),t)}take(e){return e<0||e==null?this:new k5(this,e)}skip(e){return e<0||e==null?this:new w5(this,e)}prefetch(e){return new zC(this,e)}shuffle(e,t){return new E5(this,e,t)}serial(){return new v5(this)}},b5=class extends Qt{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:m5(e),done:!1}}},x5=class extends Qt{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}},v5=class extends Qt{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},w5=class extends Qt{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;Ce(e.value)}return this.upstream.next()}},k5=class extends Qt{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},I5=class extends Qt{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},S5=class extends Qt{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Ce(e.value)}}},N5=class extends Qt{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Sr.getTensorsInContainer(e.value),n=this.transform(e.value),r=Sr.getTensorsInContainer(n);for(let a of t)Sr.isTensorInList(a,r)||a.dispose();return{value:n,done:!1}}},T5=class extends Qt{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}},cI=class extends Qt{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Sr.getTensorsInContainer(e.value),n=await this.transform(e.value),r=Sr.getTensorsInContainer(n);for(let a of t)Sr.isTensorInList(a,r)||a.dispose();return{value:n,done:!1}}},M0=class extends Qt{constructor(){super(),this.outputQueue=new DC,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},C5=class extends M0{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=Sr.getTensorsInContainer(e.value),n=this.transform(e.value),r=Sr.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let a of t)Sr.isTensorInList(a,r)||a.dispose();return!0}},LC=class extends Qt{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){let n=await this.moreIterators.next();if(n.done)return{value:null,done:!0};this.iterator=n.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}},za;(function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"})(za||(za={}));var _5=class extends Qt{constructor(e,t=za.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;function r(s){return s instanceof Qt?{value:s.next().then(i=>(t++,i.done&&n++,i.value)),recurse:!1}:{value:null,recurse:!0}}let a=await FC(this.iterators,r);if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case za.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case za.SHORTEST:return{value:null,done:!0};case za.LONGEST:default:}return this.count++,{value:a,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},zC=class extends Qt{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new RC(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},E5=class extends zC{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=u5.alea(n||w.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}},Ou=class{constructor(){this.size=null}batch(e,t=!0){let n=this;w.assert(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let r;return this.size===1/0||this.size==null?r=this.size:t?r=Math.ceil(this.size/e):r=Math.floor(this.size/e),Pn(async()=>(await n.iterator()).columnMajorBatch(e,t,F5),r)}concatenate(e){let t=this,n;return this.size===1/0||e.size===1/0?n=1/0:this.size!=null&&e.size!=null?n=this.size+e.size:n=null,Pn(async()=>(await t.iterator()).concatenate(await e.iterator()),n)}filter(e){let t=this,n;return this.size===1/0?n=1/0:n=null,Pn(async()=>(await t.iterator()).filter(r=>B(()=>e(r))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return Pn(async()=>(await t.iterator()).map(n=>B(()=>e(n))),this.size)}mapAsync(e){let t=this;return Pn(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return Pn(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){let t=this,n;return this.size!=null&&e>0?n=this.size*e:e===0?n=0:this.size!=null&&(e===void 0||e<0)?n=1/0:n=null,Pn(async()=>{let r=D0(async()=>({value:await t.iterator(),done:!1}));return g5(r.take(e))},n)}skip(e){let t=this,n;return this.size!=null&&e>=0&&this.size>=e?n=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?n=0:n=null,Pn(async()=>(await t.iterator()).skip(e),n)}shuffle(e,t,n=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let r=this,a=l5.alea(t||w.now().toString());return Pn(async()=>{let s=a.int32();return n&&(s+=a.int32()),(await r.iterator()).shuffle(e,s.toString())},this.size)}take(e){let t=this,n;return this.size!=null&&this.size>e?n=e:this.size!=null&&this.size<=e?n=this.size:n=null,Pn(async()=>(await t.iterator()).take(e),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};Ou.MAX_BUFFER_SIZE=1e4;function Pn(e,t=null){return new class extends Ou{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function $5(e){return Pn(async()=>OC(e),e.length)}function A5(e){if(!yl(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=t==null?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=t==null?e[n].size:Math.min(t,e[n].size);return Pn(async()=>{let n=await FC(e,r=>{if(r instanceof Ou)return{value:r.iterator(),recurse:!1};if(yl(r))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return y5(n,za.SHORTEST)},t)}function F5(e){if(e===null)return null;let t=e[0];return h5(t)?{value:R5(e),recurse:!1}:{value:null,recurse:!0}}function R5(e){if(e.length===0)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof Re?Dt(e):yn(e)}var PC=class extends Ou{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e))}},Fh='"',op=Symbol("out"),mI=Symbol("field"),Rh=Symbol("quote"),lb=Symbol("quoteafterquote"),fI=Symbol("quoteinquote"),BC=class extends Ou{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&w.assert(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce((r,a)=>(r[a]=r[a]+1||1,r),{}),n=Object.keys(t).filter(r=>t[r]>1);if(w.assert(n.length===0,()=>"Duplicate column names found: "+n.toString()),this.columnConfigs){for(let r of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(r)===-1)throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");let t=e.value;return this.parseRow(t,!1)}else return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new PC(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(w.assert(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){let t=this.parseRow(e),n={},r={};for(let a=0;a<this.fullColumnNames.length;a++){let s=this.fullColumnNames[a],i=this.columnConfigs?this.columnConfigs[s]:null;if(!(this.configuredColumnsOnly&&!i)){let o=t[a],l=null;if(o==="")if(i&&i.default!==void 0)l=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${s} is empty in this line: ${e}`);l=void 0}else{let u=Number(o);if(isNaN(u))i&&i.dtype==="bool"?l=this.getBoolean(o):l=o;else if(!i||!i.dtype)l=u;else switch(i.dtype){case"float32":l=u;break;case"int32":l=Math.floor(u);break;case"bool":l=this.getBoolean(o);break;default:l=u}}i&&i.isLabel?r[s]=l:n[s]=l}}return Object.keys(r).length===0?n:{xs:n,ys:r}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){let n=[],r=0,a=e.length,s=op;for(let i=0;i<a;i++)switch(s){case op:switch(e.charAt(i)){case Fh:r=i+1,s=Rh;break;case this.delimiter:if(r=i+1,this.delimiter===" "&&this.delimWhitespace)break;n.push(""),s=op;break;default:s=mI,r=i;break}break;case mI:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(r,i)),s=op,r=i+1;break;default:}break;case Rh:switch(e.charAt(i)){case Fh:s=lb;break;default:}break;case lb:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(r,i-1)),s=op,r=i+1;break;case Fh:s=Rh;break;default:s=fI;break}break;case fI:switch(e.charAt(i)){case Fh:s=Rh;break;default:}break;default:}if(s===lb?n.push(e.substring(r,a-1)):n.push(e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},D5=class WC extends Qt{constructor(t){super(),this.microphoneConfig=t,this.isClosed=!1,this.fftSize=t.fftSize||1024;let n=Math.log2(this.fftSize);if(this.fftSize<0||n<4||n>14||!Number.isInteger(n))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=t.numFramesPerSpectrogram||43,this.sampleRateHz=t.sampleRateHz,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.audioTrackConstraints=t.audioTrackConstraints,this.smoothingTimeConstant=t.smoothingTimeConstant||0,this.includeSpectrogram=t.includeSpectrogram!==!1,this.includeWaveform=t.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(t={}){if(!G().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let n=new WC(t);return await n.start(),n}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(r){throw new Error(`Error thrown while initializing video stream: ${r.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let t=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new t,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let n=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,n.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let t,n,r=await this.getAudioData();if(this.includeSpectrogram){let a=this.flattenQueue(r.freqDataQueue);t=this.getTensorFromAudioDataArray(a,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let a=this.flattenQueue(r.timeDataQueue);n=this.getTensorFromAudioDataArray(a,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:t,waveform:n},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let t=[],n=[],r=0;return new Promise(a=>{let s=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&a({freqDataQueue:t,timeDataQueue:n}),t.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),n.push(this.timeData.slice())),++r===this.numFrames&&(clearInterval(s),a({freqDataQueue:t,timeDataQueue:n}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(t){let n=t[0].length,r=new Float32Array(t.length*n);return t.forEach((a,s)=>r.set(a,s*n)),r}getTensorFromAudioDataArray(t,n){let r=new Float32Array(w.sizeFromShape(n));return r.set(t,r.length-t.length),yn(r,n)}},M5=class VC extends Qt{constructor(t,n){if(super(),this.webcamVideoElement=t,this.webcamConfig=n,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Qe([0],"int32"),this.webcamConfig.centerCrop){let r=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,a=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,s=(1-r)/2,i=(1-a)/2,o=s+r,l=a+i;this.cropBox=Gr([i,s,l,o],[1,4])}else this.cropBox=Gr([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(t,n={}){if(!G().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!n.resizeWidth||!n.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=n.resizeWidth,t.height=n.resizeHeight}let r=new VC(t,n);return await r.start(),r}async start(){this.webcamConfig.facingMode&&w.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(t){throw t.message=`Error thrown while initializing video stream: ${t.message}`,t}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(t){console.log(t),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(t=>{this.webcamVideoElement.onloadedmetadata=()=>{t()}})}async next(){if(this.isClosed)return{value:null,done:!0};let t;try{t=Rd.fromPixels(this.webcamVideoElement)}catch(n){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(n)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(t),done:!1}}catch(n){throw new Error(`Error thrown cropping the video: ${n.message}`)}finally{t.dispose()}else return{value:t,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(t){return B(()=>{let n=Xt(oe(t,"float32"),0),r;r=er.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let a=r.shape;return P(r,a.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},UC=class{},GC=class extends Qt{split(e){return new O5(this,e)}},O5=class extends GC{constructor(e,t){super(),this.upstream=e,this.impl=new L5(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},L5=class extends M0{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}},z5=class extends Qt{decodeUTF8(){return new P5(this)}},P5=class extends GC{constructor(e){super(),this.upstream=e,this.impl=new B5(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},B5=class extends M0{constructor(e){if(super(),this.upstream=e,G().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:t}=YI();this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e=await this.upstream.next(),t;if(e.done)return!1;t=e.value;let n;return G().get("IS_BROWSER")?n=this.decoder.decode(t,{stream:!0}):n=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0}},HC=class extends z5{constructor(e,t={}){super(),this.file=e,this.options=t,w.assert(e instanceof Uint8Array||(G().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((e,t)=>{let n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{let r=new FileReader;r.onload=s=>{let i=r.result;if(i instanceof ArrayBuffer&&(i=new Uint8Array(i)),!(i instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(i)},r.onabort=s=>t(new Error("Aborted")),r.onerror=s=>t(new Error(s.type));let a=this.file.slice(this.offset,n);r.readAsArrayBuffer(a)}this.offset=n}),done:!1}}};async function W5(e,t={},n){let r,a;typeof e=="string"?r=e:(r=e.url,a=V5(e));let s=await(n||w.fetch)(r,a);if(s.ok){let i=new Uint8Array(await s.arrayBuffer());return new HC(i,t)}else throw new Error(s.statusText)}var V5=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function jC(e){return typeof e=="string"&&e.slice(0,7)==="file://"}var qC=class extends UC{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(jC(this.input)&&G().get("IS_NODE")){let e=Nx();this.input=e.readFileSync(this.input.slice(7))}return new HC(this.input,this.options)}},KC=class extends UC{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return jC(this.url)?new qC(this.url,this.fileOptions).iterator():W5(this.url,this.fileOptions)}};function U5(e,t={}){return new BC(new KC(e),t)}function G5(e){let t=D0(e);return Pn(async()=>t)}function H5(e){return Pn(async()=>{let t=await e();return D0(()=>t.next())})}async function j5(e,t){return M5.create(e,t)}async function q5(e){return D5.create(e)}var K5="4.22.0";function ge(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&w.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var X5=Qr.whereImpl,O0=class XC extends Hp{nextDataId(){return XC.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new _c(this,cr())}write(t,n,r){this.firstUse&&(this.firstUse=!1,G().get("IS_NODE")&&T.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let a={id:this.nextDataId()};return this.data.set(a,{values:t,dtype:r,refCount:1}),a}makeTensorInfo(t,n,r){let a;if(n==="string"&&r!=null&&r.length>0&&w.isString(r[0])){let s=r.map(i=>w.encodeString(i));a=this.write(s,t,n)}else a=this.write(r,t,n);return{dataId:a,shape:t,dtype:n}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){let n=this.data.get(t);n.refCount++}decRef(t){if(this.data.has(t)){let n=this.data.get(t);n.refCount--}}move(t,n,r,a,s){this.data.set(t,{values:n,dtype:a,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){let{dtype:n,complexTensorInfos:r}=this.data.get(t);if(n==="complex64"){let a=this.readSync(r.real.dataId),s=this.readSync(r.imag.dataId);return T.mergeRealAndImagArrays(a,s)}return w.convertBackendValuesAndArrayBuffer(this.data.get(t).values,n)}bufferSync(t){let n=this.readSync(t.dataId);if(t.dtype==="string")try{let r=n.map(a=>w.decodeString(a));return Oe(t.shape,t.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Oe(t.shape,t.dtype,n)}makeOutput(t,n,r){return cr().makeTensorFromTensorInfo(this.makeTensorInfo(n,r,t),this)}disposeData(t,n=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!n&&this.data.get(t).refCount>0)return!1;let{complexTensorInfos:r}=this.data.get(t);r!=null&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){let n=w.now();return t(),{kernelMs:w.now()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){ge([t],"where");let n=this.readSync(t.dataId);return X5(t.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};O0.nextDataId=0;var L0={};_e(L0,{addImpl:()=>YC,bincountImpl:()=>P0,bincountReduceImpl:()=>QC,bitwiseAndImpl:()=>e_,castImpl:()=>JC,ceilImpl:()=>t_,concatImpl:()=>B0,equalImpl:()=>n_,expImpl:()=>a_,expm1Impl:()=>i_,floorDivImpl:()=>l_,floorImpl:()=>o_,gatherNdImpl:()=>u_,gatherV2Impl:()=>p_,greaterEqualImpl:()=>h_,greaterImpl:()=>d_,lessEqualImpl:()=>m_,lessImpl:()=>c_,linSpaceImpl:()=>f_,logImpl:()=>g_,maxImpl:()=>y_,maximumImpl:()=>b_,minimumImpl:()=>x_,multiplyImpl:()=>W0,negImpl:()=>v_,notEqualImpl:()=>w_,prodImpl:()=>k_,raggedGatherImpl:()=>I_,raggedRangeImpl:()=>S_,raggedTensorToTensorImpl:()=>N_,rangeImpl:()=>U0,rsqrtImpl:()=>T_,scatterImpl:()=>Os,sigmoidImpl:()=>KK,simpleAbsImpl:()=>ZC,sliceImpl:()=>bc,sparseFillEmptyRowsImpl:()=>__,sparseReshapeImpl:()=>E_,sparseSegmentReductionImpl:()=>G0,sqrtImpl:()=>JK,squaredDifferenceImpl:()=>$_,staticRegexReplaceImpl:()=>A_,stridedSliceImpl:()=>F_,stringNGramsImpl:()=>H0,stringSplitImpl:()=>j0,stringToHashBucketFastImpl:()=>q0,subImpl:()=>R_,tileImpl:()=>D_,topKImpl:()=>O_,transposeImpl:()=>V0,uniqueImpl:()=>X0});function ZC(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}var Z5=e=>{let{x:t}=e.inputs,n=e.backend;ge(t,"abs");let r=new Float32Array(w.sizeFromShape(t.shape)),a=n.data.get(t.dataId).values;return r=ZC(a),n.makeOutput(r,t.shape,t.dtype)},J5={kernelName:Sl,backendName:"cpu",kernelFunc:Z5};function _t(e){return(t,n,r,a,s)=>{let i=T.assertAndGetBroadcastShape(t,n),o=i.length,l=w.computeStrides(i),u=w.sizeFromShape(i),p=w.getTypedArrayFromDType(s,u),h=t.length,d=n.length,c=w.computeStrides(t),m=w.computeStrides(n),f=T.getBroadcastDims(t,i),g=T.getBroadcastDims(n,i);if(f.length+g.length===0)for(let y=0;y<p.length;++y)p[y]=e(r[y%r.length],a[y%a.length]);else for(let y=0;y<p.length;++y){let b=w.indexToLoc(y,o,l),x=b.slice(-h);f.forEach(C=>x[C]=0);let v=w.locToIndex(x,h,c),I=b.slice(-d);g.forEach(C=>I[C]=0);let N=w.locToIndex(I,d,m);p[y]=e(r[v],a[N])}return[p,i]}}function Wn(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=n.makeTensorInfo(r.shape,"complex64"),l=n.data.get(o.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",s),imag:n.makeTensorInfo(a.shape,"float32",i)},o}var Y5={kernelName:Ac,backendName:"cpu",kernelFunc:Wn};function yc(e,t,n="float32"){if(n==="complex64"){let a=yc(e,t,"float32"),s=yc(e,t,"float32");return Wn({inputs:{real:a,imag:s},backend:e})}let r=w.makeZerosTypedArray(w.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function Xr(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var Q5={kernelName:Oi,backendName:"cpu",kernelFunc:Xr};function Qs(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.real,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}var eK={kernelName:Uc,backendName:"cpu",kernelFunc:Qs};function JC(e,t,n,r){if(r==="int32"){let a=Int32Array.from(e);return[t,"int32",a]}if(r==="bool"){let a=w.toTypedArray([0],n),[s,i]=_t((o,l)=>o!==l?1:0)(t,[],e,a,"bool");return[i,"bool",s]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function rs(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if(s==="complex64"){if(a.dtype==="complex64")return Xr({inputs:{x:a},backend:n});let p=yc(n,a.shape,a.dtype),h=rs({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),d=Wn({inputs:{real:h,imag:p},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),d}if(a.dtype==="complex64"){let p=Qs({inputs:{input:a},backend:n}),h=rs({inputs:{x:p},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(p),h}if(!w.hasEncodingLoss(a.dtype,s)){let p=Xr({inputs:{x:a},backend:n});return{dataId:p.dataId,shape:p.shape,dtype:s}}let i=n.data.get(a.dataId).values,[o,l,u]=JC(i,a.shape,a.dtype,s);return n.makeTensorInfo(o,l,u)}var tK={kernelName:yi,backendName:"cpu",kernelFunc:rs};function Ut(e,t,n,r){return n==null?({inputs:a,backend:s})=>{let{a:i,b:o}=a,l=s;ge([i,o],e);let u=l.data.get(i.dataId).values,p=l.data.get(o.dataId).values,h=i.dtype==="string"?T.fromUint8ToStringArray(u):u,d=i.dtype==="string"?T.fromUint8ToStringArray(p):p,c=r||i.dtype,[m,f]=t(i.shape,o.shape,h,d,c);return l.makeTensorInfo(f,c,m)}:({inputs:a,backend:s})=>{let{a:i,b:o}=a,l=s;if(i.dtype==="complex64"||o.dtype==="complex64"){let u=rs({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),p=l.data.get(u.dataId),h=p.complexTensorInfos.real,d=p.complexTensorInfos.imag,c=l.data.get(h.dataId).values,m=l.data.get(d.dataId).values,f=rs({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(f.dataId),y=g.complexTensorInfos.real,b=g.complexTensorInfos.imag,x=l.data.get(y.dataId).values,v=l.data.get(b.dataId).values,[I,N,C]=n(i.shape,o.shape,c,m,x,v),E=l.makeTensorInfo(C,"float32",I),A=l.makeTensorInfo(C,"float32",N),R=Wn({inputs:{real:E,imag:A},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(f),l.disposeIntermediateTensorInfo(E),l.disposeIntermediateTensorInfo(A),R}else{let u=l.data.get(i.dataId).values,p=l.data.get(o.dataId).values,h=r||i.dtype,[d,c]=t(i.shape,o.shape,u,p,h);return l.makeTensorInfo(c,h,d)}}}function z0(e){return(t,n,r,a,s,i)=>{let o=T.assertAndGetBroadcastShape(t,n),l=w.sizeFromShape(o),u=o.length,p=w.computeStrides(o),h=w.getTypedArrayFromDType("float32",l),d=w.getTypedArrayFromDType("float32",l),c=T.getBroadcastDims(t,o),m=T.getBroadcastDims(n,o),f=T.mergeRealAndImagArrays(r,a),g=T.mergeRealAndImagArrays(s,i),y=t.length,b=w.computeStrides(t),x=n.length,v=w.computeStrides(n);if(c.length+m.length===0)for(let I=0;I<h.length;I++){let N=I%f.length,C=I%g.length,E=e(f[N*2],f[N*2+1],g[C*2],g[C*2+1]);h[I]=E.real,d[I]=E.imag}else for(let I=0;I<h.length;I++){let N=w.indexToLoc(I,u,p),C=N.slice(-y);c.forEach(S=>C[S]=0);let E=w.locToIndex(C,y,b),A=N.slice(-x);m.forEach(S=>A[S]=0);let R=w.locToIndex(A,x,v),F=e(f[E*2],f[E*2+1],g[R*2],g[R*2+1]);h[I]=F.real,d[I]=F.imag}return[h,d,o]}}var YC=_t((e,t)=>e+t),nK=z0((e,t,n,r)=>({real:e+n,imag:t+r})),bl=Ut(is,YC,nK),rK={kernelName:is,backendName:"cpu",kernelFunc:bl};function P0(e,t,n,r,a){let s=w.sizeFromShape(r),i=w.makeZerosTypedArray(a,n);for(let o=0;o<e.length;o++){let l=e[o];if(l<0)throw new Error("Input x must be non-negative!");l>=a||(s>0?i[l]+=t[o]:i[l]+=1)}return i}function QC(e,t,n,r=!1){let a=e.shape[0],s=e.shape[1],i=Oe([a,n],t.dtype);for(let o=0;o<a;o++)for(let l=0;l<s;l++){let u=e.get(o,l);if(u<0)throw new Error("Input x must be non-negative!");u>=n||(r?i.set(1,o,u):t.size>0?i.set(i.get(o,u)+t.get(o,l),o,u):i.set(i.get(o,u)+1,o,u))}return i}var e_=_t((e,t)=>e&t),aK=Ut(Fl,e_),sK={kernelName:Fl,backendName:"cpu",kernelFunc:aK};function ea(e){return(t,n,r)=>{let a=w.getArrayFromDType(n,t.length);for(let s=0;s<t.length;++s)a[s]=e(t[s],r);return a}}function at(e,t,n){let r=ea(t);return fs(e,r,n)}function fs(e,t,n){return({inputs:r,attrs:a,backend:s})=>{let{x:i}=r;ge(i,e);let o=s,l=o.data.get(i.dataId).values,u;if(i.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=T.fromUint8ToStringArray(l)}else u=l;let p=n||i.dtype,h=t(u,p,a);return o.makeTensorInfo(i.shape,p,h)}}var t_=ea(e=>Math.ceil(e)),iK=fs(bi,t_),oK={kernelName:bi,backendName:"cpu",kernelFunc:iK};function B0(e,t,n,r){let a=w.getArrayFromDType(n,w.sizeFromShape(t));if(r&&n!=="string"){let s=0;e.forEach(i=>{let o=w.sizeFromShape(i.shape);a.set(i.vals,s),s+=o})}else{let s=0;e.forEach(i=>{let o=n==="string"?T.fromUint8ToStringArray(i.vals):i.vals,l=0;for(let u=0;u<i.shape[0];++u){let p=u*t[1]+s;for(let h=0;h<i.shape[1];++h)a[p+h]=o[l++]}s+=i.shape[1]})}return a}var n_=_t((e,t)=>e===t?1:0),r_=Ut(Bl,n_,null,"bool"),lK={kernelName:Bl,backendName:"cpu",kernelFunc:r_},a_=ea(e=>Math.exp(e)),s_=fs($i,a_,"float32"),uK={kernelName:$i,backendName:"cpu",kernelFunc:s_},i_=ea(e=>Math.expm1(e)),pK=fs(Ai,i_),dK={kernelName:Ai,backendName:"cpu",kernelFunc:pK},o_=ea(e=>Math.floor(e)),hK=fs(Fi,o_),cK={kernelName:Fi,backendName:"cpu",kernelFunc:hK},l_=_t((e,t)=>Math.floor(e/t)),mK=Ut(Ri,l_,null,"int32"),fK={kernelName:Ri,backendName:"cpu",kernelFunc:mK};function u_(e,t,n,r,a,s,i,o,l){let u=Oe([r,s],n);for(let p=0;p<r;p++){let h=[],d=0;for(let c=0;c<a;c++){let m=e[p*a+c];d+=m*i[c],h.push(m)}if(d<0||d>=l/s)throw new Error(`Invalid indices: ${h} does not index into ${o}`);for(let c=0;c<s;c++)u.values[p*s+c]=t.get(...t.indexToLoc(d*s+c))}return u}function p_(e,t,n){let r=Oe(n,e.dtype);for(let a=0;a<r.size;++a){let s=r.indexToLoc(a).slice(),i=s[0],o=s[2],l=t.locToIndex([i,o]);s[2]=t.values[l];let u=e.locToIndex(s);0<=u&&u<e.values.length&&(r.values[a]=e.values[u])}return r}var d_=_t((e,t)=>e>t?1:0),gK=Ut(Hl,d_,null,"bool"),yK={kernelName:Hl,backendName:"cpu",kernelFunc:gK},h_=_t((e,t)=>e>=t?1:0),bK=Ut(Mi,h_,null,"bool"),xK={kernelName:Mi,backendName:"cpu",kernelFunc:bK},c_=_t((e,t)=>e<t?1:0),vK=Ut(jl,c_,null,"bool"),wK={kernelName:jl,backendName:"cpu",kernelFunc:vK},m_=_t((e,t)=>e<=t?1:0),kK=Ut(ql,m_,null,"bool"),IK={kernelName:ql,backendName:"cpu",kernelFunc:kK};function f_(e,t,n){let r=(t-e)/(n-1),a=w.makeZerosTypedArray(n,"float32");a[0]=e;for(let s=1;s<a.length;s++)a[s]=a[s-1]+r;return a}var g_=ea(e=>Math.log(e)),SK=fs(Wi,g_),NK={kernelName:Wi,backendName:"cpu",kernelFunc:SK};function y_(e,t,n,r){let a=w.getTypedArrayFromDType(r,w.sizeFromShape(n));for(let s=0;s<a.length;++s){let i=s*t,o=e[i];for(let l=0;l<t;++l){let u=e[i+l];(Number.isNaN(u)||u>o)&&(o=u)}a[s]=o}return a}var b_=_t((e,t)=>Math.max(e,t)),TK=Ut(Hi,b_),CK={kernelName:Hi,backendName:"cpu",kernelFunc:TK},x_=_t((e,t)=>Math.min(e,t)),_K=Ut(Xi,x_),EK={kernelName:Xi,backendName:"cpu",kernelFunc:_K},W0=_t((e,t)=>e*t),$K=z0((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n})),Xm=Ut(Yi,W0,$K),AK={kernelName:Yi,backendName:"cpu",kernelFunc:Xm};function v_(e,t,n){let r=w.createScalarValue(-1,n);return W0([],t,r,e,n)}function FK(e){let{inputs:t,backend:n}=e,{x:r}=t;ge(r,"neg");let a=n.data.get(r.dataId).values,[s,i]=v_(a,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,s)}var RK={kernelName:tu,backendName:"cpu",kernelFunc:FK},w_=_t((e,t)=>e!==t?1:0),DK=Ut(nu,w_,null,"bool"),MK={kernelName:nu,backendName:"cpu",kernelFunc:DK};function V0(e,t,n,r,a){let s=t.length,i=w.sizeFromShape(t),o=w.computeStrides(t),l=w.computeStrides(a),u=w.getTypedArrayFromDType(n,w.sizeFromShape(a));for(let p=0;p<i;++p){let h=w.indexToLoc(p,s,o),d=new Array(h.length);for(let m=0;m<d.length;m++)d[m]=h[r[m]];let c=w.locToIndex(d,s,l);u[c]=e[p]}return u}function Dn(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{perm:s}=n;ge(a,"transpose");let i=a.shape.length,o=new Array(i);for(let p=0;p<o.length;p++)o[p]=a.shape[s[p]];let l=r.data.get(a.dataId).values,u=V0(l,a.shape,a.dtype,s,o);return{dataId:r.write(u,o,a.dtype),shape:o,dtype:a.dtype}}var OK={kernelName:ua,backendName:"cpu",kernelFunc:Dn};function k_(e,t,n,r){let[a,s]=T.computeOutAndReduceShapes(e,r),i=sr(t,"int32"),o=w.makeZerosTypedArray(w.sizeFromShape(a),i),l=w.sizeFromShape(s);for(let u=0;u<o.length;++u){let p=u*l,h=1;for(let d=0;d<l;++d)h*=n[p+d];o[u]=h}return{outVals:o,outShape:a,outDtype:i}}function LK(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;ge(a,"prod");let o=a.shape.length,l=w.parseAxisParam(s,a.shape),u=T.getAxesPermutation(l,o),p=l,h=a,d=[];u!=null&&(h=Dn({inputs:{x:a},backend:n,attrs:{perm:u}}),d.push(h),p=T.getInnerMostAxes(p.length,o));let c=n.data.get(h.dataId).values,{outVals:m,outShape:f,outDtype:g}=k_(h.shape,h.dtype,c,p),y=f;return i&&(y=T.expandShapeToKeepDim(f,l)),d.forEach(b=>n.disposeIntermediateTensorInfo(b)),n.makeTensorInfo(y,g,m)}var zK={kernelName:ro,backendName:"cpu",kernelFunc:LK};function PK(e,t,n){e.forEach((r,a)=>{if(r<0||r>=n){let s=w.indexToLoc(a,t.length,w.computeStrides(t)).join(",");throw new Error(`indices[${s}] = ${r} is not in [0, ${n})`)}})}function BK(e,t){for(let n=0;n<e.length;++n){let r=e[n],a=n===e.length-1?t:e[n+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>a)throw new Error("Ragged splits must not point past values");for(let s=1;s<r.length;++s)if(r[s-1]>r[s])throw new Error("Ragged splits must be sorted in ascending order")}}function WK(e,t,n,r){let a=[],s=0,i=t.length-1+n.length,o=new Array(i).fill(null).map(()=>[0]);BK(n,r);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];let p=t[u+1];for(let h=1;h<l+1;++h)o[u].push(h*p)}for(let u=0;u<e.length;++u){let p=e[u],h=e[u]+1;for(let d=0;d<n.length;++d){let c=n[d],m=d+t.length-1;if(m>=0){let f=o[m],g=f[f.length-1]-c[p];for(let y=p;y<h;++y)o[m].push(c[y+1]+g)}p=c[p],h=c[h]}h!==p&&(a.push([p,h]),s+=h-p)}return{outSplits:o,valueSlices:a,numValues:s}}function VK(e){let t=[];for(let n=0;n<e.length;++n){let r=e[n].length,a=w.getArrayFromDType("int32",r);t.push(a),e[n].forEach((s,i)=>a[i]=s)}return t}function gI(e,t){let n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function UK(e,t,n,r,a,s){let i=gI(t,2)[1],o=gI(s,2)[1],l=0;for(let u of n)for(let p=u[0];p<u[1];++p){for(let h=0;h<r;++h)a[l*o+h]=e[p*i+h];++l}}function GK(e,t,n,r,a){let s=t.slice();s[0]=a;let i=w.getArrayFromDType(n,w.sizeFromShape(s)),o=e.length,l=o===0?0:o/t[0];return UK(e,t,r,l,i,s),[i,s]}function I_(e,t,n,r,a,s,i,o){if(e.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");let l=t[0][0]-1;if(PK(s,i,l),r.length===0)throw new Error("params.rank must be nonzero");let u=r[0],{outSplits:p,valueSlices:h,numValues:d}=WK(s,i,e,u),c=VK(p),m=GK(n,r,a,h,d);return[c,m[0],m[1]]}var yI=2147483647;function S_(e,t,n,r,a,s,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(a.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");let o=t.length===0,l=a.length===0,u=i.length===0,p=[];o||p.push(t[0]),l||p.push(a[0]),u||p.push(i[0]);for(let g=1;g<p.length;++g)if(p[g]!==p[g-1])throw new Error("starts, limits, and deltas must have the same shape");let h=p.length===0?1:p[0],d=w.getArrayFromDType("int32",h+1);d[0]=0;for(let g=0;g<h;++g){let y=o?e[0]:e[g],b=l?r[0]:r[g],x=u?s[0]:s[g];if(x===0)throw new Error("Requires delta != 0");let v;if(x>0&&b<y||x<0&&b>y)v=0;else if(v=Math.ceil(Math.abs((b-y)/x)),v>yI)throw new Error(`Requires ((limit - start) / delta) <= ${yI}`);d[g+1]=d[g]+v}let c=d[h],m=w.getArrayFromDType(n,c),f=0;for(let g=0;g<h;++g){let y=d[g+1]-d[g],b=o?e[0]:e[g],x=u?s[0]:s[g];for(let v=0;v<y;++v)m[f++]=b,b+=x}return[d,m]}var hr=T.RowPartitionType,HK=class ex{constructor(t,n,r,a,s,i,o,l,u,p){this.shape=t,this.shapeShape=n,this.values=r,this.valuesShape=a,this.valuesDType=s,this.defaultValue=i,this.defaultValueShape=o,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=T.getRowPartitionTypesHelper(p),this.raggedRank=T.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===hr.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===hr.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){let n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case hr.VALUE_ROWIDS:return ex.getMaxWidthValueRowID(n);case hr.ROW_SPLITS:return ex.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${hr[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){let n=t.length;if(n===0||n===1)return 0;let r=0;for(let a=0;a<n-1;++a){let s=t[a+1]-t[a];s>r&&(r=s)}return r}static getMaxWidthValueRowID(t){let n=t.length;if(n===0)return 0;let r=0,a=t[0],s=0;for(let i=1;i<n;++i){let o=t[i];o!==a&&(a=o,s=Math.max(i-r,s),r=i)}return Math.max(n-r,s)}tensorShapeFromTensor(t,n,r=!0){if(n.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return xI(t,r)}calculateOutputSize(t){let n=this.valuesShape,r=this.defaultValueShape;T.validateDefaultValueShape(r,n);let a=this.tensorShapeFromTensor(this.shape,this.shapeShape),s=T.combineRaggedTensorToTensorShapes(this.raggedRank,a,n);s[0]<0&&(s[0]=t);for(let i=1;i<=this.raggedRank;++i)s[i]<0&&(s[i]=this.getMaxWidth(i));return s}calculateFirstParentOutputIndex(t,n,r){let a=Math.min(t,r),s=[],i=0;for(let o=0;o<a;++o,i+=n)s.push(i);for(let o=a;o<t;++o)s.push(-1);return w.assert(s.length===t,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(t,n,r,a){let s=t.length,i=[];for(let o=0;o<s-1;++o){let l=t[o+1]-t[o],u=Math.min(a,l),p=n[o];p===-1&&(u=0);for(let h=0;h<u;++h)i.push(p),p+=r;for(let h=0;h<l-u;++h)i.push(-1)}if(s>0&&i.length!==t[s-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(t,n,r,a){let s=t.length,i=[];if(s===0)return[];let o=0,l=t[0];if(l>=n.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`);let u=n[l];i.push(u);for(let p=1;p<s;++p){let h=t[p];if(h===l)u>=0&&(++o,o<a?u+=r:u=-1);else{if(o=0,l=h,h>=n.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${n.length}`);u=n[h]}i.push(u)}if(i.length!==t.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(t,n,r,a){let s=this.getRowPartitionTensor(t),i=this.getRowPartitionTypeByDimension(t);switch(i){case hr.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,n,r,a);case hr.ROW_SPLITS:if(s.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(s,n,r,a);default:throw new Error(`Unsupported partition type: ${hr[i]}`)}}getFirstDimensionSize(){let t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let n=this.rowPartitionTypes[0];switch(n){case hr.FIRST_DIM_SIZE:return t[0];case hr.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case hr.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${hr[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let t=this.getFirstDimensionSize(),n=this.calculateOutputSize(t),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let i=r.length-2;i>=0;--i)r[i]=r[i+1]*n[i+1];let a=xI(n,!1),s=w.getArrayFromDType(this.valuesDType,w.sizeFromShape(a));if(r[0]*n[0]>0){let i=this.calculateFirstParentOutputIndex(t,r[0],n[0]);for(let o=1;o<=this.raggedRank;++o)i=this.calculateOutputIndex(o-1,i,r[o],n[o]);this.setOutput(this.raggedRank,i,s,a)}return[a,s]}setOutput(t,n,r,a){if(r.length===0)return;let s=this.values,i=r,o=a.slice();o=o.slice(t+1);let l=w.sizeFromShape(o),u=n.length,p=this.defaultValue;if(p.length!==l&&p.length!==1){let m=this.defaultValueShape;B(()=>{let f=P(p,m);p=Ls(f,o).dataSync()})}let h=0,d=0,c=0;for(let m=0;m<=u;++m){let f=m<u?n[m]:-1;if(f===c){++c;continue}if(d<c){let g=s.subarray(h*l),y=i.subarray(d*l),b=(c-d)*l;bI(y,g,b)}if(m>=u){let g=r.length;f=Math.floor(g/l)}if(f>c)if(this.defaultValue.length===1)i.subarray(c*l,f*l).fill(this.defaultValue[0]),c=f;else for(;f>c;){let g=i.slice(c*l);bI(g,p,l),++c}f<0?(h=m+1,d=c):(h=m,d=c,c=d+1)}}};function bI(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function xI(e,t){let n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function N_(e,t,n,r,a,s,i,o,l,u){return new HK(e,t,n,r,a,s,i,o,l,u).compute()}function U0(e,t,n,r){let a=e===t,s=e<t&&n<0,i=t<e&&n>1;if(a||s||i)return w.makeZerosTypedArray(0,r);let o=Math.abs(Math.ceil((t-e)/n)),l=w.makeZerosTypedArray(o,r);t<e&&n===1&&(n=-1),l[0]=e;for(let u=1;u<l.length;u++)l[u]=l[u-1]+n;return l}var T_=ea(e=>1/Math.sqrt(e)),jK=fs(ho,T_),qK={kernelName:ho,backendName:"cpu",kernelFunc:jK};function Os(e,t,n,r,a,s,i,o,l,u){let p=[r/a,a],h=e.values,d=t.values;if(r===0)return Oe(n,t.dtype);let c=l instanceof Rt?l:Oe(p,t.dtype);typeof l=="string"||typeof l=="number"?c.values.fill(l):typeof l=="boolean"&&c.values.fill(+l);for(let m=0;m<s;m++){let f=[],g=0;for(let y=0;y<i;y++){let b=h[m*i+y];f.push(b),g+=b*o[y]}if(g<0||g>=r/a)throw new Error(`Invalid indices: ${f} does not index into ${n}`);for(let y=0;y<a;y++)u?c.values[g*a+y]+=d[m*a+y]:c.values[g*a+y]=t.rank===0?d[0]:d[m*a+y]}return c}var KK=ea(e=>1/(1+Math.exp(-e))),C_=at(yo,e=>1/(1+Math.exp(-e))),XK={kernelName:yo,backendName:"cpu",kernelFunc:C_};function bc(e,t,n,r,a){let s=Bt.isSliceContinous(r,t,n),i=w.sizeFromShape(n),o=w.computeStrides(r);if(s){let h=Bt.computeFlatOffset(t,o);return a==="string"?e.slice(h,h+i):e.subarray(h,h+i)}let l=a==="string"?T.fromUint8ToStringArray(e):e,u=Oe(r,a,l),p=Oe(n,a);for(let h=0;h<p.size;++h){let d=p.indexToLoc(h),c=d.map((m,f)=>m+t[f]);p.set(u.get(...c),...d)}return a==="string"?T.fromStringArrayToUint8(p.values):p.values}function ei(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r;ge(a,"slice");let[o,l]=Bt.parseSliceParams(a,s,i);Bt.assertParamsValid(a,o,l);let u=n.data.get(a.dataId).values,p=bc(u,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,p)}var ZK={kernelName:fu,backendName:"cpu",kernelFunc:ei};function __(e,t,n,r,a,s,i){let o=t[0],l=s[0],u=new Array(l),p=new Array(o),h=t[1];if(l===0){if(o!==0)throw new Error(T.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));let g=w.getArrayFromDType(n,0),y=w.getArrayFromDType(a,0);return[g,[0,h],y,u,p]}let d=!0,c=0,m=new Array(l).fill(0);for(let g=0;g<o;++g){let y=e[g*h];if(y<0)throw new Error(T.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,y));if(y>=l)throw new Error(T.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,y,l));++m[y],d=d&&y>=c,c=y}let f=!0;for(let g=0;g<l;++g){let y=m[g]===0;u[g]=y,f=f&&!y,m[g]=Math.max(m[g],1),g>0&&(m[g]+=m[g-1])}if(f&&d){let g=e,y=r;for(let b=0;b<o;++b)p[b]=b;return[g,[o,h],y,u,p]}else{let g=m[l-1],y=w.getArrayFromDType(n,g*h),b=w.getArrayFromDType(a,g),x=new Array(l).fill(0);for(let v=0;v<o;++v){let I=e[v*h],N=x[I],C=(I===0?0:m[I-1])+N;x[I]++;for(let E=0;E<h;++E)y[C*h+E]=e[v*h+E];b[C]=r[v],p[v]=C}for(let v=0;v<l;++v)if(x[v]===0){let I=v===0?0:m[v-1];y[I*h+0]=v;for(let N=1;N<h;++N)y[I*h+N]=0;b[I]=i}return[y,[g,h],b,u,p]}}function E_(e,t,n,r,a){let s=w.sizeFromShape(r),i=t[0],o=a.length,l=[],u=1,p=-1;for(let f=0;f<o;++f){let g=a[f];if(g===-1){if(p!==-1)throw new Error(T.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(p,f));p=f,l.push(1)}else{if(g<0)throw new Error(T.getSparseReshapeNegativeOutputDimErrorMessage(f,g));u*=g,l.push(g)}}if(p!==-1){if(u<=0)throw new Error(T.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let f=Math.trunc(s/u);if(u*f!==s)throw new Error(T.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[p]=f}if(w.sizeFromShape(l)!==s)throw new Error(T.getSparseReshapeInputOutputMismatchErrorMessage(r,l));let h=r.length,d=[];if(h>0){d[h-1]=1;for(let f=h-2;f>=0;--f)d[f]=d[f+1]*r[f+1]}let c=[];if(o>0){c[o-1]=1;for(let f=o-2;f>=0;--f)c[f]=c[f+1]*l[f+1]}let m=w.getArrayFromDType(n,i*o);for(let f=0;f<i;++f){let g=0;for(let y=0;y<h;++y)g+=e[f*h+y]*d[y];for(let y=0;y<o;++y)m[f*o+y]=Math.trunc(g/c[y]),g%=c[y]}return[m,[i,o],l]}function G0(e,t,n,r,a,s=!1,i=0){let o=r.length,l=[t[0],e.length/t[0]],u=l[1],p=o>0?a[o-1]+1:0;if(p<0)throw new Error(T.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let h=t.slice();h[0]=p;let d=h.reduce((b,x)=>b*x,1),c=w.getArrayFromDType(n,d);if(o===0)return p>0&&c.fill(i),[c,h];if(p<=0)throw new Error(T.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let m=0,f=1,g=0,y=a[m];for(;;){let b=0;if(f<o){if(b=a[f],y===b){++f;continue}if(y>=b)throw new Error(T.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(y<0||y>=p)throw new Error(T.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y,p));y>g&&c.fill(i,g*u,y*u);for(let x=m;x<f;++x){let v=r[x];if(v<0||v>=l[0])throw new Error(T.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(x,r[x],l[0]));for(let I=0;I<u;I++)c[y*u+I]+=e[v*u+I]}if(s)for(let x=0;x<u;x++)c[y*u+x]/=f-m;if(m=f,++f,g=y+1,y=b,f>o)break}return g<p&&c.fill(i,g*u,p*u),[c,h]}var JK=ea(e=>Math.sqrt(e)),YK=at(xo,e=>Math.sqrt(e)),QK={kernelName:xo,backendName:"cpu",kernelFunc:YK},$_=_t((e,t)=>{let n=e-t;return n*n}),e8=Ut(ko,$_),t8={kernelName:ko,backendName:"cpu",kernelFunc:e8},A_=ea((e,t)=>{let{pattern:n,replaceGlobal:r,rewrite:a}=t;return e.replace(new RegExp(n,r?"g":""),a)}),n8=fs(ld,A_),r8={kernelName:ld,backendName:"cpu",kernelFunc:n8};function F_(e,t,n,r){let a=Oe(e,t.dtype);for(let s=0;s<a.size;s++){let i=a.indexToLoc(s),o=new Array(i.length);for(let l=0;l<o.length;l++)o[l]=i[l]*n[l]+r[l];a.set(t.get(...o),...i)}return a}var a8=class{constructor(e,t,n,r,a,s){this.separator=w.encodeString(e),this.nGramWidths=t,this.leftPad=w.encodeString(n),this.rightPad=w.encodeString(r),this.padWidth=a,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,a,s){for(let i=0;i<a;++i){let o=this.getPadWidth(s),l=Math.max(0,o-i),u=Math.max(0,o-(a-(i+1))),p=s-(l+u),h=t+(l>0?0:i-o),d=0;d+=l*this.leftPad.length;for(let y=0;y<p;++y)d+=e[h+y].length;d+=u*this.rightPad.length;let c=l+u+p-1;d+=c*this.separator.length,n[r+i]=new Uint8Array(d);let m=n[r+i],f=0,g=y=>y.forEach(b=>m[f++]=b);for(let y=0;y<l;++y)g(this.leftPad),g(this.separator);for(let y=0;y<p-1;++y)g(e[h+y]),g(this.separator);if(p>0){g(e[h+p-1]);for(let y=0;y<u;++y)g(this.separator),g(this.rightPad)}else{for(let y=0;y<u-1;++y)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(e,t){let n=e.length,r=t.length;if(r>0){let o=t[0];if(o!==0)throw new Error(`First split value must be 0, got ${o}`);for(let l=1;l<r;++l){let u=t[l]>=o;if(u=u&&t[l]<=n,!u)throw new Error(`Invalid split value ${t[l]}, must be in [${o}, ${n}]`);o=t[l]}if(o!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${o}`)}let a=r-1,s=w.getArrayFromDType("int32",r);if(n===0||r===0){let o=new Array(n);for(let l=0;l<=a;++l)s[l]=0;return[o,s]}s[0]=0;for(let o=1;o<=a;++o){let l=t[o]-t[o-1],u=0;this.nGramWidths.forEach(p=>{u+=this.getNumNGrams(l,p)}),this.preserveShort&&l>0&&u===0&&(u=1),s[o]=s[o-1]+u}let i=new Array(s[a]);for(let o=0;o<a;++o){let l=t[o],u=s[o];if(this.nGramWidths.forEach(p=>{let h=t[o+1]-t[o],d=this.getNumNGrams(h,p);this.createNGrams(e,l,i,u,d,p),u+=d}),this.preserveShort&&u===s[o]){let p=t[o+1]-t[o];if(p===0)continue;let h=p+2*this.padWidth;this.createNGrams(e,l,i,u,1,h)}}return[i,s]}};function H0(e,t,n,r,a,s,i,o){return new a8(n,r,a,s,i,o).compute(e,t)}function s8(e,t,n,r){if(!e.length)return;if(t.length===0){for(let s=0;s<e.length;++s)r.push(e.subarray(s,s+1));return}if(t.length===1){let s=t[0],i=e.indexOf(s);for(;i!==-1;){let o=e.subarray(0,i);(!n||o.length!==0)&&r.push(o),e=e.subarray(i+1),i=e.indexOf(s)}(!n||e.length!==0)&&r.push(e);return}let a=0;for(let s=0;s<e.length+1;s++)if(s===e.length||t.indexOf(e[s])!==-1){let i=e.subarray(a,s);(!n||i.length!==0)&&r.push(i),a=s+1}}function j0(e,t,n){let r=e.length,a=[],s=0,i=0,o=new Array(r);for(let d=0;d<r;++d){let c=a.length;s8(e[d],t,n,a);let m=a.length-c;o[d]=m,s+=m,i=Math.max(i,m)}let l=w.getArrayFromDType("int32",s*2),u=new Array(s),p=[r,i],h=0;for(let d=0;d<r;++d)for(let c=0;c<o[d];++c)l[h*2]=d,l[h*2+1]=c,u[h]=a[h],++h;return[l,u,p]}function q0(e,t){let n=w.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=w.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}var R_=_t((e,t)=>e-t),i8=z0((e,t,n,r)=>({real:e-n,imag:t-r})),K0=Ut(Io,R_,i8),o8={kernelName:Io,backendName:"cpu",kernelFunc:K0};function D_(e,t){let n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=e.shape[a]*t[a];let r=Oe(n,e.dtype);for(let a=0;a<r.values.length;++a){let s=r.indexToLoc(a),i=new Array(e.rank);for(let l=0;l<i.length;l++)i[l]=s[l]%e.shape[l];let o=e.locToIndex(i);r.values[a]=e.values[o]}return r}var dp=(e,t)=>{let n=t.value-e.value;return n===0?e.index-t.index:n};function M_(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){let o=r-n+1,l=t-n+1,u=Math.log(o),p=.5*Math.exp(2*u/3),h=.5*Math.sqrt(u*p*(o-p)/o)*Math.sign(l-o/2),d=Math.max(n,Math.floor(t-l*p/o+h)),c=Math.min(r,Math.floor(t+(o-l)*p/o+h));M_(e,t,d,c)}let a=e[t],s=n,i=r;for(w.swap(e,n,t),dp(e[r],a)>0&&w.swap(e,n,r);s<i;){for(w.swap(e,s,i),s++,i--;dp(e[s],a)<0;)s=s+1;for(;dp(e[i],a)>0;)i=i-1}dp(e[n],a)===0?w.swap(e,n,i):(i=i+1,w.swap(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function O_(e,t,n,r,a){let s=t[t.length-1],[i,o]=[e.length/s,s],l=w.getTypedArrayFromDType(n,i*r),u=w.getTypedArrayFromDType("int32",i*r);for(let h=0;h<i;h++){let d=h*o,c=e.subarray(d,d+o),m=new Array(c.length);c.forEach((b,x)=>m[x]={value:b,index:x}),r<m.length&&(M_(m,r),m=m.slice(0,r)),a&&m.sort(dp);let f=h*r,g=l.subarray(f,f+r),y=u.subarray(f,f+r);for(let b=0;b<r;b++)g[b]=m[b].value,y[b]=m[b].index}let p=t.slice();return p[p.length-1]=r,[Oe(p,n,l),Oe(p,"int32",u)]}function X0(e,t,n,r){let a=w.parseAxisParam(t,n)[0],s=[1,n[0],1];for(let m=0;m<a;m++)s[0]*=n[m];s[1]=n[a];for(let m=a+1;m<n.length;m++)s[2]*=n[m];let i=new Map,o=new Int32Array(n[a]),l=new Rt(s,r,e),u=[],p=s[0]===1&&s[2]===1;for(let m=0;m<n[a];m++){let f;if(p)f=e[m].toString();else{let y=[];for(let b=0;b<s[0];b++)for(let x=0;x<s[2];x++)y.push(l.get(b,m,x));f=y.join(",")}let g=i.get(f);if(g!=null)o[m]=g;else{let y=i.size;i.set(f,y),o[m]=y,u.push(m)}}let h=s.slice();h[1]=i.size;let d=new Rt(h,r);u.forEach((m,f)=>{for(let g=0;g<s[0];g++)for(let y=0;y<s[2];y++)d.set(l.get(g,m,y),g,f,y)});let c=n.slice();return c[a]=h[1],{outputValues:d.values,outputShape:c,indices:o}}var l8="4.22.0";jc("cpu",()=>new O0,1);var L_=at(_i,e=>e>=0?e:Math.exp(e)-1),u8={kernelName:_i,backendName:"cpu",kernelFunc:L_};function z_(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r;ge([a],"leakyRelu");let i=w.sizeFromShape(a.shape),o=n.data.get(a.dataId).values,l=w.getTypedArrayFromDType("float32",i);for(let u=0;u<o.length;u++)l[u]=o[u]<0?s*o[u]:o[u];return n.makeTensorInfo(a.shape,"float32",l)}var p8={kernelName:Bi,backendName:"cpu",kernelFunc:z_},d8=_t((e,t)=>e<0?t*e:e);function P_(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t;ge([r,a],"prelu");let s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,[o,l]=d8(r.shape,a.shape,s,i,"float32");return n.makeTensorInfo(l,"float32",o)}var h8={kernelName:no,backendName:"cpu",kernelFunc:P_},B_=at(so,e=>Math.max(0,e)),c8={kernelName:so,backendName:"cpu",kernelFunc:B_},W_=at(lo,e=>Math.min(Math.max(0,e),6)),m8={kernelName:lo,backendName:"cpu",kernelFunc:W_};function xc(e,t,n,r,a){if(n==="linear")return Xr({inputs:{x:t},backend:e});if(n==="relu")return B_({inputs:{x:t},backend:e});if(n==="elu")return L_({inputs:{x:t},backend:e});if(n==="relu6")return W_({inputs:{x:t},backend:e});if(n==="prelu")return P_({inputs:{x:t,alpha:r},backend:e});if(n==="leakyrelu")return z_({inputs:{x:t},backend:e,attrs:{alpha:a}});if(n==="sigmoid")return C_({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function gt(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=w.sizeFromShape(a.shape),o=w.inferFromImplicitShape(s,i),l=w.sizeFromShape(o);w.assert(i===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${a.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.incRef(a.dataId);let u=n.data.get(a.dataId);if(u.complexTensorInfos!=null){let p=u.complexTensorInfos.real,h=u.complexTensorInfos.imag;p.shape=o,h.shape=o}return{dataId:a.dataId,shape:o,dtype:a.dtype}}var f8={kernelName:lu,backendName:"cpu",kernelFunc:gt};function V_(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s}=t,{transposeA:i,transposeB:o}=r;ge([a,s],"matMul");let l=a.shape.length,u=s.shape.length,p=i?a.shape[l-2]:a.shape[l-1],h=o?s.shape[u-1]:s.shape[u-2],d=i?a.shape[l-1]:a.shape[l-2],c=o?s.shape[u-2]:s.shape[u-1],m=a.shape.slice(0,-2),f=s.shape.slice(0,-2),g=w.sizeFromShape(m),y=w.sizeFromShape(f),b=Tu.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([d,c]);w.assert(p===h,()=>`Error in matMul: inner shapes (${p}) and (${h}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`);let x=i?[g,p,d]:[g,d,p],v=o?[y,c,h]:[y,h,c],I=gt({inputs:{x:a},backend:n,attrs:{shape:x}}),N=gt({inputs:{x:s},backend:n,attrs:{shape:v}}),C=i?I.shape[1]:I.shape[2],E=i?I.shape[2]:I.shape[1],A=o?N.shape[1]:N.shape[2],R=Math.max(g,y),F=n.data.get(I.dataId).values,S=n.data.get(N.dataId).values,M=w.computeStrides(I.shape),W=w.computeStrides(N.shape),[U,H,q]=i?[M[0],1,M[1]]:[M[0],M[1],1],[K,J,Y]=o?[1,W[1],W[0]]:[W[1],1,W[0]],ee=E*A,re=Oe([R,E,A],I.dtype),te=re.values,ae=n.blockSize;for(let se=0;se<R;se++){let xe=se%g,ue=se%y;for(let be=0;be<E;be+=ae){let ke=Math.min(be+ae,E);for(let Se=0;Se<A;Se+=ae){let Le=Math.min(Se+ae,A);for(let We=0;We<C;We+=ae){let pt=Math.min(We+ae,C);for(let Ye=be;Ye<ke;Ye++)for(let Ze=Se;Ze<Le;Ze++){let Je=0;for(let Ae=We;Ae<pt;Ae++){let ct=F[xe*U+Ye*H+Ae*q],Mn=S[Ae*K+Ze*J+ue*Y];Je+=ct*Mn}te[se*ee+(Ye*A+Ze)]+=Je}}}}}return n.disposeIntermediateTensorInfo(I),n.disposeIntermediateTensorInfo(N),n.makeTensorInfo(b,re.dtype,re.values)}var g8={kernelName:gi,backendName:"cpu",kernelFunc:V_};function y8(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:p,leakyreluAlpha:h}=r,d,c,m,f=[];d=V_({inputs:{a,b:s},attrs:{transposeA:l,transposeB:u},backend:n}),i&&(c=bl({inputs:{a:d,b:i},backend:n}),f.push(d),d=c),p&&(m=xc(n,d,p,o,h),f.push(d),d=m);for(let g of f)n.disposeIntermediateTensorInfo(g);return d}var b8={kernelName:Bs,backendName:"cpu",kernelFunc:y8},x8=at(oi,e=>Math.acos(e)),v8={kernelName:oi,backendName:"cpu",kernelFunc:x8},w8=at(li,e=>Math.acosh(e)),k8={kernelName:li,backendName:"cpu",kernelFunc:w8};function I8(e){let{inputs:t,backend:n}=e,r=t;ge(t,"addN");let a=r.map(o=>n.data.get(o.dataId).values),s=Oe(r[0].shape,r[0].dtype),i=s.values;for(let o=0;o<r.length;o++){let l=a[o];for(let u=0;u<i.length;u++)i[u]+=l[u]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}var S8={kernelName:ui,backendName:"cpu",kernelFunc:I8};function N8(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;ge(a,"all");let o=w.parseAxisParam(s,a.shape),l=o,u=T.getAxesPermutation(l,a.shape.length),p=a;u!=null&&(p=Dn({inputs:{x:a},backend:n,attrs:{perm:u}}),l=T.getInnerMostAxes(l.length,a.shape.length)),T.assertAxesAreInnerMostDims("all",l,p.shape.length);let[h,d]=T.computeOutAndReduceShapes(p.shape,l),c=w.sizeFromShape(d),m=w.makeZerosTypedArray(w.sizeFromShape(h),p.dtype),f=n.data.get(p.dataId).values;for(let y=0;y<m.length;++y){let b=y*c,x=f[b];for(let v=0;v<c;++v){let I=f[b+v];x=x&&I}m[y]=x}u!=null&&n.disposeIntermediateTensorInfo(p);let g=n.makeTensorInfo(h,p.dtype,m);if(i){let y=T.expandShapeToKeepDim(h,o),b=gt({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),b}return g}var T8={kernelName:Nl,backendName:"cpu",kernelFunc:N8};function C8(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;ge(a,"any");let o=w.parseAxisParam(s,a.shape),l=o,u=T.getAxesPermutation(l,a.shape.length),p=a;u!=null&&(p=Dn({inputs:{x:a},backend:n,attrs:{perm:u}}),l=T.getInnerMostAxes(l.length,a.shape.length)),T.assertAxesAreInnerMostDims("any",l,p.shape.length);let[h,d]=T.computeOutAndReduceShapes(p.shape,l),c=w.sizeFromShape(d),m=w.makeZerosTypedArray(w.sizeFromShape(h),p.dtype),f=n.data.get(p.dataId).values;for(let y=0;y<m.length;++y){let b=y*c,x=f[b];for(let v=0;v<c;++v){let I=f[b+v];x=x||I}m[y]=x}u!=null&&n.disposeIntermediateTensorInfo(p);let g=n.makeTensorInfo(h,p.dtype,m);if(i){let y=T.expandShapeToKeepDim(h,o),b=gt({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),b}return g}var _8={kernelName:Tl,backendName:"cpu",kernelFunc:C8};function E8(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;ge(a,"argMax");let i=w.parseAxisParam(s,a.shape),o=T.getAxesPermutation(i,a.shape.length),l=a,u=[];o!=null&&(l=Dn({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=T.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],T.assertAxesAreInnerMostDims("argMax",i,l.shape.length);let[p,h]=T.computeOutAndReduceShapes(l.shape,i),d=w.sizeFromShape(p),c=w.makeZerosTypedArray(d,"int32"),m=w.sizeFromShape(h),f=n.data.get(l.dataId).values;for(let g=0;g<c.length;++g){let y=g*m,b=f[y],x=0;for(let v=0;v<m;++v){let I=f[y+v];I>b&&(b=I,x=v)}c[g]=x}return u.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(p,"int32",c)}var $8={kernelName:Cl,backendName:"cpu",kernelFunc:E8};function A8(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;ge(a,"argMin");let i=w.parseAxisParam(s,a.shape),o=T.getAxesPermutation(i,a.shape.length),l=a,u=[];o!=null&&(l=Dn({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=T.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],T.assertAxesAreInnerMostDims("argMin",i,l.shape.length);let[p,h]=T.computeOutAndReduceShapes(l.shape,i),d=w.sizeFromShape(p),c=w.makeZerosTypedArray(d,"int32"),m=w.sizeFromShape(h),f=n.data.get(l.dataId).values;for(let g=0;g<c.length;++g){let y=g*m,b=f[y],x=0;for(let v=0;v<m;++v){let I=f[y+v];I<b&&(b=I,x=v)}c[g]=x}return u.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(p,"int32",c)}var F8={kernelName:_l,backendName:"cpu",kernelFunc:A8},R8=at(pi,e=>Math.asin(e)),D8={kernelName:pi,backendName:"cpu",kernelFunc:R8},M8=at(di,e=>Math.asinh(e)),O8={kernelName:di,backendName:"cpu",kernelFunc:M8},L8=at(hi,e=>Math.atan(e)),z8={kernelName:hi,backendName:"cpu",kernelFunc:L8},P8=_t((e,t)=>Math.atan2(e,t)),B8=Ut(mi,P8),W8={kernelName:mi,backendName:"cpu",kernelFunc:B8},V8=at(ci,e=>Math.atanh(e)),U8={kernelName:ci,backendName:"cpu",kernelFunc:V8};function Z0(e,t,n,r,a,s){let i=a.strideHeight,o=a.strideWidth,l=a.dilationHeight,u=a.dilationWidth,p=a.effectiveFilterHeight,h=a.effectiveFilterWidth,d=a.padInfo.top,c=a.padInfo.left,m=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,f=Oe(a.outShape,n),g=f.values,y=a.outShape[1]*a.outShape[2]*a.outShape[3],b=a.outShape[2]*a.outShape[3],x=a.outShape[3];for(let v=0;v<a.batchSize;++v){let I=v*y,N=v*r[0];for(let C=0;C<a.inChannels;++C)for(let E=0;E<a.outHeight;++E){let A=E*i-d,R=Math.max(0,A),F=Math.min(a.inHeight,p+A),S=I+E*b;for(let M=0;M<a.outWidth;++M){let W=M*o-c,U=Math.max(0,W),H=Math.min(a.inWidth,h+W),q=m,K=0,J=0;for(let ee=R;ee<F;ee+=l){let re=N+ee*r[1];for(let te=U;te<H;te+=u){let ae=re+te*r[2],se=e[ae+C];s==="max"&&se>q?q=se:s==="avg"&&(K+=se,J++)}if(isNaN(q))break}let Y=S+M*x+C;g[Y]=s==="avg"?K/J:q}}}return f}function U_(e,t,n,r,a=!1,s=!1){let i=Oe(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,p=r.dilationWidth,h=r.effectiveFilterHeight,d=r.effectiveFilterWidth,c=r.padInfo.top,m=r.padInfo.left,f=Oe(t,n,e);for(let g=0;g<r.batchSize;++g)for(let y=0;y<r.inChannels;++y)for(let b=0;b<r.outHeight;++b){let x=b*o-c,v=x;for(;v<0;)v+=u;let I=Math.min(r.inHeight,h+x);for(let N=0;N<r.outWidth;++N){let C=N*l-m,E=C;for(;E<0;)E+=p;let A=Math.min(r.inWidth,d+C),R=Number.NEGATIVE_INFINITY,F=-1;for(let S=v;S<I;S+=u){let M=S-x;for(let W=E;W<A;W+=p){let U=W-C,H=f.get(g,S,W,y);H>R&&(R=H,a?F=s?((g*r.inHeight+S)*r.inWidth+W)*r.inChannels+y:(S*r.inWidth+W)*r.inChannels+y:F=M*d+U)}}i.set(F,g,b,N,y)}}return i}function G_(e,t,n,r,a,s){let i=a.strideDepth,o=a.strideHeight,l=a.strideWidth,u=a.dilationDepth,p=a.dilationHeight,h=a.dilationWidth,d=a.effectiveFilterDepth,c=a.effectiveFilterHeight,m=a.effectiveFilterWidth,f=a.padInfo.front,g=a.padInfo.top,y=a.padInfo.left,b=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=Oe(a.outShape,n),v=x.values,I=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],N=a.outShape[2]*a.outShape[3]*a.outShape[4],C=a.outShape[3]*a.outShape[4],E=a.outShape[4];for(let A=0;A<a.batchSize;++A){let R=A*I,F=A*r[0];for(let S=0;S<a.inChannels;++S)for(let M=0;M<a.outDepth;++M){let W=M*i-f,U=W;for(;U<0;)U+=u;let H=Math.min(a.inDepth,d+W),q=R+M*N;for(let K=0;K<a.outHeight;++K){let J=K*o-g,Y=J;for(;Y<0;)Y+=p;let ee=Math.min(a.inHeight,c+J),re=q+K*C;for(let te=0;te<a.outWidth;++te){let ae=te*l-y,se=ae;for(;se<0;)se+=h;let xe=Math.min(a.inWidth,m+ae),ue=re+te*E,be=b,ke=0,Se=0;for(let We=U;We<H;We+=u){let pt=F+We*r[1];for(let Ye=Y;Ye<ee;Ye+=p){let Ze=pt+Ye*r[2];for(let Je=se;Je<xe;Je+=h){let Ae=Ze+Je*r[3],ct=e[Ae+S];if(s==="max"&&ct>be?be=ct:s==="avg"&&(ke+=ct,Se++),isNaN(be))break}if(isNaN(be))break}if(isNaN(be))break}let Le=ue+S;v[Le]=s==="avg"?ke/Math.max(Se,1):be}}}}return x}function G8(e,t){let n=Oe(t.outShape,"int32"),r=t.strideDepth,a=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,p=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.front,c=t.padInfo.top,m=t.padInfo.left;for(let f=0;f<t.batchSize;++f)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){let b=y*r-d,x=b;for(;x<0;)x+=i;let v=Math.min(t.inDepth,u+b);for(let I=0;I<t.outHeight;++I){let N=I*a-c,C=N;for(;C<0;)C+=o;let E=Math.min(t.inHeight,p+N);for(let A=0;A<t.outWidth;++A){let R=A*s-m,F=R;for(;F<0;)F+=l;let S=Math.min(t.inWidth,h+R),M=Number.NEGATIVE_INFINITY,W=-1;for(let U=x;U<v;U+=i){let H=U-b;for(let q=C;q<E;q+=o){let K=q-N;for(let J=F;J<S;J+=l){let Y=J-R,ee=e.get(f,U,q,J,g);ee>=M&&(M=ee,W=H*p*h+K*p+Y)}}}n.set(W,f,y,I,A,g)}}}return n}function H8(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;ge(a,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,u=1;w.assert(T.eitherStridesOrDilationsAreOne(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let p=T.computePool2DInfo(a.shape,s,i,u,o,l),h;if(p.filterWidth===1&&p.filterHeight===1&&w.arraysEqual(p.inShape,p.outShape))h=Xr({inputs:{x:a},backend:n});else{let d=n.data.get(a.dataId).values,c=w.computeStrides(a.shape),m=Z0(d,a.shape,a.dtype,c,p,"avg");h=n.makeTensorInfo(p.outShape,a.dtype,m.values)}return h}var j8={kernelName:fi,backendName:"cpu",kernelFunc:H8};function q8(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;ge(a,"avgPool3d");let p=T.computePool3DInfo(a.shape,s,i,1,o,l,u),h=n.data.get(a.dataId).values,d=G_(h,a.shape,a.dtype,w.computeStrides(a.shape),p,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}var K8={kernelName:El,backendName:"cpu",kernelFunc:q8};function X8(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;ge([a,s],"avgPool3DGrad");let p=T.computePool3DInfo(s.shape,i,o,1,l,u),h=p.strideDepth,d=p.strideHeight,c=p.strideWidth,m=p.filterDepth,f=p.filterHeight,g=p.filterWidth,y=p.dilationDepth,b=p.dilationHeight,x=p.dilationWidth,v=p.effectiveFilterDepth,I=p.effectiveFilterHeight,N=p.effectiveFilterWidth,C=v-1-p.padInfo.front,E=N-1-p.padInfo.left,A=I-1-p.padInfo.top,R=Oe(s.shape,"float32"),F=1/(m*f*g),S=n.bufferSync(a);for(let M=0;M<p.batchSize;++M)for(let W=0;W<p.inChannels;++W)for(let U=0;U<p.inDepth;++U)for(let H=0;H<p.inHeight;++H)for(let q=0;q<p.inWidth;++q){let K=U-C,J=H-A,Y=q-E,ee=0;for(let re=0;re<v;re+=y){let te=(K+re)/h;if(!(te<0||te>=p.outDepth||Math.floor(te)!==te))for(let ae=0;ae<I;ae+=b){let se=(J+ae)/d;if(!(se<0||se>=p.outHeight||Math.floor(se)!==se))for(let xe=0;xe<N;xe+=x){let ue=(Y+xe)/c;if(ue<0||ue>=p.outWidth||Math.floor(ue)!==ue)continue;let be=S.get(M,te,se,ue,W);ee+=be}}}R.set(ee*F,M,U,H,q,W)}return n.makeTensorInfo(R.shape,R.dtype,R.values)}var Z8={kernelName:Kp,backendName:"cpu",kernelFunc:X8};function J8(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;ge([a,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=r,p=T.computePool2DInfo(i.shape,o,l,1,u),h=p.strideHeight,d=p.strideWidth,c=p.filterHeight,m=p.filterWidth,f=p.dilationHeight,g=p.dilationWidth,y=p.effectiveFilterHeight,b=p.effectiveFilterWidth,x=b-1-p.padInfo.left,v=y-1-p.padInfo.top,I=Oe(i.shape,"float32"),N=1/(c*m),C=n.data.get(a.dataId).values,E=Oe(a.shape,"float32",C);for(let A=0;A<p.batchSize;++A)for(let R=0;R<p.inChannels;++R)for(let F=0;F<p.inHeight;++F)for(let S=0;S<p.inWidth;++S){let M=F-v,W=S-x,U=0;for(let H=0;H<y;H+=f){let q=(M+H)/h;if(!(q<0||q>=p.outHeight||Math.floor(q)!==q))for(let K=0;K<b;K+=g){let J=(W+K)/d;if(J<0||J>=p.outWidth||Math.floor(J)!==J)continue;let Y=E.get(A,q,J,R);U+=Y}}I.set(U*N,A,F,S,R)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}var Y8={kernelName:qp,backendName:"cpu",kernelFunc:J8};function Q8(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,scale:s,offset:i,mean:o,variance:l}=t;w.assert(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),w.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),w.assert(s==null||o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),ge([a,o,l,s,i],"batchNorm");let{varianceEpsilon:u}=r;u==null&&(u=.001);let p=n.data.get(a.dataId).values,h=n.data.get(o.dataId).values,d=n.data.get(l.dataId).values,c=s?n.data.get(s.dataId).values:new Float32Array([1]),m=i?n.data.get(i.dataId).values:new Float32Array([0]),f=new Float32Array(p.length),g=m.length,y=c.length,b=d.length,x=h.length,v=0,I=0,N=0,C=0;for(let E=0;E<p.length;++E)f[E]=m[v++]+(p[E]-h[I++])*c[N++]/Math.sqrt(d[C++]+u),v>=g&&(v=0),I>=x&&(I=0),N>=y&&(N=0),C>=b&&(C=0);return n.makeTensorInfo(a.shape,a.dtype,f)}var eX={kernelName:Di,backendName:"cpu",kernelFunc:Q8};function tX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;ge([a],"batchToSpaceND");let o=s.reduce((y,b)=>y*b),l=T.getReshaped(a.shape,s,o),u=T.getPermuted(l.length,s.length),p=T.getReshapedPermuted(a.shape,s,o),h=T.getSliceBeginCoords(i,s.length),d=T.getSliceSize(p,i,s.length),c=gt({inputs:{x:a},backend:n,attrs:{shape:l}}),m=Dn({inputs:{x:c},backend:n,attrs:{perm:u}}),f=gt({inputs:{x:m},backend:n,attrs:{shape:p}}),g=ei({inputs:{x:f},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(f),g}var nX={kernelName:$l,backendName:"cpu",kernelFunc:tX};function rX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,u=P0(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}var aX={kernelName:Al,backendName:"cpu",kernelFunc:rX};function sX(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=T.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var iX={kernelName:Xp,backendName:"cpu",kernelFunc:sX},oX=at(os,(e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),lX={kernelName:os,backendName:"cpu",kernelFunc:oX},uX=e=>{let{x:t}=e.inputs,n=e.backend,r=new Float32Array(w.sizeFromShape(t.shape)),a=n.data.get(t.dataId),s=a.complexTensorInfos.real,i=a.complexTensorInfos.imag,o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values;for(let u=0;u<o.length;u++){let p=o[u],h=l[u];r[u]=Math.hypot(p,h)}return n.makeOutput(r,t.shape,"float32")},pX={kernelName:Zp,backendName:"cpu",kernelFunc:uX};function xl(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.imag,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}var dX={kernelName:Pc,backendName:"cpu",kernelFunc:xl};function vl(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=w.parseAxisParam(a,t[0].shape)[0],i=t.map(f=>f.shape);T.assertParamsConsistent(i,s);let o=T.computeOutShape(t.map(f=>f.shape),s);if(w.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(f=>w.sizeFromShape(f.shape)>0);if(l.length===1)return Xr({inputs:{x:l[0]},backend:n});if(l[0].dtype==="complex64"){let f=l.map(v=>Qs({inputs:{input:v},backend:n})),g=l.map(v=>xl({inputs:{input:v},backend:n})),y=vl({inputs:f,backend:n,attrs:{axis:s}}),b=vl({inputs:g,backend:n,attrs:{axis:s}}),x=Wn({inputs:{real:y,imag:b},backend:n});return f.forEach(v=>n.disposeIntermediateTensorInfo(v)),g.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),x}let u=l.map(f=>{let g=[-1,w.sizeFromShape(f.shape.slice(s))];return gt({inputs:{x:f},backend:n,attrs:{shape:g}})}),p=u.map(f=>({vals:n.data.get(f.dataId).values,shape:f.shape}));o=T.computeOutShape(u.map(f=>f.shape),1);let h=u[0].shape[0]===1,d=B0(p,o,t[0].dtype,h),c=T.computeOutShape(l.map(f=>f.shape),s),m=n.makeTensorInfo(c,t[0].dtype,d);return u.forEach(f=>n.disposeIntermediateTensorInfo(f)),m}var hX={kernelName:Rl,backendName:"cpu",kernelFunc:vl};function H_(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:p}=r;ge([a,s],"conv2d");let h=T.convertConv2DDataFormat(l),d=T.computeConv2DInfo(a.shape,s.shape,i,u,o,p,!1,h),c=d.filterHeight,m=d.filterWidth,f=d.dilationHeight,g=d.dilationWidth,y=d.padInfo.left,b=d.padInfo.top,x=d.dataFormat==="channelsLast",v=new Rt(d.outShape,a.dtype),I=w.computeStrides(a.shape),N=w.computeStrides(s.shape),C=I[0],E=x?I[1]:I[2],A=x?I[2]:1,R=x?1:I[1],F=v.strides[0],S=x?v.strides[1]:v.strides[2],M=x?v.strides[2]:1,W=x?1:v.strides[1],U=n.data.get(a.dataId).values,H=n.data.get(s.dataId).values,q=v.values;for(let K=0;K<d.batchSize;++K){let J=K*C,Y=K*F;for(let ee=0;ee<d.outHeight;++ee){let re=Y+ee*S,te=ee*d.strideHeight-b;for(let ae=0;ae<c;++ae){let se=te+ae*f;if(se<0||se>=d.inHeight)continue;let xe=ae*N[0],ue=J+se*E;for(let be=0;be<d.outWidth;++be){let ke=re+be*M,Se=be*d.strideWidth-y;for(let Le=0;Le<m;++Le){let We=Se+Le*g;if(We<0||We>=d.inWidth)continue;let pt=xe+Le*N[1],Ye=ue+We*A,Ze=pt;for(let Je=0;Je<d.inChannels;++Je){let Ae=U[Ye+Je*R];for(let ct=0;ct<d.outChannels;++ct)q[ke+ct*W]+=Ae*H[Ze+ct];Ze+=d.outChannels}}}}}}return n.makeTensorInfo(v.shape,v.dtype,q)}var cX={kernelName:xi,backendName:"cpu",kernelFunc:H_};function mX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:p}=r;ge([a,s],"conv2dBackpropFilter");let h=T.convertConv2DDataFormat(l),d=T.computeConv2DInfo(a.shape,p,i,1,o,u,!1,h),{strideHeight:c,strideWidth:m,filterHeight:f,filterWidth:g}=d,y=d.dataFormat==="channelsLast",b=new Rt(d.filterShape,"float32"),x=d.padInfo.left,v=d.padInfo.top,I=n.data.get(a.dataId).values,N=n.data.get(s.dataId).values,C=new Rt(a.shape,a.dtype,I),E=new Rt(s.shape,s.dtype,N);for(let A=0;A<f;++A){let R=Math.max(0,Math.ceil((v-A)/c)),F=Math.min(d.outHeight,(d.inHeight+v-A)/c);for(let S=0;S<g;++S){let M=Math.max(0,Math.ceil((x-S)/m)),W=Math.min(d.outWidth,(d.inWidth+x-S)/m);for(let U=0;U<d.inChannels;++U)for(let H=0;H<d.outChannels;++H){let q=0;for(let K=0;K<d.batchSize;++K)for(let J=R;J<F;++J){let Y=A+J*c-v;for(let ee=M;ee<W;++ee){let re=S+ee*m-x;y?q+=C.get(K,Y,re,U)*E.get(K,J,ee,H):q+=C.get(K,U,Y,re)*E.get(K,H,J,ee)}}b.set(q,A,S,U,H)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var fX={kernelName:Fc,backendName:"cpu",kernelFunc:mX};function gX(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:p}=r;ge([a,s],"conv2dBackpropInput");let h=w.computeStrides(s.shape),d=w.computeStrides(a.shape),c=T.convertConv2DDataFormat(u),m=T.computeConv2DInfo(i,s.shape,o,1,l,p,!1,c),f=new Rt(m.inShape,"float32"),g=f.values,y=n.data.get(a.dataId).values,b=n.data.get(s.dataId).values,[x,v,I]=h,{batchSize:N,filterHeight:C,filterWidth:E,inChannels:A,inHeight:R,inWidth:F,outChannels:S,outHeight:M,outWidth:W,strideHeight:U,strideWidth:H}=m;c=m.dataFormat;let q=C-1-m.padInfo.top,K=E-1-m.padInfo.left,J=c==="channelsLast",Y=f.strides[0],ee=J?f.strides[1]:f.strides[2],re=J?f.strides[2]:1,te=J?1:f.strides[1],ae=d[0],se=J?d[1]:d[2],xe=J?d[2]:1,ue=J?1:d[1];for(let be=0;be<N;++be)for(let ke=0;ke<A;++ke)for(let Se=0;Se<R;++Se){let Le=Se-q,We=Math.max(0,Math.ceil(Le/U)),pt=Math.min(M,(C+Le)/U);for(let Ye=0;Ye<F;++Ye){let Ze=Ye-K,Je=Math.max(0,Math.ceil(Ze/H)),Ae=Math.min(W,(E+Ze)/H),ct=0;for(let Et=We;Et<pt;++Et){let Xn=Et*U-Le;for(let tn=Je;tn<Ae;++tn){let Sn=tn*H-Ze,Zn=ae*be+se*Et+xe*tn,Nn=x*(C-1-Xn)+v*(E-1-Sn)+I*ke;for(let st=0;st<S;++st){let Tn=y[Zn+ue*st],On=b[Nn+st];ct+=Tn*On}}}let Mn=Y*be+ee*Se+re*Ye+te*ke;g[Mn]=ct}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}var yX={kernelName:vi,backendName:"cpu",kernelFunc:gX};function bX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;ge([a,s],"conv3d");let u=T.computeConv3DInfo(a.shape,s.shape,i,l,o),{filterDepth:p,filterHeight:h,filterWidth:d,dilationDepth:c,dilationHeight:m,dilationWidth:f,padInfo:g}=u,y=g.front,b=g.left,x=g.top,v=new Rt(u.outShape,a.dtype),I=n.data.get(a.dataId).values,N=n.data.get(s.dataId).values,C=v.values,E=w.computeStrides(a.shape),A=w.computeStrides(s.shape);for(let R=0;R<u.batchSize;++R){let F=R*E[0],S=R*v.strides[0];for(let M=0;M<u.outDepth;++M){let W=S+M*v.strides[1],U=M*u.strideDepth-y;for(let H=0;H<p;++H){let q=U+H*c;if(q<0||q>=u.inDepth)continue;let K=H*A[0],J=F+q*E[1];for(let Y=0;Y<u.outHeight;++Y){let ee=W+Y*v.strides[2],re=Y*u.strideHeight-x;for(let te=0;te<h;++te){let ae=re+te*m;if(ae<0||ae>=u.inHeight)continue;let se=K+te*A[1],xe=J+ae*E[2];for(let ue=0;ue<u.outWidth;++ue){let be=ee+ue*u.outChannels,ke=ue*u.strideWidth-b;for(let Se=0;Se<d;++Se){let Le=ke+Se*f;if(Le<0||Le>=u.inWidth)continue;let We=se+Se*A[2],pt=xe+Le*u.inChannels,Ye=We;for(let Ze=0;Ze<u.inChannels;++Ze){let Je=I[pt+Ze];for(let Ae=0;Ae<u.outChannels;++Ae)C[be+Ae]+=Je*N[Ye+Ae];Ye+=u.outChannels}}}}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}var xX={kernelName:wi,backendName:"cpu",kernelFunc:bX};function vX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r;ge([a,s],"conv3dBackpropFilterV2");let u=w.computeStrides(a.shape),p=w.computeStrides(s.shape),h=T.computeConv3DInfo(a.shape,l,i,1,o),d=h.strideDepth,c=h.strideHeight,m=h.strideWidth,f=h.filterDepth,g=h.filterHeight,y=h.filterWidth,b=new Rt(h.filterShape,"float32"),x=b.values,[v,I,N,C]=b.strides,E=n.data.get(s.dataId).values,[A,R,F,S]=p,M=n.data.get(a.dataId).values,[W,U,H,q]=u,K=h.padInfo.front,J=h.padInfo.left,Y=h.padInfo.top;for(let ee=0;ee<f;++ee){let re=Math.max(0,Math.ceil((K-ee)/d)),te=Math.min(h.outDepth,(h.inDepth+K-ee)/d),ae=ee*v;for(let se=0;se<g;++se){let xe=Math.max(0,Math.ceil((Y-se)/c)),ue=Math.min(h.outHeight,(h.inHeight+Y-se)/c),be=se*I+ae;for(let ke=0;ke<y;++ke){let Se=Math.max(0,Math.ceil((J-ke)/m)),Le=Math.min(h.outWidth,(h.inWidth+J-ke)/m),We=ke*N+be;for(let pt=0;pt<h.inChannels;++pt){let Ye=pt*C+We;for(let Ze=0;Ze<h.outChannels;++Ze){let Je=0;for(let Ae=0;Ae<h.batchSize;++Ae){let ct=Ae*W,Mn=Ae*A;for(let Et=re;Et<te;++Et){let Xn=(ee+Et*d-K)*U+ct,tn=Et*R+Mn;for(let Sn=xe;Sn<ue;++Sn){let Zn=(se+Sn*c-Y)*H+Xn,Nn=Sn*F+tn;for(let st=Se;st<Le;++st){let Tn=(ke+st*m-J)*q+Zn,On=st*S+Nn;Je+=M[Tn+pt]*E[On+Ze]}}}}x[Ye+Ze]=Je}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var wX={kernelName:Dl,backendName:"cpu",kernelFunc:vX};function kX(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r;ge([a],"conv3dBackpropInputV2");let u=w.computeStrides(a.shape),p=w.computeStrides(s.shape),h=T.computeConv3DInfo(l,s.shape,o,1,i),d=new Rt(h.inShape,"float32"),c=d.values,[m,f,g,y]=d.strides,b=n.data.get(a.dataId).values,[x,v,I,N]=u,C=n.data.get(s.dataId).values,[E,A,R,F]=p,{batchSize:S,filterDepth:M,filterHeight:W,filterWidth:U,inChannels:H,inDepth:q,inHeight:K,inWidth:J,outChannels:Y,outDepth:ee,outHeight:re,outWidth:te,strideDepth:ae,strideHeight:se,strideWidth:xe}=h,ue=M-1-h.padInfo.front,be=W-1-h.padInfo.top,ke=U-1-h.padInfo.left;for(let Se=0;Se<S;++Se)for(let Le=0;Le<H;++Le)for(let We=0;We<q;++We){let pt=We-ue,Ye=Math.max(0,Math.ceil(pt/ae)),Ze=Math.min(ee,(M+pt)/ae);for(let Je=0;Je<K;++Je){let Ae=Je-be,ct=Math.max(0,Math.ceil(Ae/se)),Mn=Math.min(re,(W+Ae)/se);for(let Et=0;Et<J;++Et){let Xn=Et-ke,tn=Math.max(0,Math.ceil(Xn/xe)),Sn=Math.min(te,(U+Xn)/xe),Zn=0;for(let Nn=Ye;Nn<Ze;++Nn){let st=Nn*ae-pt;for(let Tn=ct;Tn<Mn;++Tn){let On=Tn*se-Ae;for(let ta=tn;ta<Sn;++ta){let Po=ta*xe-Xn,Rr=x*Se+v*Nn+I*Tn+N*ta,Xu=E*(M-1-st)+A*(W-1-On)+R*(U-1-Po)+F*Le;for(let pr=0;pr<Y;++pr){let Sa=b[Rr+pr],Gt=C[Xu+pr];Zn+=Sa*Gt}}}}c[m*Se+f*We+g*Je+y*Et+Le]=Zn}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}var IX={kernelName:Ml,backendName:"cpu",kernelFunc:kX},SX=at(ki,e=>Math.cos(e)),NX={kernelName:ki,backendName:"cpu",kernelFunc:SX},TX=at(Ii,e=>Math.cosh(e)),CX={kernelName:Ii,backendName:"cpu",kernelFunc:TX};function _X(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,[p,h,d,c]=a.shape,m=s.shape[0],[f,g]=o,y=Oe([m,f,g,c],"float32"),b=n.data.get(s.dataId).values,x=n.data.get(i.dataId).values,v=n.data.get(a.dataId).values,I=w.computeStrides(a.shape),N=w.computeStrides(y.shape);for(let C=0;C<m;C++){let E=C*4,A=b[E],R=b[E+1],F=b[E+2],S=b[E+3],M=x[C];if(M>=p)continue;let W=f>1?(F-A)*(h-1)/(f-1):0,U=g>1?(S-R)*(d-1)/(g-1):0;for(let H=0;H<f;H++){let q=f>1?A*(h-1)+H*W:.5*(A+F)*(h-1);if(q<0||q>h-1){for(let K=0;K<g;K++)for(let J=0;J<c;J++){let Y=J+K*N[2]+H*N[1]+C*N[0];y.values[Y]=u}continue}if(l==="bilinear"){let K=Math.floor(q),J=Math.ceil(q),Y=q-K;for(let ee=0;ee<g;ee++){let re=g>1?R*(d-1)+ee*U:.5*(R+S)*(d-1);if(re<0||re>d-1){for(let xe=0;xe<c;xe++){let ue=xe+ee*N[2]+H*N[1]+C*N[0];y.values[ue]=u}continue}let te=Math.floor(re),ae=Math.ceil(re),se=re-te;for(let xe=0;xe<c;xe++){let ue=xe+te*I[2]+K*I[1]+M*I[0],be=v[ue];ue=xe+ae*I[2]+K*I[1]+M*I[0];let ke=v[ue];ue=xe+te*I[2]+J*I[1]+M*I[0];let Se=v[ue];ue=xe+ae*I[2]+J*I[1]+M*I[0];let Le=v[ue],We=be+(ke-be)*se,pt=Se+(Le-Se)*se;ue=xe+ee*N[2]+H*N[1]+C*N[0],y.values[ue]=We+(pt-We)*Y}}}else for(let K=0;K<g;++K){let J=g>1?R*(d-1)+K*U:.5*(R+S)*(d-1);if(J<0||J>d-1){for(let re=0;re<c;re++){let te=re+K*N[2]+H*N[1]+C*N[0];y.values[te]=u}continue}let Y=Math.round(J),ee=Math.round(q);for(let re=0;re<c;re++){let te=re+Y*I[2]+ee*I[1]+M*I[0],ae=re+K*N[2]+H*N[1]+C*N[0];y.values[ae]=v[te]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}var EX={kernelName:Ll,backendName:"cpu",kernelFunc:_X};function $X(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;ge(a,"cumprod");let l=T.getAxesPermutation([s],a.shape.length),u=a;l!=null&&(u=Dn({inputs:{x:a},backend:n,attrs:{perm:l}}));let p=T.getInnerMostAxes(1,a.shape.length)[0];if(p!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${p}`);let h=sr(u.dtype,"int32"),d=w.makeOnesTypedArray(w.sizeFromShape(u.shape),h),c=n.data.get(u.dataId).values,m=u.shape[u.shape.length-1],f=o?(y,b)=>y+m-b-1:(y,b)=>y+b;for(let y=0;y<c.length;y+=m)for(let b=0;b<m;b++){let x=f(y,b);if(b===0)d[x]=i?1:c[x];else{let v=f(y,b-1);d[x]=i?c[v]*d[v]:c[x]*d[v]}}let g=n.makeTensorInfo(u.shape,h,d);if(l!=null){let y=T.getUndoAxesPermutation(l),b=Dn({inputs:{x:g},backend:n,attrs:{perm:y}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),b}return g}var AX={kernelName:Ol,backendName:"cpu",kernelFunc:$X};function FX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;ge(a,"cumsum");let l=T.getAxesPermutation([s],a.shape.length),u=a;l!=null&&(u=Dn({inputs:{x:a},backend:n,attrs:{perm:l}}));let p=T.getInnerMostAxes(1,a.shape.length)[0];if(p!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${p}`);let h=sr(u.dtype,"int32"),d=w.makeZerosTypedArray(w.sizeFromShape(u.shape),h),c=n.data.get(u.dataId).values,m=u.shape[u.shape.length-1],f=o?(y,b)=>y+m-b-1:(y,b)=>y+b;for(let y=0;y<c.length;y+=m)for(let b=0;b<m;b++){let x=f(y,b);if(b===0)d[x]=i?0:c[x];else{let v=f(y,b-1);d[x]=i?c[v]+d[v]:c[x]+d[v]}}let g=n.makeTensorInfo(u.shape,h,d);if(l!=null){let y=T.getUndoAxesPermutation(l),b=Dn({inputs:{x:g},backend:n,attrs:{perm:y}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),b}return g}var RX={kernelName:Si,backendName:"cpu",kernelFunc:FX};function DX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(a.shape.length===1){let l=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,p=P0(l,u,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,p)}else if(a.shape.length===2){let l=n.bufferSync(a),u=n.bufferSync(s),p=QC(l,u,i,o);return n.makeTensorInfo(p.shape,s.dtype,p.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}var MX={kernelName:Jp,backendName:"cpu",kernelFunc:DX};function OX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r;w.assert(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let o=a.shape[0],l=a.shape[1],u=a.shape[2],p=a.shape[3],h=l*s,d=u*s,c=p/(s*s),m=n.data.get(a.dataId).values,f=new Float32Array(o*h*d*c),g=0;for(let y=0;y<o;++y)for(let b=0;b<h;++b){let x=Math.floor(b/s),v=b%s;for(let I=0;I<d;++I){let N=Math.floor(I/s),C=I%s,E=(v*s+C)*c;for(let A=0;A<c;++A){let R=A+E+p*(N+u*(x+l*y));f[g++]=m[R]}}}return n.makeTensorInfo([o,h,d,c],a.dtype,f)}var LX={kernelName:zl,backendName:"cpu",kernelFunc:OX};function j_(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;ge([a,s],"depthwiseConv2DNative");let p=w.computeStrides(a.shape),h=w.computeStrides(s.shape),d=l;d==null&&(d=[1,1]),w.assert(T.eitherStridesOrDilationsAreOne(i,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);let c=T.computeConv2DInfo(a.shape,s.shape,i,d,o,u,!0),{filterHeight:m,filterWidth:f,dilationHeight:g,dilationWidth:y,padInfo:b}=c,x=b.left,v=b.top,I=c.outChannels/c.inChannels,N=new Rt(c.outShape,a.dtype),C=n.data.get(a.dataId).values,E=n.data.get(s.dataId).values,A=N.values;for(let R=0;R<c.batchSize;++R){let F=R*p[0],S=R*N.strides[0];for(let M=0;M<c.outHeight;++M){let W=S+M*N.strides[1],U=M*c.strideHeight-v;for(let H=0;H<m;++H){let q=U+H*g;if(q<0||q>=c.inHeight)continue;let K=H*h[0],J=F+q*p[1];for(let Y=0;Y<c.outWidth;++Y){let ee=W+Y*N.strides[2],re=Y*c.strideWidth-x;for(let te=0;te<f;++te){let ae=re+te*y;if(ae<0||ae>=c.inWidth)continue;let se=K+te*h[1],xe=J+ae*c.inChannels,ue=ee,be=se;for(let ke=0;ke<c.inChannels;++ke){let Se=C[xe+ke];for(let Le=0;Le<I;++Le)A[ue+Le]+=Se*E[be+Le];ue+=I,be+=I}}}}}}return n.makeTensorInfo(N.shape,N.dtype,N.values)}var zX={kernelName:Ni,backendName:"cpu",kernelFunc:j_};function PX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:p}=r;ge([a,s],"depthwiseConv2dNativeBackpropFilter");let h=T.computeConv2DInfo(a.shape,p,i,o,l,u,!0),{strideHeight:d,strideWidth:c,filterHeight:m,filterWidth:f}=h,g=new Rt(h.filterShape,"float32"),y=h.padInfo.left,b=h.padInfo.top,x=h.outChannels/h.inChannels,v=n.data.get(a.dataId).values,I=new Rt(a.shape,a.dtype,v),N=n.data.get(s.dataId).values,C=new Rt(s.shape,s.dtype,N);for(let E=0;E<m;++E){let A=Math.max(0,Math.ceil((b-E)/d)),R=Math.min(h.outHeight,(h.inHeight+b-E)/d);for(let F=0;F<f;++F){let S=Math.max(0,Math.ceil((y-F)/c)),M=Math.min(h.outWidth,(h.inWidth+y-F)/c);for(let W=0;W<h.outChannels;++W){let U=Math.trunc(W/x),H=W%x,q=0;for(let K=0;K<h.batchSize;++K)for(let J=A;J<R;++J){let Y=E+J*d-b;for(let ee=S;ee<M;++ee){let re=F+ee*c-y;q+=I.get(K,Y,re,U)*C.get(K,J,ee,W)}}g.set(q,E,F,U,H)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}var BX={kernelName:Rc,backendName:"cpu",kernelFunc:PX};function WX(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:p}=r;ge([a,s],"depthwiseConv2DNativeBackpropInput");let h=w.computeStrides(a.shape),d=w.computeStrides(s.shape),c=T.computeConv2DInfo(p,s.shape,i,o,l,u,!0),m=new Rt(c.inShape,"float32"),f=m.values,[g,y,b]=m.strides,x=n.data.get(a.dataId).values,[v,I,N]=h,C=n.data.get(s.dataId).values,[E,A,R]=d,{batchSize:F,filterHeight:S,filterWidth:M,inChannels:W,inHeight:U,inWidth:H,outChannels:q,outHeight:K,outWidth:J,strideHeight:Y,strideWidth:ee}=c,re=S-1-c.padInfo.top,te=M-1-c.padInfo.left,ae=q/W;for(let se=0;se<F;++se)for(let xe=0;xe<W;++xe)for(let ue=0;ue<U;++ue){let be=ue-re,ke=Math.max(0,Math.ceil(be/Y)),Se=Math.min(K,(S+be)/Y);for(let Le=0;Le<H;++Le){let We=Le-te,pt=Math.max(0,Math.ceil(We/ee)),Ye=Math.min(J,(M+We)/ee),Ze=0;for(let Je=ke;Je<Se;++Je){let Ae=Je*Y-be;for(let ct=pt;ct<Ye;++ct){let Mn=ct*ee-We,Et=v*se+I*Je+N*ct,Xn=E*(S-1-Ae)+A*(M-1-Mn)+R*xe;for(let tn=0;tn<ae;++tn){let Sn=xe*ae+tn,Zn=x[Et+Sn],Nn=C[Xn+tn];Ze+=Zn*Nn}}}f[g*se+y*ue+b*Le+xe]=Ze}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}var VX={kernelName:Dc,backendName:"cpu",kernelFunc:WX};function UX(e){let{inputs:t,backend:n}=e,{x:r}=t,a=w.sizeFromShape(r.shape),s=n.data.get(r.dataId).values,i=Oe([a,a],r.dtype),o=i.values;for(let u=0;u<s.length;u++)o[u*a+u]=s[u];let l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}var GX={kernelName:Yp,backendName:"cpu",kernelFunc:UX},HX={kernelName:Ti,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a}=e,{strides:s,pad:i,dilations:o}=n,l=t,u=l.data.get(r.dataId).values,p=r.shape.length,h=l.data.get(a.dataId).values,d=a.shape.length,{batchSize:c,inHeight:m,inWidth:f,inChannels:g,outHeight:y,outWidth:b,padInfo:x,strideHeight:v,strideWidth:I,filterHeight:N,filterWidth:C,dilationHeight:E,dilationWidth:A,outShape:R}=T.computeDilation2DInfo(r.shape,a.shape,s,i,"NHWC",o),F=w.sizeFromShape(R),S=R.length,M=w.getArrayFromDType(r.dtype,F);for(let W=0;W<c;++W)for(let U=0;U<y;++U){let H=U*v-x.top;for(let q=0;q<b;++q){let K=q*I-x.left;for(let J=0;J<g;++J){let Y=Number.MIN_SAFE_INTEGER;for(let re=0;re<N;++re){let te=H+re*E;if(te>=0&&te<m)for(let ae=0;ae<C;++ae){let se=K+ae*A;if(se>=0&&se<f){let xe=w.locToIndex([W,te,se,J],p,w.computeStrides(r.shape)),ue=w.locToIndex([re,ae,J],d,w.computeStrides(a.shape)),be=u[xe]+h[ue];be>Y&&(Y=be)}}}let ee=w.locToIndex([W,U,q,J],S,w.computeStrides(R));M[ee]=Y}}}return{dataId:l.write(w.toTypedArray(M,r.dtype),R,r.dtype),shape:R,dtype:r.dtype}}},jX={kernelName:il,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a,dy:s}=e,{strides:i,pad:o,dilations:l}=n,u=t,p=w.toNestedArray(r.shape,u.data.get(r.dataId).values),h=w.toNestedArray(a.shape,u.data.get(a.dataId).values),{batchSize:d,inHeight:c,inWidth:m,inChannels:f,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:v,filterHeight:I,filterWidth:N,dilationHeight:C,dilationWidth:E,outShape:A}=T.computeDilation2DInfo(r.shape,a.shape,i,o,"NHWC",l);w.assert(s.rank===A.length,()=>`Error in ${il}, dy must have the same rank as output ${A.length}, but got ${s.rank}`);let R=w.toNestedArray(A,u.data.get(s.dataId).values),F=w.makeZerosNestedTypedArray(a.shape,a.dtype);for(let S=0;S<d;++S)for(let M=0;M<g;++M){let W=M*x-b.top;for(let U=0;U<y;++U){let H=U*v-b.left;for(let q=0;q<f;++q){let K=Number.MIN_SAFE_INTEGER,J=0,Y=0;for(let ee=0;ee<I;++ee){let re=W+ee*C;if(re>=0&&re<c)for(let te=0;te<N;++te){let ae=H+te*E;if(ae>=0&&ae<m){let se=p[S][re][ae][q]+h[ee][te][q];se>K&&(K=se,J=ee,Y=te)}}}F[J][Y][q]+=R[S][M][U][q]}}}return{dataId:u.write(w.toTypedArray(F,r.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},qX={kernelName:sl,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a,dy:s}=e,{strides:i,pad:o,dilations:l}=n,u=t,p=w.toNestedArray(r.shape,u.data.get(r.dataId).values),h=w.toNestedArray(a.shape,u.data.get(a.dataId).values),{batchSize:d,inHeight:c,inWidth:m,inChannels:f,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:v,filterHeight:I,filterWidth:N,dilationHeight:C,dilationWidth:E,outShape:A}=T.computeDilation2DInfo(r.shape,a.shape,i,o,"NHWC",l);w.assert(s.rank===A.length,()=>`Error in ${sl}, dy must have the same rank as output ${A.length}, but got ${s.rank}`);let R=w.toNestedArray(A,u.data.get(s.dataId).values),F=w.makeZerosNestedTypedArray(r.shape,r.dtype);for(let S=0;S<d;++S)for(let M=0;M<g;++M){let W=M*x-b.top;for(let U=0;U<y;++U){let H=U*v-b.left;for(let q=0;q<f;++q){let K=Number.MIN_SAFE_INTEGER,J=W<0?0:W,Y=H<0?0:H;for(let ee=0;ee<I;++ee){let re=W+ee*C;if(re>=0&&re<c)for(let te=0;te<N;++te){let ae=H+te*E;if(ae>=0&&ae<m){let se=p[S][re][ae][q]+h[ee][te][q];se>K&&(K=se,J=re,Y=ae)}}}F[S][J][Y][q]+=R[S][M][U][q]}}}return{dataId:u.write(w.toTypedArray(F,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function KX(e){let{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{canvas:s,options:i}=r,{contextOptions:o,imageOptions:l}=i||{},u=(l==null?void 0:l.alpha)||1,p=(o==null?void 0:o.contextType)||"2d";if(p!=="2d")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);let h=s.getContext(p,(o==null?void 0:o.contextAttributes)||{});if(h==null)throw new Error(`Could not get the context with ${p} type.`);let[d,c]=a.shape.slice(0,2),m=a.shape.length===2?1:a.shape[2],f=n.data.get(a.dataId).values,g=a.dtype==="float32"?255:1,y=new Uint8ClampedArray(c*d*4);for(let x=0;x<d*c;++x){let v=[0,0,0,255*u];for(let N=0;N<m;N++){let C=f[x*m+N];if(a.dtype==="float32"){if(C<0||C>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${C}.`)}else if(a.dtype==="int32"&&(C<0||C>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${C}.`);m===1?(v[0]=C*g,v[1]=C*g,v[2]=C*g):v[N]=C*g}let I=x*4;y[I+0]=Math.round(v[0]),y[I+1]=Math.round(v[1]),y[I+2]=Math.round(v[2]),y[I+3]=Math.round(v[3])}s.width=c,s.height=d;let b=new ImageData(y,c,d);return h.putImageData(b,0,0),a}var XX={kernelName:Mc,backendName:"cpu",kernelFunc:KX};function Vd(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;ge(a,"sum");let o;a.dtype==="bool"?o=rs({inputs:{x:a},backend:n,attrs:{dtype:"int32"}}):o=Xr({inputs:{x:a},backend:n});let l=o.shape.length,u=w.parseAxisParam(s,o.shape),p=T.getAxesPermutation(u,l),h=u,d=o;p!=null&&(d=Dn({inputs:{x:o},backend:n,attrs:{perm:p}}),h=T.getInnerMostAxes(h.length,l)),T.assertAxesAreInnerMostDims("sum",h,d.shape.length);let[c,m]=T.computeOutAndReduceShapes(d.shape,h),f=T.upcastType(d.dtype,"int32"),g=yc(n,c,f),y=w.sizeFromShape(m),b=n.data.get(g.dataId).values,x=n.data.get(d.dataId).values;for(let v=0;v<b.length;++v){let I=v*y,N=0;for(let C=0;C<y;++C)N+=x[I+C];b[v]=N}if(i){let v=T.expandShapeToKeepDim(g.shape,u),I=g;g=gt({inputs:{x:g},backend:n,attrs:{shape:v}}),n.disposeIntermediateTensorInfo(I)}return n.disposeIntermediateTensorInfo(o),p!=null&&n.disposeIntermediateTensorInfo(d),g}var ZX={kernelName:vo,backendName:"cpu",kernelFunc:Vd};function JX(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=T.decodeEinsumEquation(a,s.length);T.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:p}=T.getEinsumComputePath(o,l),h=p.length,d=null,c=i.length,m=[];for(let f=0;f<h;++f){for(let g of p[f]){let{permutationIndices:y,expandDims:b}=T.getEinsumPermutation(c,l[g]),x;T.isIdentityPermutation(y)?x=s[g]:(x=Dn({inputs:{x:s[g]},backend:n,attrs:{perm:y}}),m.push(x));let v=x.shape.slice();for(let I=0;I<b.length;++I)v.splice(b[I],0,1);w.arraysEqual(x.shape,v)||(x=gt({inputs:{x},backend:n,attrs:{shape:v}}),m.push(x)),d===null?d=x:(d=Xm({inputs:{a:x,b:d},backend:n}),m.push(d))}f<h-1&&(u[f]>=0&&(d=Vd({inputs:{x:d},backend:n,attrs:{axis:u[f]-(i.length-c),keepDims:!1}}),m.push(d)),c--)}for(let f of m)f!==d&&n.disposeIntermediateTensorInfo(f);return d}var YX={kernelName:Oc,backendName:"cpu",kernelFunc:JX};function QX(e){let{inputs:t,backend:n}=e,{dy:r,y:a}=t;ge([r,a],"eluGrad");let s=new Float32Array(w.sizeFromShape(a.shape)),i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<i.length;++l){let u=i[l];u>=0?s[l]=o[l]:s[l]=o[l]*(u+1)}return n.makeTensorInfo(a.shape,"float32",s)}var eZ={kernelName:Pl,backendName:"cpu",kernelFunc:QX},tZ=T.ERF_P,nZ=T.ERF_A1,rZ=T.ERF_A2,aZ=T.ERF_A3,sZ=T.ERF_A4,iZ=T.ERF_A5,oZ=at(Ei,e=>{let t=Math.sign(e),n=Math.abs(e),r=1/(1+tZ*n);return t*(1-((((iZ*r+sZ)*r+aZ)*r+rZ)*r+nZ)*r*Math.exp(-n*n))}),lZ={kernelName:Ei,backendName:"cpu",kernelFunc:oZ};function vc(e){let{inputs:t,backend:n,attrs:r}=e,{input:a}=t,{dim:s}=r,i=a.shape.length,o=a.shape.slice(),l=s;return s<0&&(w.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),gt({inputs:{x:a},backend:n,attrs:{shape:o}})}var uZ={kernelName:Wl,backendName:"cpu",kernelFunc:vc},pZ=_t((e,t)=>e/t),J0=Ut(Ci,pZ),tx={kernelName:Ci,backendName:"cpu",kernelFunc:J0};function q_(e,t,n){let r=e.shape,a=r[0],s=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[a,s],p=w.sizeFromShape(u),h=w.getTypedArrayFromDType("float32",p),d=w.getTypedArrayFromDType("float32",p);for(let g=0;g<a;g++){let y=ei({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,s]}}),b=ei({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,s]}}),x=Wn({inputs:{real:y,imag:b},backend:n}),{real:v,imag:I}=dZ(x,t,n),N=T.mergeRealAndImagArrays(v,I);for(let C=0;C<s;C++){let E=T.getComplexWithIndex(N,C);h[g*s+C]=E.real,d[g*s+C]=E.imag}n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(x)}let c=n.makeTensorInfo(u,"float32",h),m=n.makeTensorInfo(u,"float32",d),f=Wn({inputs:{real:c,imag:m},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(m),f}function dZ(e,t,n){let r=w.sizeFromShape(e.shape),a=n.data.get(e.dataId),s=n.data.get(a.complexTensorInfos.real.dataId).values,i=n.data.get(a.complexTensorInfos.imag.dataId).values;if(hZ(r)){let o=nx(s,i,r,t,n),l=[e.shape[0],e.shape[1]];if(t){let u=n.makeTensorInfo(l,"float32",o.real),p=n.makeTensorInfo(l,"float32",o.imag),h=n.makeTensorInfo([],"float32",w.createScalarValue(r,"float32")),d=Xr({inputs:{x:h},backend:n}),c=tx.kernelFunc({inputs:{a:u,b:h},backend:n}),m=tx.kernelFunc({inputs:{a:p,b:d},backend:n}),f=n.data.get(c.dataId).values,g=n.data.get(m.dataId).values;return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(m),{real:f,imag:g}}return o}else{let o=T.mergeRealAndImagArrays(s,i),l=cZ(o,r,t);return T.splitRealAndImagArrays(l)}}function hZ(e){return(e&e-1)===0}function nx(e,t,n,r,a){if(n===1)return{real:e,imag:t};let s=T.mergeRealAndImagArrays(e,t),i=n/2,o=T.complexWithEvenIndex(s),l=o.real,u=o.imag,p=[l.length],h=a.makeTensorInfo(p,"float32",l),d=a.makeTensorInfo(p,"float32",u),c=Wn({inputs:{real:h,imag:d},backend:a}),m=T.complexWithOddIndex(s),f=m.real,g=m.imag,y=[f.length],b=a.makeTensorInfo(y,"float32",f),x=a.makeTensorInfo(y,"float32",g),v=Wn({inputs:{real:b,imag:x},backend:a}),I=nx(l,u,i,r,a),N=I.real,C=I.imag,E=[N.length],A=a.makeTensorInfo(E,"float32",N),R=a.makeTensorInfo(E,"float32",C),F=Wn({inputs:{real:A,imag:R},backend:a}),S=nx(f,g,i,r,a),M=S.real,W=S.imag,U=[M.length],H=a.makeTensorInfo(U,"float32",M),q=a.makeTensorInfo(U,"float32",W),K=Wn({inputs:{real:H,imag:q},backend:a}),J=T.exponents(n,r),Y=[J.real.length],ee=a.makeTensorInfo(Y,"float32",J.real),re=a.makeTensorInfo(Y,"float32",J.imag),te=Wn({inputs:{real:ee,imag:re},backend:a}),ae=Xm({inputs:{a:te,b:K},backend:a}),se=bl({inputs:{a:F,b:ae},backend:a}),xe=K0({inputs:{a:F,b:ae},backend:a}),ue=Qs({inputs:{input:se},backend:a}),be=Qs({inputs:{input:xe},backend:a}),ke=xl({inputs:{input:se},backend:a}),Se=xl({inputs:{input:xe},backend:a}),Le=vl({inputs:[ue,be],backend:a,attrs:{axis:0}}),We=vl({inputs:[ke,Se],backend:a,attrs:{axis:0}}),pt=a.data.get(Le.dataId).values,Ye=a.data.get(We.dataId).values;return a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(d),a.disposeIntermediateTensorInfo(c),a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(v),a.disposeIntermediateTensorInfo(A),a.disposeIntermediateTensorInfo(R),a.disposeIntermediateTensorInfo(F),a.disposeIntermediateTensorInfo(H),a.disposeIntermediateTensorInfo(q),a.disposeIntermediateTensorInfo(K),a.disposeIntermediateTensorInfo(ee),a.disposeIntermediateTensorInfo(re),a.disposeIntermediateTensorInfo(te),a.disposeIntermediateTensorInfo(ae),a.disposeIntermediateTensorInfo(se),a.disposeIntermediateTensorInfo(xe),a.disposeIntermediateTensorInfo(ue),a.disposeIntermediateTensorInfo(ke),a.disposeIntermediateTensorInfo(be),a.disposeIntermediateTensorInfo(Se),a.disposeIntermediateTensorInfo(Le),a.disposeIntermediateTensorInfo(We),{real:pt,imag:Ye}}function cZ(e,t,n){let r=new Float32Array(t*2);for(let a=0;a<t;a++){let s=0,i=0;for(let o=0;o<t;o++){let l=T.exponent(a*o,t,n),u=T.getComplexWithIndex(e,o);s+=u.real*l.real-u.imag*l.imag,i+=u.real*l.imag+u.imag*l.real}n&&(s/=t,i/=t),T.assignToTypedArray(r,s,i,a)}return r}function mZ(e){let{inputs:t,backend:n}=e,{input:r}=t,a=w.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=a/s,o=gt({inputs:{x:r},backend:n,attrs:{shape:[i,s]}}),l=q_(o,!1,n),u=gt({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}var fZ={kernelName:Lc,backendName:"cpu",kernelFunc:mZ};function Y0(e){let{backend:t,attrs:n}=e,{shape:r,value:a,dtype:s}=n,i=s||w.inferDtype(a),o=w.getArrayFromDType(i,w.sizeFromShape(r));return yZ(o,a,i),t.makeTensorInfo(r,i,o)}var gZ={kernelName:Qp,backendName:"cpu",kernelFunc:Y0};function yZ(e,t,n){e.fill(t)}var bZ={kernelName:Vl,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,a=n,s=w.getTypedArrayFromDType(r.dtype,w.sizeFromShape(r.shape)),[i,o,l,u]=r.shape,p=a.data.get(r.dataId).values;for(let h=0;h<i;h++){let d=h*l*o*u;for(let c=0;c<o;c++){let m=c*(l*u);for(let f=0;f<l;f++){let g=f*u;for(let y=0;y<u;y++){let b=Math.round(l-f-1),x=d+m+g+y,v=p[x];if(b>=0&&b<l){let I=b*u,N=d+m+I+y;v=p[N]}s[x]=v}}}}return{dataId:a.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function xZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:p,dilations:h,dimRoundingMode:d,activation:c,leakyreluAlpha:m}=r,f=H_({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:p,dilations:h,dimRoundingMode:d}});if(i){let g=f;if(p==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){let y=gt({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});f=bl({inputs:{a:f,b:y},backend:n}),n.disposeIntermediateTensorInfo(y)}else f=bl({inputs:{a:f,b:i},backend:n});n.disposeIntermediateTensorInfo(g)}if(c){let g=f;if(p==="NCHW"&&c==="prelu"&&o.shape.length===1&&o.shape[0]!==1){let y=gt({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});f=xc(n,f,c,y,m),n.disposeIntermediateTensorInfo(y)}else f=xc(n,f,c,o,m);n.disposeIntermediateTensorInfo(g)}return f}var vZ={kernelName:Ws,backendName:"cpu",kernelFunc:xZ};function wZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:p,dilations:h,dimRoundingMode:d,activation:c,leakyreluAlpha:m}=r,f=j_({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:p,dilations:h,dimRoundingMode:d}});if(i){let g=f;f=bl({inputs:{a:f,b:i},backend:n}),n.disposeIntermediateTensorInfo(g)}if(c){let g=f;f=xc(n,f,c,o,m),n.disposeIntermediateTensorInfo(g)}return f}var kZ={kernelName:Vs,backendName:"cpu",kernelFunc:wZ};function IZ(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=w.sizeFromShape(r.shape),i=a.shape,o=i[i.length-1],[l,u,p,h]=T.prepareAndValidate(r,a);if(u===0)return n.makeTensorInfo(l,r.dtype,[]);let d=n.data.get(a.dataId).values,c=n.bufferSync(r),m=u_(d,c,r.dtype,u,o,p,h,r.shape,s);return n.makeTensorInfo(l,r.dtype,m.values)}var SZ={kernelName:Gl,backendName:"cpu",kernelFunc:IZ};function NZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r;ge([a,s],"gatherV2");let l=w.parseAxisParam(i,a.shape)[0],u=n.data.get(s.dataId).values,p=a.shape[l];for(let v=0;v<u.length;++v){let I=u[v];w.assert(I<=p-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${p-1}]`)}let h=o;o==null&&(h=0);let d=w.sizeFromShape(s.shape),c=T.segment_util.collectGatherOpShapeInfo(a,s,l,h),m=gt({inputs:{x:a},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),f=gt({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,d/c.batchSize]}}),g=[c.batchSize,c.outerSize,d/c.batchSize,c.sliceSize],y=n.bufferSync(f),b=n.bufferSync(m),x=p_(b,y,g);return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(f),n.makeTensorInfo(c.outputShape,x.dtype,x.values)}var TZ={kernelName:Ul,backendName:"cpu",kernelFunc:NZ};function CZ(e){let{inputs:t,backend:n}=e,{input:r}=t,a=w.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=a/s,o=gt({inputs:{x:r},backend:n,attrs:{shape:[i,s]}}),l=q_(o,!0,n),u=gt({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}var _Z={kernelName:zc,backendName:"cpu",kernelFunc:CZ},EZ=at(Li,e=>Number.isFinite(e)?1:0,"bool"),$Z={kernelName:Li,backendName:"cpu",kernelFunc:EZ},AZ=at(zi,e=>Math.abs(e)===1/0?1:0,"bool"),FZ={kernelName:zi,backendName:"cpu",kernelFunc:AZ},RZ=at(Pi,e=>Number.isNaN(e)?1:0,"bool"),DZ={kernelName:Pi,backendName:"cpu",kernelFunc:RZ};function MZ(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=f_(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}var OZ={kernelName:Kl,backendName:"cpu",kernelFunc:MZ},LZ=at(Vi,e=>Math.log1p(e)),zZ={kernelName:Vi,backendName:"cpu",kernelFunc:LZ},PZ=_t((e,t)=>e&&t),BZ=Ut(Xl,PZ,null,"bool"),WZ={kernelName:Xl,backendName:"cpu",kernelFunc:BZ},VZ=at(Zl,e=>e?0:1,"bool"),UZ={kernelName:Zl,backendName:"cpu",kernelFunc:VZ},GZ=_t((e,t)=>e||t),HZ=Ut(Jl,GZ,null,"bool"),jZ={kernelName:Jl,backendName:"cpu",kernelFunc:HZ};function qZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r;ge(a,"LRN");let u=a.shape[3],p=u-1,h=n.data.get(a.dataId).values,d=w.sizeFromShape(a.shape),c=new Float32Array(d);function m(f){let g=f%u,y=f-g+Math.max(0,g-s),b=f-g+Math.min(g+s,p),x=0;for(;y<=b;y++){let v=h[y];x+=v*v}return x}for(let f=0;f<d;f++){let g=m(f),y=h[f]*Math.pow(i+o*g,-l);c[f]=y}return n.makeTensorInfo(a.shape,a.dtype,c)}var KZ={kernelName:Ui,backendName:"cpu",kernelFunc:qZ};function XZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:p}=r;ge(i,"LRNGrad");let h=w.sizeFromShape(i.shape),d=i.shape[3],c=n.data.get(i.dataId).values,m=n.data.get(a.dataId).values,f=n.data.get(s.dataId).values,g=new Float32Array(h),y=h;for(let b=0;b<y;b++){let x=b%d,v=b-x+Math.max(0,x-o),I=b-x+Math.min(d,x+o+1),N=0;for(let C=v;C<I;C++)N+=Math.pow(m[C],2);N=u*N+l;for(let C=v;C<I;C++){let E=-2*u*p*m[C]*f[b]/N;b===C&&(E+=Math.pow(N,-p)),E*=c[b],g[C]+=E}}return n.makeTensorInfo(i.shape,a.dtype,g)}var ZZ={kernelName:Yl,backendName:"cpu",kernelFunc:XZ};function K_(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=n,l=a.shape,u=l.length,p=w.parseAxisParam(s,l),h=p,d=T.getAxesPermutation(h,u),c=o.data.get(a.dataId).values;if(d!=null){let v=new Array(u);for(let I=0;I<v.length;I++)v[I]=l[d[I]];c=V0(c,l,a.dtype,d,v),h=T.getInnerMostAxes(h.length,u),l=v}ge(a,"max"),T.assertAxesAreInnerMostDims("max",h,u);let[m,f]=T.computeOutAndReduceShapes(l,h),g=w.sizeFromShape(f),y=y_(c,g,m,a.dtype),b=o.write(y,m,a.dtype),x=m;return i&&(x=T.expandShapeToKeepDim(m,p)),{dataId:b,shape:x,dtype:a.dtype}}var JZ={kernelName:Gi,backendName:"cpu",kernelFunc:K_};function YZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;ge(a,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,u=1;w.assert(T.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let p=T.computePool2DInfo(a.shape,s,i,u,o,l),h;if(p.filterWidth===1&&p.filterHeight===1&&w.arraysEqual(p.inShape,p.outShape))h=Xr({inputs:{x:a},backend:n});else{let d=n.data.get(a.dataId).values,c=w.computeStrides(a.shape),m=Z0(d,a.shape,a.dtype,c,p,"max");h=n.makeTensorInfo(p.outShape,a.dtype,m.values)}return h}var QZ={kernelName:ji,backendName:"cpu",kernelFunc:YZ};function e7(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;ge(a,"maxPool3d");let p=T.computePool3DInfo(a.shape,s,i,1,o,l,u),h=n.data.get(a.dataId).values,d=G_(h,a.shape,a.dtype,w.computeStrides(a.shape),p,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}var t7={kernelName:Ql,backendName:"cpu",kernelFunc:e7};function n7(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;ge([a,s],"maxPool3DGrad");let p=T.computePool3DInfo(s.shape,i,o,1,l,u),h=n.bufferSync(s),d=G8(h,p),c=p.strideDepth,m=p.strideHeight,f=p.strideWidth,g=p.dilationDepth,y=p.dilationHeight,b=p.dilationWidth,x=p.effectiveFilterDepth,v=p.effectiveFilterHeight,I=p.effectiveFilterWidth,N=x-1-p.padInfo.front,C=I-1-p.padInfo.left,E=v-1-p.padInfo.top,A=Oe(s.shape,"float32"),R=n.bufferSync(a);for(let F=0;F<p.batchSize;++F)for(let S=0;S<p.inChannels;++S)for(let M=0;M<p.inDepth;++M)for(let W=0;W<p.inHeight;++W)for(let U=0;U<p.inWidth;++U){let H=M-N,q=W-E,K=U-C,J=0;for(let Y=0;Y<x;Y+=g){let ee=(H+Y)/c;if(!(ee<0||ee>=p.outDepth||Math.floor(ee)!==ee))for(let re=0;re<v;re+=y){let te=(q+re)/m;if(!(te<0||te>=p.outHeight||Math.floor(te)!==te))for(let ae=0;ae<I;ae+=b){let se=(K+ae)/f;if(se<0||se>=p.outWidth||Math.floor(se)!==se)continue;let xe=x*v*I-1-d.get(F,ee,te,se,S),ue=Y*v*I+re*I+ae,be=xe===ue?1:0;if(be===0)continue;let ke=R.get(F,ee,te,se,S);J+=ke*be}}}A.set(J,F,M,W,U,S)}return n.makeTensorInfo(A.shape,A.dtype,A.values)}var r7={kernelName:td,backendName:"cpu",kernelFunc:n7};function a7(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;ge([s,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:p,dimRoundingMode:h}=r,d=T.computePool2DInfo(o.shape,l,u,1,p,h),c=n.data.get(o.dataId).values,m=Oe(d.outShape,o.dtype,U_(c,o.shape,o.dtype,d).values),f=d.strideHeight,g=d.strideWidth,y=d.dilationHeight,b=d.dilationWidth,x=d.effectiveFilterHeight,v=d.effectiveFilterWidth,I=v-1-d.padInfo.left,N=x-1-d.padInfo.top,C=Oe(o.shape,"float32"),E=n.data.get(a.dataId).values,A=Oe(a.shape,"float32",E);for(let R=0;R<d.batchSize;++R)for(let F=0;F<d.inChannels;++F)for(let S=0;S<d.inHeight;++S)for(let M=0;M<d.inWidth;++M){let W=S-N,U=M-I,H=0;for(let q=0;q<x;q+=y){let K=(W+q)/f;if(!(K<0||K>=d.outHeight||Math.floor(K)!==K))for(let J=0;J<v;J+=b){let Y=(U+J)/g;if(Y<0||Y>=d.outWidth||Math.floor(Y)!==Y)continue;let ee=x*v-1-m.get(R,K,Y,F),re=q*v+J,te=ee===re?1:0;if(te===0)continue;let ae=A.get(R,K,Y,F);H+=ae*te}}C.set(H,R,S,M,F)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}var s7={kernelName:ed,backendName:"cpu",kernelFunc:a7};function i7(e,t,n,r,a){let s=w.computeStrides(t),i=Z0(e,t,n,s,a,"max"),o=U_(e,t,n,a,!0,r);return[i.values,o.values]}var o7={kernelName:nd,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:a,strides:s,pad:i,includeBatchInIndex:o}=t,l=n;ge(r,"MaxPoolWithArgmax");let u=l.data.get(r.dataId).values,p=T.computePool2DInfo(r.shape,a,s,[1,1],i),[h,d]=i7(u,r.shape,r.dtype,o,p),c=l.write(h,p.outShape,r.dtype),m=l.write(d,p.outShape,r.dtype);return[{dataId:c,shape:p.outShape,dtype:r.dtype},{dataId:m,shape:p.outShape,dtype:"int32"}]}};function l7(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=w.parseAxisParam(s,a.shape),l=T.computeOutAndReduceShapes(a.shape,o)[1],u=w.sizeFromShape(l),p=[],h=n.makeTensorInfo([],"float32",new Float32Array([u]));p.push(h);let d=rs({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});p.push(d);let c=J0({inputs:{a:d,b:h},backend:n});p.push(c);let m=Vd({inputs:{x:c},backend:n,attrs:{axis:s,keepDims:i}});return p.forEach(f=>n.disposeIntermediateTensorInfo(f)),m}var u7={kernelName:qi,backendName:"cpu",kernelFunc:l7};function p7(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;ge(a,"min");let o=w.parseAxisParam(s,a.shape),l=o,u=T.getAxesPermutation(l,a.shape.length),p=a;u!=null&&(p=Dn({inputs:{x:a},backend:n,attrs:{perm:u}}),l=T.getInnerMostAxes(l.length,a.shape.length)),T.assertAxesAreInnerMostDims("min",l,p.shape.length);let[h,d]=T.computeOutAndReduceShapes(p.shape,l),c=w.sizeFromShape(d),m=w.makeZerosTypedArray(w.sizeFromShape(h),p.dtype),f=n.data.get(p.dataId).values;for(let y=0;y<m.length;++y){let b=y*c,x=f[b];for(let v=0;v<c;++v){let I=f[b+v];(Number.isNaN(I)||I<x)&&(x=I)}m[y]=x}u!=null&&n.disposeIntermediateTensorInfo(p);let g=n.makeTensorInfo(h,p.dtype,m);if(i){let y=T.expandShapeToKeepDim(h,o),b=gt({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),b}return g}var d7={kernelName:Ki,backendName:"cpu",kernelFunc:p7};function h7(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,mode:i}=r;ge(a,"mirrorPad");let o=s.map((b,x)=>b[0]+a.shape[x]+b[1]),l=s.map(b=>b[0]),u=s.map((b,x)=>b[0]+a.shape[x]),p=i==="reflect"?0:1,h=n.data.get(a.dataId).values,d=a.shape.length,c=w.computeStrides(a.shape),m=w.sizeFromShape(o),f=o.length,g=w.computeStrides(o),y=w.getTypedArrayFromDType(a.dtype,m);for(let b=0;b<m;b++){let x=w.indexToLoc(b,f,g);for(let I=0;I<f;I++)x[I]<l[I]?x[I]=l[I]*2-x[I]-p:x[I]>=u[I]&&(x[I]=(u[I]-1)*2-x[I]+p);x=x.map((I,N)=>I-l[N]);let v=w.locToIndex(x,d,c);y[b]=h[v]}return{dataId:n.write(y,o,a.dtype),shape:o,dtype:a.dtype}}var c7={kernelName:Zi,backendName:"cpu",kernelFunc:h7},m7=_t((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),f7=Ut(Ji,m7),g7={kernelName:Ji,backendName:"cpu",kernelFunc:f7},y7=ss(Cc());function X_(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=a.shape.length,o=s;if(o===-1&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);let l=w.parseAxisParam([o],a.shape),u=K_({inputs:{x:a},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),p=T.expandShapeToKeepDim(u.shape,l),h=gt({inputs:{x:u},backend:n,attrs:{shape:p}}),d=K0({inputs:{a,b:h},backend:n}),c=s_({inputs:{x:d},backend:n}),m=Vd({inputs:{x:c},backend:n,attrs:{axis:l,keepDims:!1}}),f=gt({inputs:{x:m},backend:n,attrs:{shape:p}}),g=J0({inputs:{a:c,b:f},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(f),g}var b7={kernelName:wo,backendName:"cpu",kernelFunc:X_};function x7(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r;ge(a,"multinomial");let l=o?a:X_({inputs:{logits:a},backend:n,attrs:{dim:-1}}),u=l.shape[0],p=l.shape[1],h=n.data.get(l.dataId).values,d=[u,s],c=w.makeZerosTypedArray(w.sizeFromShape(d),"int32");for(let m=0;m<u;++m){let f=m*p,g=new Float32Array(p-1);g[0]=h[f];for(let x=1;x<g.length;++x)g[x]=g[x-1]+h[f+x];let y=y7.alea(i.toString()),b=m*s;for(let x=0;x<s;++x){let v=y();c[b+x]=g.length;for(let I=0;I<g.length;I++)if(v<g[I]){c[b+x]=I;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(d,"int32",c)}var v7={kernelName:eu,backendName:"cpu",kernelFunc:x7},w7=Qr.nonMaxSuppressionV3Impl;function k7(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;ge(a,"NonMaxSuppression");let u=n.data.get(a.dataId).values,p=n.data.get(s.dataId).values,{selectedIndices:h}=w7(u,p,i,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}var I7={kernelName:ru,backendName:"cpu",kernelFunc:k7},S7=Qr.nonMaxSuppressionV4Impl;function N7(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;ge(a,"NonMaxSuppressionPadded");let p=n.data.get(a.dataId).values,h=n.data.get(s.dataId).values,{selectedIndices:d,validOutputs:c}=S7(p,h,i,o,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([c]))]}var T7={kernelName:au,backendName:"cpu",kernelFunc:N7},C7=Qr.nonMaxSuppressionV5Impl;function _7(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;ge(a,"NonMaxSuppressionWithScore");let p=n.data.get(a.dataId).values,h=n.data.get(s.dataId).values,d=i,c=o,m=l,f=u,{selectedIndices:g,selectedScores:y}=C7(p,h,d,c,m,f);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var E7={kernelName:su,backendName:"cpu",kernelFunc:_7};function $7(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r;ge(a,"oneHot");let u=w.sizeFromShape(a.shape),p=new Float32Array(u*i);p.fill(l);let h=n.data.get(a.dataId).values;for(let d=0;d<u;++d)h[d]>=0&&h[d]<i&&(p[d*i+h[d]]=o);return n.makeTensorInfo([...a.shape,i],s,p)}var A7={kernelName:Qi,backendName:"cpu",kernelFunc:$7};function wc(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){let a=Qs({inputs:{input:r},backend:n}),s=wc({inputs:{x:a},backend:n}),i=xl({inputs:{input:r},backend:n}),o=wc({inputs:{x:i},backend:n}),l=Wn({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return Y0({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var F7={kernelName:Su,backendName:"cpu",kernelFunc:wc};function Z_(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){let a=Qs({inputs:{input:r},backend:n}),s=Z_({inputs:{x:a},backend:n}),i=xl({inputs:{input:r},backend:n}),o=wc({inputs:{x:i},backend:n}),l=Wn({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return Y0({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}var R7={kernelName:iu,backendName:"cpu",kernelFunc:Z_};function J_(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(t.length===1)return vc({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach(p=>{w.assertShapesMatch(s,p.shape,"All tensors passed to stack must have matching shapes"),w.assert(i===p.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(p=>{let h=vc({inputs:{input:p},backend:n,attrs:{dim:a}});return o.push(h),h}),u=vl({inputs:l,backend:n,attrs:{axis:a}});return o.forEach(p=>n.disposeIntermediateTensorInfo(p)),u}var D7={kernelName:ou,backendName:"cpu",kernelFunc:J_};function M7(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;ge(a,"pad");let o=s.map((y,b)=>y[0]+a.shape[b]+y[1]),l=s.map(y=>y[0]),u=n.data.get(a.dataId).values,p=w.sizeFromShape(a.shape),h=a.shape.length,d=w.computeStrides(a.shape),c=w.sizeFromShape(o),m=o.length,f=w.computeStrides(o),g=w.getTypedArrayFromDType(a.dtype,c);i!==0&&g.fill(i);for(let y=0;y<p;y++){let b=w.indexToLoc(y,h,d).map((v,I)=>v+l[I]),x=w.locToIndex(b,m,f);g[x]=u[y]}return{dataId:n.write(g,o,a.dtype),shape:o,dtype:a.dtype}}var Y_={kernelName:eo,backendName:"cpu",kernelFunc:M7},O7=_t((e,t)=>Math.pow(e,t)),L7=Ut(to,O7),z7={kernelName:to,backendName:"cpu",kernelFunc:L7};function P7(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=r,l=a.map(y=>n.data.get(y.dataId).values),u=a.map(y=>y.shape),p=n.data.get(s.dataId).values,h=n.data.get(i.dataId).values,[d,c,m]=I_(l,u,p,s.shape,s.dtype,h,i.shape,o),f=d.map(y=>n.makeTensorInfo([y.length],"int32",y)),g=n.makeTensorInfo(m,s.dtype,c);return f.concat([g])}var B7={kernelName:Bc,backendName:"cpu",kernelFunc:P7};function W7(e){let{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,p]=S_(i,r.shape,r.dtype,o,a.shape,l,s.shape),h=n.makeTensorInfo([u.length],"int32",u),d=n.makeTensorInfo([p.length],r.dtype,p);return[h,d]}var V7={kernelName:Wc,backendName:"cpu",kernelFunc:W7};function U7(e){let{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.data.get(a.dataId).values,p=n.data.get(s.dataId).values,h=n.data.get(i.dataId).values,d=o.map(g=>n.data.get(g.dataId).values),c=o.map(g=>g.shape),[m,f]=N_(u,a.shape,p,s.shape,s.dtype,h,i.shape,d,c,l);return n.makeTensorInfo(m,s.dtype,f)}var G7={kernelName:Vc,backendName:"cpu",kernelFunc:U7};function H7(e){let{backend:t,attrs:n}=e,{start:r,stop:a,dtype:s,step:i}=n,o=U0(r,a,i,s);return t.makeTensorInfo([o.length],s,o)}var j7={kernelName:rd,backendName:"cpu",kernelFunc:H7},q7=at(ao,e=>1/e),K7={kernelName:ao,backendName:"cpu",kernelFunc:q7};function X7(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;ge(a,"resizeBilinear");let l=w.computeStrides(a.shape),[u,p]=o,[h,d,c,m]=a.shape,f=n.data.get(a.dataId).values,g=new Float32Array(w.sizeFromShape([h,u,p,m])),y=[s&&u>1?d-1:d,s&&p>1?c-1:c],b=[s&&u>1?u-1:u,s&&p>1?p-1:p],x=0,v=y[0]/b[0],I=y[1]/b[1];for(let N=0;N<h;N++)for(let C=0;C<u;C++){let E;i?E=v*(C+.5)-.5:E=v*C;let A=Math.max(0,Math.floor(E)),R=E-A,F=Math.min(d-1,Math.ceil(E)),S=N*l[0]+A*l[1],M=N*l[0]+F*l[1];for(let W=0;W<p;W++){let U;i?U=I*(W+.5)-.5:U=I*W;let H=Math.max(0,Math.floor(U)),q=U-H,K=Math.min(c-1,Math.ceil(U)),J=S+H*l[2],Y=M+H*l[2],ee=S+K*l[2],re=M+K*l[2];for(let te=0;te<m;te++){let ae=f[J+te],se=f[Y+te],xe=f[ee+te],ue=f[re+te],be=ae+(xe-ae)*q,ke=se+(ue-se)*q,Se=be+(ke-be)*R;g[x++]=Se}}}return n.makeTensorInfo([h,u,p,m],"float32",g)}var Z7={kernelName:oo,backendName:"cpu",kernelFunc:X7};function J7(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;ge([s,a],"resizeBilinearGrad");let o=w.computeStrides(a.shape),[l,u,p,h]=a.shape,[,d,c]=s.shape,m=new Float32Array(l*u*p*h),f=[i&&d>1?u-1:u,i&&c>1?p-1:p],g=[i&&d>1?d-1:d,i&&c>1?c-1:c],y=f[0]/g[0],b=f[1]/g[1],x=n.data.get(s.dataId).values,v=0;for(let I=0;I<l;I++){let N=I*o[0];for(let C=0;C<d;C++){let E=C*y,A=Math.floor(E),R=Math.min(Math.ceil(E),u-1),F=N+A*o[1],S=N+R*o[1],M=E-A,W=1-M;for(let U=0;U<c;U++){let H=U*b,q=Math.floor(H),K=Math.min(Math.ceil(H),p-1),J=H-q,Y=1-J,ee=F+q*o[2],re=F+K*o[2],te=S+q*o[2],ae=S+K*o[2],se=W*Y,xe=W*J,ue=M*Y,be=M*J;for(let ke=0;ke<h;ke++){let Se=x[v++];m[ee+ke]+=Se*se,m[re+ke]+=Se*xe,m[te+ke]+=Se*ue,m[ae+ke]+=Se*be}}}}return n.makeTensorInfo([l,p,u,h],"float32",m)}var Y7={kernelName:pu,backendName:"cpu",kernelFunc:J7};function Q7(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;ge(a,"resizeNearestNeighbor");let l=w.computeStrides(a.shape),[u,p]=o,[h,d,c,m]=a.shape,f=n.data.get(a.dataId).values,g=new Float32Array(h*u*p*m),y=[s&&u>1?d-1:d,s&&p>1?c-1:c],b=[s&&u>1?u-1:u,s&&p>1?p-1:p],x=y[0]/b[0],v=y[1]/b[1],I=0;for(let N=0;N<h;N++){let C=N*l[0];for(let E=0;E<u;E++){let A=i?x*(E+.5):x*E,R=Math.min(d-1,s?Math.round(A):Math.floor(A));i&&(R=Math.max(0,R));let F=C+R*l[1];for(let S=0;S<p;S++){let M=i?v*(S+.5):v*S,W=Math.min(c-1,s?Math.round(M):Math.floor(M));i&&(W=Math.max(0,W));let U=F+W*l[2];for(let H=0;H<m;H++){let q=f[U+H];g[I++]=q}}}}return n.makeTensorInfo([h,u,p,m],a.dtype,g)}var eJ={kernelName:io,backendName:"cpu",kernelFunc:Q7};function tJ(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;ge([s,a],"resizeNearestNeighborGrad");let o=w.computeStrides(a.shape),l=w.computeStrides(s.shape),[u,p,h,d]=a.shape,[,c,m]=s.shape,f=new Float32Array(u*p*h*d),g=n.data.get(s.dataId).values,y=[i&&c>1?p-1:p,i&&m>1?h-1:h],b=[i&&c>1?c-1:c,i&&m>1?m-1:m],x=y[0]/b[0],v=y[1]/b[1],I=1/x,N=1/v,C=Math.ceil(I)*2+2,E=Math.ceil(N)*2+2;for(let A=0;A<u;A++){let R=A*o[0];for(let F=0;F<p;F++){let S=R+F*o[1],M=Math.floor(F*I),W=Math.floor(M-C/2);for(let U=0;U<h;U++){let H=S+U*o[2],q=Math.floor(U*N),K=Math.floor(q-E/2);for(let J=0;J<d;J++){let Y=0;for(let ee=0;ee<C;ee++){let re=ee+W;if(re<0||re>=c)continue;let te=R+re*l[1],ae=re*x,se=Math.min(p-1,i?Math.round(ae):Math.floor(ae));if(F===se)for(let xe=0;xe<E;xe++){let ue=xe+K;if(ue<0||ue>=m)continue;let be=te+ue*l[2],ke=ue*v,Se=Math.min(h-1,i?Math.round(ke):Math.floor(ke));U===Se&&(Y+=g[be+J])}}f[H+J]=Y}}}}return n.makeTensorInfo(a.shape,a.dtype,f)}var nJ={kernelName:uu,backendName:"cpu",kernelFunc:tJ};function rJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r;ge(a,"reverse");let i=a.shape.length,o=w.parseAxisParam(s,a.shape);if(i===0)return Xr({inputs:{x:a},backend:n});let l=new Rt(a.shape,a.dtype),u=n.bufferSync(a);for(let p=0;p<l.size;p++){let h=l.indexToLoc(p),d=h.slice();o.forEach(c=>d[c]=a.shape[c]-1-d[c]),l.set(u.get(...d),...h)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}var aJ={kernelName:uo,backendName:"cpu",kernelFunc:rJ},sJ={kernelName:Nu,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:a,fillValue:s,center:i}=t,o=n,l=w.getTypedArrayFromDType(r.dtype,w.sizeFromShape(r.shape)),[u,p,h,d]=r.shape,[c,m]=T.getImageCenter(i,p,h),f=255,g=Math.sin(a),y=Math.cos(a),b=o.data.get(r.dataId).values;for(let x=0;x<u;x++){let v=x*h*p*d;for(let I=0;I<p;I++){let N=I*(h*d);for(let C=0;C<h;C++){let E=C*d;for(let A=0;A<d;A++){let R=[u,I,C,A],F=R[2],S=R[1],M=(F-c)*y-(S-m)*g,W=(F-c)*g+(S-m)*y;M=Math.round(M+c),W=Math.round(W+m);let U=s;if(typeof s!="number"&&(A===3?U=f:U=s[A]),M>=0&&M<h&&W>=0&&W<p){let q=W*(h*d),K=M*d,J=v+q+K+A;U=b[J]}let H=v+N+E+A;l[H]=U}}}}return{dataId:o.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},iJ=at(po,e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1}),oJ={kernelName:po,backendName:"cpu",kernelFunc:iJ};function lJ(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:p,outputSize:h}=T.calculateShapes(s,a,i),d=!0,c=n.bufferSync(a),m=n.bufferSync(s),f=Os(c,m,i,h,u,l,o,p,0,d);return n.makeTensorInfo(i,f.dtype,f.values)}var uJ={kernelName:du,backendName:"cpu",kernelFunc:lJ};function pJ(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<t?n=a+1:r=a;return r}function dJ(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<=t?n=a+1:r=a;return r}function hJ(e,t,n,r,a,s){let i=w.getArrayFromDType("int32",n*a);for(let o=0;o<n;++o){let l=e.slice(o*r,(o+1)*r),u=o*a;for(let p=0;p<a;++p)i[u+p]=s==="left"?pJ(l,t[p+u]):dJ(l,t[p+u])}return i}function cJ(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,u=hJ(o,l,a.shape[0],a.shape[1],s.shape[1],i);return n.makeTensorInfo(s.shape,"int32",u)}var mJ={kernelName:cu,backendName:"cpu",kernelFunc:cJ};function fJ(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t;ge([r,a,s],"select");let i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,p=sr(a.dtype,s.dtype),h=w.makeZerosTypedArray(w.sizeFromShape(a.shape),p),d=0,c=i===0||i>1||a.shape.length===1?1:w.sizeFromShape(a.shape.slice(1));for(let m=0;m<o.length;m++)for(let f=0;f<c;f++)o[m]===1?h[d++]=l[m]:h[d++]=u[m];return n.makeTensorInfo(a.shape,p,h)}var gJ={kernelName:mu,backendName:"cpu",kernelFunc:fJ},yJ=T.SELU_SCALEALPHA,bJ=T.SELU_SCALE,xJ=at(co,e=>e>=0?bJ*e:yJ*(Math.exp(e)-1)),vJ={kernelName:co,backendName:"cpu",kernelFunc:xJ},wJ=at(go,e=>e<0?-1:e>0?1:0),kJ={kernelName:go,backendName:"cpu",kernelFunc:wJ},IJ=at(mo,e=>Math.sin(e)),SJ={kernelName:mo,backendName:"cpu",kernelFunc:IJ},NJ=at(fo,e=>Math.sinh(e)),TJ={kernelName:fo,backendName:"cpu",kernelFunc:NJ},CJ=11920928955078125e-23,vI=Math.log(CJ)+2,_J=at(bo,e=>{let t=e>-vI,n=e<vI,r=Math.exp(e),a;return n?a=r:t?a=e:a=Math.log(1+r),a}),EJ={kernelName:bo,backendName:"cpu",kernelFunc:_J};function $J(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;ge([a],"spaceToBatchND");let o=w.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<a.shape.length;++g)l.push([0,0]);let u=Y_.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),p=T.getReshaped(u.shape,s,o,!1),h=T.getPermuted(p.length,s.length,!1),d=T.getReshapedPermuted(u.shape,s,o,!1),c=gt({inputs:{x:u},backend:n,attrs:{shape:p}}),m=Dn({inputs:{x:c},backend:n,attrs:{perm:h}}),f=gt({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(m),f}var AJ={kernelName:gu,backendName:"cpu",kernelFunc:$J};function FJ(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(a.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${a.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,p=n.data.get(i.dataId).values[0],[h,d,c,m,f]=__(o,r.shape,r.dtype,l,a.dtype,u,p);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],a.dtype,c),n.makeTensorInfo([m.length],"bool",new Uint8Array(m.map(g=>Number(g)))),n.makeTensorInfo([f.length],r.dtype,new Int32Array(f))]}var RJ={kernelName:ad,backendName:"cpu",kernelFunc:FJ};function DJ(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(a.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${a.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.data.get(a.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(s.dataId).values),[u,p,h]=E_(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(p,r.dtype,u),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}var MJ={kernelName:bu,backendName:"cpu",kernelFunc:DJ};function OJ(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${a.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,p]=G0(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(p,r.dtype,u)}var LJ={kernelName:sd,backendName:"cpu",kernelFunc:OJ};function zJ(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${a.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,p]=G0(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(p,r.dtype,u)}var PJ={kernelName:id,backendName:"cpu",kernelFunc:zJ};function BJ(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:p,strides:h,outputSize:d}=T.calculateShapes(s,a,o),c=!1,m=n.bufferSync(a),f;switch(s.dtype){case"bool":{let g=n.bufferSync(s),y=!!n.data.get(i.dataId).values[0];f=Os(m,g,o,d,p,u,l,h,y,c);break}case"float32":{let g=n.bufferSync(s),y=n.data.get(i.dataId).values[0];f=Os(m,g,o,d,p,u,l,h,y,c);break}case"int32":{let g=n.bufferSync(s),y=n.data.get(i.dataId).values[0];f=Os(m,g,o,d,p,u,l,h,y,c);break}case"string":{let g=n.bufferSync(s),y=w.decodeString(n.data.get(i.dataId).values[0]);f=Os(m,g,o,d,p,u,l,h,y,c);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return n.makeTensorInfo(o,f.dtype,f.values)}var WJ={kernelName:xu,backendName:"cpu",kernelFunc:BJ};function VJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=w.parseAxisParam(i,a.shape)[0],l=T.prepareSplitSize(a,s,o),u=new Array(a.shape.length).fill(0),p=a.shape.slice();return l.map(h=>{let d=[...p];d[o]=h;let c=ei({inputs:{x:a},backend:n,attrs:{begin:u,size:d}});return u[o]+=h,c})}var UJ={kernelName:yu,backendName:"cpu",kernelFunc:VJ},GJ={kernelName:od,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{let{x:n}=e,r=t;ge(n,"square");let a=r.data.get(n.dataId).values,s=new Float32Array(a.length);for(let i=0;i<a.length;++i){let o=a[i];s[i]=o*o}return{dataId:r.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},HJ=at(us,(e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),jJ={kernelName:us,backendName:"cpu",kernelFunc:HJ};function qJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:p,newAxisMask:h,shrinkAxisMask:d}=r;ge(a,"stridedSlice");let{finalShapeSparse:c,finalShape:m,isIdentity:f,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:v}=Bt.sliceInfo(a.shape,s,i,o,l,u,p,h,d),I;if(f)I=gt({inputs:{x:a},backend:n,attrs:{shape:m}});else if(g||y){w.assert(a.shape.length>=1,()=>`Input must have rank at least 1, got: ${a.shape.length}`);let N=Bt.computeOutShape(b,x,v),C=ei({inputs:{x:a},backend:n,attrs:{begin:b,size:N}});I=gt({inputs:{x:C},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(C)}else{let N=n.bufferSync(a),C=F_(c,N,v,b);I=n.makeTensorInfo(m,C.dtype,C.values)}return I}var KJ={kernelName:vu,backendName:"cpu",kernelFunc:qJ};function XJ(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:p,dataSplits:h}=t,d=n.data.get(p.dataId).values,c=n.data.get(h.dataId).values,[m,f]=H0(d,c,a,s,i,o,l,u);return[n.makeTensorInfo([m.length],"string",m),n.makeTensorInfo(h.shape,"int32",f)]}var ZJ={kernelName:ud,backendName:"cpu",kernelFunc:XJ};function JJ(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values[0],[u,p,h]=j0(o,l,a),d=p.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",p),n.makeTensorInfo([2],"int32",new Int32Array(h))]}var YJ={kernelName:pd,backendName:"cpu",kernelFunc:JJ};function QJ(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let i=n.data.get(s.dataId).values,o=q0(i,a);return n.makeTensorInfo(s.shape,"int32",o)}var eY={kernelName:dd,backendName:"cpu",kernelFunc:QJ},tY=at(So,e=>Math.tan(e)),nY={kernelName:So,backendName:"cpu",kernelFunc:tY},rY=at(No,e=>Math.tanh(e)),aY={kernelName:No,backendName:"cpu",kernelFunc:rY};function sY(e){let{inputs:t,backend:n}=e,{tensor:r,indices:a,updates:s}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:u,outputSize:p}=T.calculateShapes(s,a,r.shape),h=!1,d=n.bufferSync(a),c=n.bufferSync(s),m=n.bufferSync(r),f=Os(d,c,r.shape,p,l,o,i,u,m,h);return n.makeTensorInfo(r.shape,f.dtype,f.values)}var iY={kernelName:hu,backendName:"cpu",kernelFunc:sY};function oY(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;ge(a,"tile");let i=D_(n.bufferSync(a),s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}var lY={kernelName:ls,backendName:"cpu",kernelFunc:oY};function uY(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r;ge(a,"topk");let o=n.data.get(a.dataId).values,[l,u]=O_(o,a.shape,a.dtype,s,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}var pY={kernelName:wu,backendName:"cpu",kernelFunc:uY};function dY(e){let{inputs:t,attrs:n,backend:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[p,h,d,c]=a.shape,[m,f]=u!=null?u:[h,d],g=[p,m,f,c],y=w.computeStrides(a.shape),b=y[0],x=y[1],v=y[2],I=w.computeStrides(g),N=I[0],C=I[1],E=I[2],A=w.getTypedArrayFromDType(a.dtype,w.sizeFromShape(g));A.fill(l);let R=r.data.get(a.dataId).values,F=r.data.get(s.dataId).values;for(let S=0;S<p;++S){let M=s.shape[0]===1?F:F.subarray(S*8,S*8+8);for(let W=0;W<m;++W)for(let U=0;U<f;++U)for(let H=0;H<c;++H){let q,K=M[6]*U+M[7]*W+1;if(K===0)continue;let J=(M[0]*U+M[1]*W+M[2])/K,Y=(M[3]*U+M[4]*W+M[5])/K,ee=wI(J,d,o),re=wI(Y,h,o);switch(i){case"nearest":q=yY(R,h,d,b,x,v,S,re,ee,H,l);break;case"bilinear":q=bY(R,h,d,b,x,v,S,re,ee,H,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let te=S*N+W*C+U*E+H;A[te]=q}return r.makeTensorInfo(g,a.dtype,A)}return{dataId:r.write(A,g,a.dtype),shape:a.shape,dtype:a.dtype}}var hY={kernelName:ku,backendName:"cpu",kernelFunc:dY};function wI(e,t,n){switch(n){case"reflect":return cY(e,t);case"wrap":return mY(e,t);case"nearest":return gY(e,t);case"constant":default:return fY(e,t)}}function cY(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let r=2*t;n<r&&(n=r*Math.trunc(-n/r)+n),n=n<-t?n+r:-n-1}else if(n>t-1)if(t<=1)n=0;else{let r=2*t;n-=r*Math.trunc(n/r),n>=t&&(n=r-n-1)}return w.clamp(0,n,t-1)}function mY(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let r=t-1;n+=t*(Math.trunc(-n/r)+1)}else if(n>t-1)if(t<=1)n=0;else{let r=t-1;n-=t*Math.trunc(n/r)}return w.clamp(0,n,t-1)}function fY(e,t){return e}function gY(e,t){return w.clamp(0,e,t-1)}function hp(e,t,n,r,a,s,i,o,l,u,p){let h=i*r+o*a+l*s+u;return 0<=o&&o<t&&0<=l&&l<n?e[h]:p}function yY(e,t,n,r,a,s,i,o,l,u,p){let h=Math.round(o),d=Math.round(l);return hp(e,t,n,r,a,s,i,h,d,u,p)}function bY(e,t,n,r,a,s,i,o,l,u,p){let h=Math.floor(o),d=Math.floor(l),c=h+1,m=d+1,f=(m-l)*hp(e,t,n,r,a,s,i,h,d,u,p)+(l-d)*hp(e,t,n,r,a,s,i,h,m,u,p),g=(m-l)*hp(e,t,n,r,a,s,i,c,d,u,p)+(l-d)*hp(e,t,n,r,a,s,i,c,m,u,p);return(c-o)*f+(o-h)*g}function xY(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;ge(s,"unique");let i=r.data.get(s.dataId).values,{outputValues:o,outputShape:l,indices:u}=X0(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}var vY={kernelName:hd,backendName:"cpu",kernelFunc:xY};function wY(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a.shape.length,o=a.shape[s],l=new Array(i-1),u=0;for(let c=0;c<i;c++)c!==s&&(l[u++]=a.shape[c]);let p=new Array(i).fill(0),h=a.shape.slice();h[s]=1;let d=new Array(o);for(let c=0;c<d.length;c++){p[s]=c;let m=ei({inputs:{x:a},backend:n,attrs:{begin:p,size:h}});d[c]=gt({inputs:{x:m},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(m)}return d}var kY={kernelName:Iu,backendName:"cpu",kernelFunc:wY};function IY(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r;ge(a,"unsortedSegmentSum");let o=a.shape.length,l=s.shape.length,u=[],p=[],h=o-l,d=s;for(let m=0;m<h;++m){let f=vc({inputs:{input:d},backend:n,attrs:{dim:m+1}});d=f,p.push(f)}for(let m=0;m<i;++m){let f=w.createScalarValue(m,"int32"),g=n.makeTensorInfo([],"int32",f),y=r_({inputs:{a:g,b:d},backend:n}),b=rs({inputs:{x:y},backend:n,attrs:{dtype:"float32"}}),x=Xm({inputs:{a:b,b:a},backend:n}),v=Vd({inputs:{x},backend:n,attrs:{axis:0,keepDims:!1}});u.push(v),p.push(g),p.push(y),p.push(b),p.push(x),p.push(v)}let c=J_({inputs:u,backend:n,attrs:{axis:0}});return p.forEach(m=>n.disposeIntermediateTensorInfo(m)),c}var SY={kernelName:cd,backendName:"cpu",kernelFunc:IY},NY=[b8,J5,v8,k8,rK,S8,T8,_8,$8,F8,D8,O8,z8,W8,U8,j8,K8,Z8,Y8,g8,eX,nX,aX,sK,iX,tK,oK,lX,Y5,pX,hX,cX,fX,yX,xX,wX,IX,NX,CX,EX,AX,RX,MX,LX,zX,BX,VX,GX,HX,jX,qX,XX,YX,u8,eZ,lK,lZ,uK,uZ,dK,fZ,gZ,bZ,cK,fK,vZ,kZ,SZ,TZ,yK,xK,Q5,_Z,dX,$Z,FZ,DZ,p8,wK,IK,OZ,NK,zZ,WZ,UZ,jZ,KZ,ZZ,JZ,CK,QZ,t7,r7,s7,o7,u7,d7,EK,c7,g7,v7,AK,RK,I7,T7,E7,MK,A7,R7,D7,Y_,z7,h8,zK,B7,V7,G7,j7,eK,tx,K7,c8,m8,f8,Z7,Y7,eJ,nJ,aJ,sJ,oJ,qK,uJ,mJ,gJ,vJ,XK,kJ,SJ,TJ,ZK,b7,EJ,AJ,RJ,MJ,LJ,PJ,WJ,UJ,QK,GJ,t8,r8,jJ,KJ,ZJ,YJ,eY,o8,ZX,nY,aY,iY,lY,pY,hY,OK,vY,kY,SY,F7];for(let e of NY)md(e);var Q_={};_e(Q_,{assertNotComplex:()=>zu,bindCanvasToFramebuffer:()=>OY,bindColorTextureToFramebuffer:()=>Hh,bindTextureToProgramUniformSampler:()=>fE,bindTextureUnit:()=>hE,bindVertexBufferToProgramAttribute:()=>rx,callAndCheck:()=>de,canBeRepresented:()=>tE,createFragmentShader:()=>aE,createFramebuffer:()=>dE,createProgram:()=>sE,createStaticIndexBuffer:()=>lE,createStaticVertexBuffer:()=>oE,createTexture:()=>uE,createVertexShader:()=>rE,getBatchDim:()=>ti,getExtensionOrThrow:()=>cp,getFramebufferErrorMessage:()=>gE,getMaxTexturesInShader:()=>vE,getNumChannels:()=>DY,getProgramUniformLocation:()=>mE,getProgramUniformLocationOrThrow:()=>cE,getRowsCols:()=>ni,getShapeAs3D:()=>fp,getTextureShapeFromLogicalShape:()=>bE,getWebGLDisjointQueryTimerVersion:()=>wE,getWebGLErrorMessage:()=>nE,getWebGLMaxTextureSize:()=>xE,hasExtension:()=>nr,isCapableOfRenderingToFloatTexture:()=>kE,isDownloadFloatTextureEnabled:()=>IE,isReshapeFree:()=>Lp,isWebGLFenceEnabled:()=>SE,isWebGLVersionEnabled:()=>sx,linkProgram:()=>iE,logShaderSourceAndInfoLog:()=>e1,resetMaxTextureSize:()=>LY,resetMaxTexturesInShader:()=>zY,unbindColorTextureFromFramebuffer:()=>ax,unbindTextureUnit:()=>MY,validateFramebuffer:()=>mp,validateProgram:()=>Gh,validateTextureSize:()=>pE});var Ds={},Dh={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function eE(e,t){Ds[e]=t}function $r(e,t){if(!(e in Ds)||t!=null){let r=CY(e,t);if(r!==null)Ds[e]=r;else return console.log("Could not get context for WebGL version",e),null}let n=Ds[e];return n==null||n.isContextLost()?(delete Ds[e],$r(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),Ds[e])}function TY(e){if(!G().getBool("IS_SAFARI")&&typeof OffscreenCanvas!="undefined"&&e===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function CY(e,t){if(e!==1&&e!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let n=t==null?TY(e):t;return n.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete Ds[e]},!1),G().getBool("SOFTWARE_WEBGL_ENABLED")&&(Dh.failIfMajorPerformanceCaveat=!1),e===1?n.getContext("webgl",Dh)||n.getContext("experimental-webgl",Dh):n.getContext("webgl2",Dh)}var Op;(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"})(Op||(Op={}));var tr;(function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"})(tr||(tr={}));var rn;(function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(rn||(rn={}));function Ud(e,t){return[t,e]}function _Y(e,t){return e*t}function Mh(e){let t=w.sizeFromShape(e),n=Math.ceil(t/4);return w.sizeToSquarishShape(n)}function Lu(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function EY(e,t){let[n,r]=Lu(e,t);return n*r*4}function Q0(e,t){let n=e,r,a,s,i,o,l,u,p,h,d;return G().getNumber("WEBGL_VERSION")===2?(r=n.R32F,a=n.R16F,s=n.RGBA16F,i=n.RGBA32F,o=n.RED,u=4,p=1,h=n.HALF_FLOAT,d=n.FLOAT,l=n.RGBA8):(r=e.RGBA,a=e.RGBA,s=e.RGBA,i=n.RGBA,o=e.RGBA,u=4,p=4,h=t!=null?t.HALF_FLOAT_OES:null,d=e.FLOAT,l=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:a,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:p,textureTypeHalfFloat:h,textureTypeFloat:d}}function de(e,t){let n=t();return G().getBool("DEBUG")&&$Y(e),n}function $Y(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+nE(e,t))}var AY=596e-10,FY=65504;function tE(e){return!!(G().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||e===0||AY<Math.abs(e)&&Math.abs(e)<FY)}function nE(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function cp(e,t){return ka(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function rE(e,t){let n=ka(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(de(e,()=>e.shaderSource(n,t)),de(e,()=>e.compileShader(n)),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function aE(e,t){let n=ka(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(de(e,()=>e.shaderSource(n,t)),de(e,()=>e.compileShader(n)),G().get("ENGINE_COMPILE_ONLY"))return n;if(e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw e1(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var RY=/ERROR: [0-9]+:([0-9]+):/g;function e1(e,t){let n=RY.exec(t);if(n==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}let r=+n[1],a=e.split(`
`),s=a.length.toString().length+2,i=a.map((h,d)=>w.rightPad((d+1).toString(),s)+h),o=0;for(let h=0;h<i.length;h++)o=Math.max(i[h].length,o);let l=i.slice(0,r-1),u=i.slice(r-1,r),p=i.slice(r);console.log(l.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${w.rightPad(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(p.join(`
`))}function sE(e){return ka(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function iE(e,t){if(de(e,()=>e.linkProgram(t)),!G().get("ENGINE_COMPILE_ONLY")&&e.getProgramParameter(t,e.LINK_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function Gh(e,t){if(de(e,()=>e.validateProgram(t)),e.getProgramParameter(t,e.VALIDATE_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function oE(e,t){let n=ka(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return de(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),de(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function lE(e,t){let n=ka(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return de(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),de(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function DY(){return G().getNumber("WEBGL_VERSION")===2?1:4}function uE(e){return ka(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function pE(e,t){let n=G().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){let r=`[${e}x${t}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(e>n||t>n){let r=`[${e}x${t}]`,a=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+a+".")}}function dE(e){return ka(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function rx(e,t,n,r,a,s,i){let o=e.getAttribLocation(t,n);return o===-1?!1:(de(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),de(e,()=>e.vertexAttribPointer(o,a,e.FLOAT,!1,s,i)),de(e,()=>e.enableVertexAttribArray(o)),!0)}function hE(e,t,n){yE(e,n),de(e,()=>e.activeTexture(e.TEXTURE0+n)),de(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function MY(e,t){yE(e,t),de(e,()=>e.activeTexture(e.TEXTURE0+t)),de(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function cE(e,t,n){return ka(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function mE(e,t,n){return e.getUniformLocation(t,n)}function fE(e,t,n,r){de(e,()=>hE(e,t,r)),de(e,()=>e.uniform1i(n,r))}function OY(e){de(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),de(e,()=>e.viewport(0,0,e.canvas.width,e.canvas.height)),de(e,()=>e.scissor(0,0,e.canvas.width,e.canvas.height))}function Hh(e,t,n){de(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),de(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function ax(e,t){de(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),de(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function mp(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+gE(e,t))}function gE(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function ka(e,t,n){let r=de(e,()=>t());if(r==null)throw new Error(n);return r}function yE(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){let a=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${a}.`)}}function ti(e,t=2){return w.sizeFromShape(e.slice(0,e.length-t))}function ni(e){if(e.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function fp(e){let t=[1,1,1];return e.length===0||e.length===1&&e[0]===1||(t=[ti(e),...ni(e)]),t}function bE(e,t=!1){let n=G().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=G().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&G().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n=n*2,r=r*2,e=e.map((o,l)=>l>=e.length-2?w.nearestLargerEven(e[l]):e[l]),e.length===1&&(e=[2,e[0]])),e.length!==2&&(e=w.squeezeShape(e).newShape);let a=w.sizeFromShape(e),s=null;e.length<=1&&a<=n?s=[1,a]:e.length===2&&e[0]<=n&&e[1]<=n?s=e:e.length===3&&e[0]*e[1]<=n&&e[2]<=n?s=[e[0]*e[1],e[2]]:e.length===3&&e[0]<=n&&e[1]*e[2]<=n?s=[e[0],e[1]*e[2]]:e.length===4&&e[0]*e[1]*e[2]<=n&&e[3]<=n?s=[e[0]*e[1]*e[2],e[3]]:e.length===4&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(s=[e[0],e[1]*e[2]*e[3]]);let i=s!=null&&Math.max(...s)>r&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(s==null||i)if(t){let o=ti(e),l=2,u=2;e.length&&([l,u]=ni(e)),a=o*(l/2)*(u/2),s=w.sizeToSquarishShape(a).map(p=>p*2)}else s=w.sizeToSquarishShape(a);return s}function Oh(e){return e%2===0}function Lp(e,t){if(e=e.slice(-2),t=t.slice(-2),w.arraysEqual(e,t)||!e.length||!t.length||e[0]===0||e[1]===0||t[0]===0||t[1]===0)return!0;if(e.length!==t.length){let n=e[e.length-1],r=t[t.length-1];if(n===r||Oh(n)&&Oh(r)&&(e[0]===1||t[0]===1))return!0}return e[1]===t[1]&&Oh(e[0])&&Oh(t[0])}var jh,qh;function xE(e){if(jh==null){let t=$r(e);jh=t.getParameter(t.MAX_TEXTURE_SIZE)}return jh}function LY(){jh=null}function zY(){qh=null}function vE(e){if(qh==null){let t=$r(e);qh=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,qh)}function wE(e){if(e===0)return 0;let t,n=$r(e);return nr(n,"EXT_disjoint_timer_query_webgl2")&&e===2?t=2:nr(n,"EXT_disjoint_timer_query")?t=1:t=0,t}function nr(e,t){return e.getExtension(t)!=null}function sx(e){try{if($r(e)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function kE(e){if(e===0)return!1;let t=$r(e);if(e===1){if(!nr(t,"OES_texture_float"))return!1}else if(!nr(t,"EXT_color_buffer_float"))return!1;return ix(t)}function IE(e){if(e===0)return!1;let t=$r(e);if(e===1){if(!nr(t,"OES_texture_float")||!nr(t,"WEBGL_color_buffer_float"))return!1}else{if(nr(t,"EXT_color_buffer_float"))return ix(t);let n="EXT_color_buffer_half_float";if(nr(t,n)){let r=t.getExtension(n);return PY(t,r)}return!1}return ix(t)}function ix(e){let t=Q0(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);let r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),a}function PY(e,t){let n=Q0(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(a),s}function SE(e){return e!==2?!1:$r(e).fenceSync!=null}function zu(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&w.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var ye=G();ye.registerFlag("HAS_WEBGL",()=>ye.getNumber("WEBGL_VERSION")>0);ye.registerFlag("WEBGL_VERSION",()=>sx(2)?2:sx(1)?1:0);ye.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);ye.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>ye.get("WEBGL_VERSION")===2);ye.registerFlag("WEBGL_CPU_FORWARD",()=>!0);ye.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);ye.registerFlag("WEBGL_PACK",()=>ye.getBool("HAS_WEBGL"));ye.registerFlag("WEBGL_PACK_NORMALIZATION",()=>ye.getBool("WEBGL_PACK"));ye.registerFlag("WEBGL_PACK_CLIP",()=>ye.getBool("WEBGL_PACK"));ye.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>ye.getBool("WEBGL_PACK"));ye.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>ye.getBool("WEBGL_PACK"));ye.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>ye.getBool("WEBGL_PACK"));ye.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>ye.getBool("WEBGL_PACK"));ye.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>ye.getBool("WEBGL_PACK"));ye.registerFlag("WEBGL_PACK_REDUCE",()=>ye.getBool("WEBGL_PACK"));ye.registerFlag("WEBGL_LAZILY_UNPACK",()=>ye.getBool("WEBGL_PACK"));ye.registerFlag("WEBGL_CONV_IM2COL",()=>ye.getBool("WEBGL_PACK"));ye.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>ye.getBool("WEBGL_PACK"));ye.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>xE(ye.getNumber("WEBGL_VERSION")));ye.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>vE(ye.getNumber("WEBGL_VERSION")));ye.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let e=ye.getNumber("WEBGL_VERSION");return e===0?0:wE(e)});ye.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>ye.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!yd.isMobile());ye.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>kE(ye.getNumber("WEBGL_VERSION")));ye.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>ye.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:ye.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));ye.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>IE(ye.getNumber("WEBGL_VERSION")));ye.registerFlag("WEBGL_FENCE_API_ENABLED",()=>SE(ye.getNumber("WEBGL_VERSION")));ye.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>ye.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);ye.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)});ye.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>yd.isMobile()?1:-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});ye.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);ye.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);ye.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);ye.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);ye.registerFlag("WEBGL_EXP_CONV",()=>!1);ye.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>ye.getBool("IS_TEST"));ye.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);ye.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);ye.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);ye.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function In(){let e,t,n,r,a,s,i,o,l,u;return G().getNumber("WEBGL_VERSION")===2?(e="#version 300 es",t="in",n="out",r="in",a="texture",s="outputColor",i="out vec4 outputColor;",o=G().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e="",t="attribute",n="varying",r="varying",a="texture2D",s="gl_FragColor",i="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:a,output:s,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function Ro(e,t,n="index"){let r=w.computeStrides(t);return r.map((a,s)=>{let i=`int ${e[s]} = ${n} / ${a}`,o=s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${a}`:`index -= ${e[s]} * ${a}`;return`${i}; ${o};`}).join("")}function Zm(e,t,n="index"){let r=w.computeStrides(t);return r.map((a,s)=>{let i=`int ${e[s]} = ${n} / outShapeStrides[${s}]`,o=s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * outShapeStrides[${s}]`:`index -= ${e[s]} * outShapeStrides[${s}]`;return`${i}; ${o};`}).join("")}function BY(e,t){let n=e.length,r=e.map(s=>`${t}[${s}]`),a=new Array(n-1);a[n-2]=r[n-1];for(let s=n-3;s>=0;--s)a[s]=`(${a[s+1]} * ${r[s+1]})`;return a}function WY(e,t,n="index"){let r=e.map((s,i)=>i),a=BY(r,t);return a.map((s,i)=>{let o=`int ${e[i]} = ${n} / ${a[i]}`,l=i===a.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${a[i]}`:`index -= ${e[i]} * ${a[i]}`;return`${o}; ${l};`}).join("")}function t1(e){let t=w.computeStrides(e).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function n1(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var NE=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:TE}=T;function VY(e,t,n){let r=[];if(e.forEach(d=>{let c=w.sizeFromShape(d.shapeInfo.logicalShape);if(d.shapeInfo.isUniform?r.push(`uniform float ${d.name}${c>1?`[${c}]`:""};`):(r.push(`uniform sampler2D ${d.name};`),r.push(`uniform int offset${d.name};`)),n.enableShapeUniforms){let{uniformShape:m}=r1(n.packedInputs,d.shapeInfo.logicalShape,d.shapeInfo.texShape);switch(m.length){case 1:r.push(`uniform int ${d.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${d.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${d.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${d.name}Shape;`);break;default:break}r.push(`uniform ivec2 ${d.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break;default:break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(d=>{r.push(`uniform ${d.type} ${d.name}${d.arrayIndex?`[${d.arrayIndex}]`:""};`)});let a=r.join(`
`),s=e.map(d=>UY(d,t,n.packedInputs,n.enableShapeUniforms)).join(`
`),i=t.texShape,o=In(),l=jY(o),u,p,h=XY(o);return t.isPacked?(u=GY(t.logicalShape,i,n.enableShapeUniforms),p=KY(o)):(u=HY(t.logicalShape,i,n.enableShapeUniforms),p=qY(o)),n.packedInputs&&(h+=QY),[h,l,p,a,u,s,n.userCode].join(`
`)}function Pu(e,t=!1){let n=e.shapeInfo.logicalShape;switch(n.length){case 0:return d9(e,t);case 1:return c9(e,t);case 2:return f9(e,t);case 3:return y9(e,t);case 4:return x9(e,t);case 5:return v9(e);case 6:return w9(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function CE(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return p9(e);case 1:return h9(e,t);case 2:return m9(e,t);case 3:return g9(e,t);default:return b9(e,t)}}function UY(e,t,n=!1,r){let a="";n?a+=CE(e,r):a+=Pu(e,r);let s=e.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(n?a+=k9(e,t):a+=I9(e,t)),a}function GY(e,t,n){switch(e.length){case 0:return _E();case 1:return e9(e,t,n);case 2:return l9(e,t,n);case 3:return n9(e,t,n);default:return a9(e,t,n)}}function HY(e,t,n){switch(e.length){case 0:return _E();case 1:return t9(e,t,n);case 2:return u9(e,t,n);case 3:return r9(e,t,n);case 4:return s9(e,t,n);case 5:return i9(e,t);case 6:return o9(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function jY(e){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e.texture2D}(textureSampler, uv).r;
    }
  `}function qY(e){return`
    void setOutput(float val) {
      ${e.output} = vec4(val, 0, 0, 0);
    }
  `}function KY(e){return`
    void setOutput(vec4 val) {
      ${e.output} = val;
    }
  `}function XY(e){return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${ZY}
    ${JY}
    ${YY}
  `}var ZY=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,JY=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,YY=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,QY=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function _E(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function e9(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return r[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function t9(e,t,n){return t[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function n9(e,t,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[2]/2),s=a*Math.ceil(e[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${a});
      int c = imod(index, ${a}) * 2;

      return ivec3(b, r, c);
    }
  `}function r9(e,t,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Zm(["r","c","d"],e)}
    return ivec3(r, c, d);
  }
`;let r=Ro(["r","c","d"],e);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function a9(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[e.length-1]/2),s=a*Math.ceil(e[e.length-2]/2),i=s,o="",l="b, r, c";for(let u=2;u<e.length-1;u++)i*=e[e.length-u-1],o=`
      int b${u} = index / ${i};
      index -= b${u} * ${i};
    `+o,l=`b${u}, `+l;return`
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${o}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${a});
      int c = imod(index, ${a}) * 2;

      return ivec${e.length}(${l});
    }
  `}function s9(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Zm(["r","c","d","d2"],e)}
      return ivec4(r, c, d, d2);
    }
  `;let r=Ro(["r","c","d","d2"],e);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function i9(e,t){let n=Ro(["r","c","d","d2","d3"],e);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function o9(e,t){let n=Ro(["r","c","d","d2","d3","d4"],e);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function l9(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(w.arraysEqual(e,t))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;let a=Math.ceil(e[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${a});
      int c = imod(index, ${a}) * 2;

      return ivec2(r, c);
    }
  `}function u9(e,t,n){return w.arraysEqual(e,t)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:e[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:e[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${e[1]};
      int c = index - r * ${e[1]};
      return ivec2(r, c);
    }
  `}function Do(e){return`offset${e}`}function p9(e){let t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=In();return`
    vec4 ${n}() {
      return ${r.texture2D}(${t}, halfCR);
    }
  `}function d9(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;let[a,s]=e.shapeInfo.texShape;if(a===1&&s===1)return`
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;let i=Do(n);if(t)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});
      return sampleTexture(${n}, uv);
    }
  `;let[o,l]=e.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${o}, ${l}, ${i});
      return sampleTexture(${n}, uv);
    }
  `}function h9(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e.shapeInfo.texShape,s=In();if(t)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${n}, uv);
    }
  `;let i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${s.texture2D}(${n}, uv);
    }
  `}function c9(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${Bu(e)}
      }
    `;let a=e.shapeInfo.texShape,s=a[0],i=a[1];if(i===1&&s===1)return`
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;let o=Do(n);return i===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);
        return sampleTexture(${n}, uv);
      }
    `:s===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:t?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${s}, ${i}, index + ${o});
      return sampleTexture(${n}, uv);
    }
  `}function m9(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=s[0],o=s[1],l=In();if(s!=null&&w.arraysEqual(n,s))return t?`
      vec4 ${a}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${a}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(t)return`
    vec4 ${a}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;let u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],p=Math.ceil(n[1]/2);return`
    vec4 ${a}(int row, int col) {
      vec2 uv = packedUVfrom2D(${p}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function f9(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape;if(s!=null&&w.arraysEqual(n,s)){if(t)return`
      float ${a}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;let d=s[0],c=s[1];return`
    float ${a}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${c}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `}let{newShape:i,keptDims:o}=w.squeezeShape(n),l=i;if(l.length<n.length){let d=Wu(e,l),c=["row","col"];return`
      ${Pu(d,t)}
      float ${a}(int row, int col) {
        return ${a}(${Vu(c,o)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${a}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${Bu(e)}
      }
    `;let u=s[0],p=s[1],h=Do(r);return p===1?t?`
      float ${a}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${a}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${r}, uv);
    }
  `:u===1?t?`
      float ${a}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${a}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${p}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:t?`
      float ${a}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${a}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${h};
    vec2 uv = uvFromFlat(${u}, ${p}, index);
    return sampleTexture(${r}, uv);
  }
`}function g9(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(n[0]===1){let d=n.slice(1),c=[1,2],m=Wu(e,d),f=["b","row","col"];return`
        ${CE(m,t)}
        vec4 ${a}(int b, int row, int col) {
          return ${a}(${Vu(f,c)});
        }
      `}let o=In();if(t)return`
    vec4 ${a}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `;let l=i[0],u=i[1],p=Math.ceil(n[2]/2),h=p*Math.ceil(n[1]/2);return`
    vec4 ${a}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${u}, ${h}, ${p}, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `}function y9(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=w.squeezeShape(n),u=o;if(u.length<n.length){let f=Wu(e,u),g=["row","col","depth"];return`
        ${Pu(f,t)}
        float ${a}(int row, int col, int depth) {
          return ${a}(${Vu(g,l)});
        }
      `}if(e.shapeInfo.isUniform)return`
      float ${a}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${i}, 1)));
        ${Bu(e)}
      }
    `;let p=e.shapeInfo.texShape,h=p[0],d=p[1],c=e.shapeInfo.flatOffset;if(d===s&&c==null)return t?`
      float ${a}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${a}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${h}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(d===i&&c==null)return t?`
      float ${a}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${a}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);
      return sampleTexture(${r}, uv);
    }
  `;let m=Do(r);return t?`
    float ${a}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${m};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${a}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${i} + depth + ${m};
        vec2 uv = uvFromFlat(${h}, ${d}, index);
        return sampleTexture(${r}, uv);
      }
  `}function b9(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=In();if(t)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${a.texture2D}(${n}, uv);
    }
  `;let s=e.shapeInfo.logicalShape,i=s.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],p=l[1],h=Math.ceil(s[i-1]/2),d=h*Math.ceil(s[i-2]/2),c="int b, int row, int col",m=`b * ${d} + (row / 2) * ${h} + (col / 2)`;for(let f=2;f<i-1;f++)c=`int b${f}, `+c,d*=s[i-f-1],m=`b${f} * ${d} + `+m;return`
    vec4 ${r}(${c}) {
      int index = ${m};
      int texR = index / ${p};
      int texC = index - texR * ${p};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${u});
      return ${a.texture2D}(${n}, uv);
    }
  `}function x9(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[3],i=n[2]*s,o=n[1]*i,{newShape:l,keptDims:u}=w.squeezeShape(n);if(l.length<n.length){let b=Wu(e,l),x=["row","col","depth","depth2"];return`
      ${Pu(b,t)}
      float ${a}(int row, int col, int depth, int depth2) {
        return ${a}(${Vu(x,u)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${a}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${i}, ${s}, 1)));
        ${Bu(e)}
      }
    `;let p=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],c=h[1],m=`int stride2 = ${r}Shape[3];`,f=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(c===o&&p==null)return t?`
      float ${a}(int row, int col, int depth, int depth2) {
        ${m}
        ${f}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${a}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${c}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(c===s&&p==null)return t?`
      float ${a}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${a}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${c}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;let y=Do(r);return t?`
    float ${a}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${m}
      ${f}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${a}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${d}, ${c}, index + ${y});
      return sampleTexture(${r}, uv);
    }
  `}function v9(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t[4],s=t[3]*a,i=t[2]*s,o=t[1]*i,{newShape:l,keptDims:u}=w.squeezeShape(t);if(l.length<t.length){let f=Wu(e,l),g=["row","col","depth","depth2","depth3"];return`
      ${Pu(f)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${Vu(g,u)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${i}, ${s}, ${a})) +
          depth3;
        ${Bu(e)}
      }
    `;let p=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],c=h[1];if(c===o&&p==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${s}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${c}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(c===a&&p==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${c}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;let m=Do(n);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} + depth * ${s} +
          depth2 * ${a} + depth3 + ${m};
      vec2 uv = uvFromFlat(${d}, ${c}, index);
      return sampleTexture(${n}, uv);
    }
  `}function w9(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:a,keptDims:s}=w.squeezeShape(t);if(a.length<t.length){let g=Wu(e,a),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${Pu(g)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${Vu(y,s)});
      }
    `}let i=t[5],o=t[4]*i,l=t[3]*o,u=t[2]*l,p=t[1]*u;if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${p}, ${u}, ${l}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${Bu(e)}
      }
    `;let h=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,c=d[0],m=d[1];if(m===p&&h==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${o}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${c}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(m===i&&h==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${c}.0);
        return sampleTexture(${n}, uv);
      }
    `;let f=Do(n);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${p} + col * ${u} + depth * ${l} +
          depth2 * ${o} + depth3 * ${i} + depth4 + ${f};
      vec2 uv = uvFromFlat(${c}, ${m}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Bu(e){let t=e.name,n=w.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function k9(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=TE(e.shapeInfo.logicalShape,t.logicalShape),l=ut(i),u=i-s,p,h=["x","y","z","w","u","v"];s===0?p="":i<2&&o.length>=1?p="coords = 0;":p=o.map(g=>`coords.${h[g+u]} = 0;`).join(`
`);let d="";i<2&&s>0?d="coords":d=e.shapeInfo.logicalShape.map((g,y)=>`coords.${h[y+u]}`).join(", ");let c="return outputValue;",m=w.sizeFromShape(e.shapeInfo.logicalShape)===1,f=w.sizeFromShape(t.logicalShape)===1;if(s===1&&!m&&!f)c=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(m&&!f)i===1?c=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:c=`
        return vec4(outputValue.x);
      `;else if(o.length){let g=s-2,y=s-1;o.indexOf(g)>-1&&o.indexOf(y)>-1?c="return vec4(outputValue.x);":o.indexOf(g)>-1?c="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(y)>-1&&(c="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${a}() {
      ${l} coords = getOutputCoords();
      ${p}
      vec4 outputValue = get${r}(${d});
      ${c}
    }
  `}function I9(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&e.shapeInfo.flatOffset==null&&w.arraysEqual(i,s))return`
      float ${a}() {
        return sampleTexture(${n}, resultUV);
      }
    `;let u=ut(l),p=TE(e.shapeInfo.logicalShape,t.logicalShape),h=l-o,d,c=["x","y","z","w","u","v"];o===0?d="":l<2&&p.length>=1?d="coords = 0;":d=p.map(f=>`coords.${c[f+h]} = 0;`).join(`
`);let m="";return l<2&&o>0?m="coords":m=e.shapeInfo.logicalShape.map((f,g)=>`coords.${c[g+h]}`).join(", "),`
    float ${a}() {
      ${u} coords = getOutputCoords();
      ${d}
      return get${r}(${m});
    }
  `}function ut(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function r1(e,t,n){let{newShape:r,keptDims:a}=w.squeezeShape(t),s=t.length,i=e&&s===3&&t[0]===1,o=i?t.slice(1):r,l=!e&&s>1&&!w.arraysEqual(t,n)&&r.length<s||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:a}}function Wu(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function Vu(e,t){return t.map(n=>e[n]).join(", ")}function S9(e,t,n,r){let a=n.map((p,h)=>{let d={logicalShape:p.shape,texShape:p.isUniform?null:p.texData.texShape,isUniform:p.isUniform,isPacked:p.isUniform?!1:p.texData.isPacked,flatOffset:null};return p.texData!=null&&p.texData.slice!=null&&p.texData.slice.flatOffset>0&&(d.flatOffset=p.texData.slice.flatOffset),{name:t.variableNames[h],shapeInfo:d}}),s=a.map(p=>p.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=VY(a,i,t),l=aE(e.gl,o),u=e.createProgram(l);return G().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(u),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i},EE(e,t,u)))}function EE(e,t,n){let r=[],a=[],s,i,o,l=null,u=null;u=e.getUniformLocation(n,"NAN",!1),G().getNumber("WEBGL_VERSION")===1&&(l=e.getUniformLocation(n,"INFINITY",!1));let p=!1;for(let h of t.variableNames){let d={name:h,uniform:e.getUniformLocation(n,h,p),offset:e.getUniformLocation(n,`offset${h}`,p)};t.enableShapeUniforms&&(d.shape=e.getUniformLocation(n,`${h}Shape`,p),d.texShape=e.getUniformLocation(n,`${h}TexShape`,p)),r.push(d)}if(t.enableShapeUniforms&&(s=e.getUniformLocation(n,"outShape",p),o=e.getUniformLocation(n,"outShapeStrides",p),i=e.getUniformLocation(n,"outTexShape",p)),t.customUniforms)for(let h of t.customUniforms)a.push(e.getUniformLocation(n,h.name,p));return{variablesLocations:r,customUniformLocations:a,infLoc:l,nanLoc:u,outShapeLocation:s,outShapeStridesLocation:o,outTexShapeLocation:i}}function kI(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((n,r)=>{let a=n.logicalShape,s=t[r],i=s.shape;if(!w.arraysEqual(a,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${a} and ${i} must match`);if(n.isUniform&&s.isUniform)return;let o=n.texShape,l=s.isUniform?null:s.texData.texShape;if(!w.arraysEqual(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}function N9(e,t,n,r,a){t.program.enableShapeUniforms||(kI(t.inShapeInfos,n),kI([t.outShapeInfo],[r]));let s=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):e.setOutputMatrixTexture(s.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),G().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&e.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){let u=n[l],{uniform:p,offset:h,shape:d,texShape:c}=t.variablesLocations[l];if(d){let{uniformShape:m}=r1(t.program.packedInputs,u.shape,u.texData.texShape);switch(m.length){case 1:e.gl.uniform1iv(d,new Int32Array(m));break;case 2:e.gl.uniform2iv(d,new Int32Array(m));break;case 3:e.gl.uniform3iv(d,new Int32Array(m));break;case 4:e.gl.uniform4iv(d,new Int32Array(m));break;default:break}}if(c&&e.gl.uniform2i(c,u.texData.texShape[0],u.texData.texShape[1]),p!=null){if(u.isUniform){if(w.sizeFromShape(u.shape)<2)e.gl.uniform1f(p,u.uniformValues[0]);else{let m=u.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),e.gl.uniform1fv(p,m)}continue}u.texData.slice!=null&&h!=null&&e.gl.uniform1i(h,u.texData.slice.flatOffset),e.setInputMatrixTexture(u.texData.texture.texture,p,l)}}let o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape));break;default:break}if(t.outShapeStridesLocation){let l=w.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l));break;default:break}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&a)for(let l=0;l<t.program.customUniforms.length;++l){let u=t.program.customUniforms[l],p=t.customUniformLocations[l],h=a[l];if(u.type==="float")e.gl.uniform1fv(p,h);else if(u.type==="vec2")e.gl.uniform2fv(p,h);else if(u.type==="vec3")e.gl.uniform3fv(p,h);else if(u.type==="vec4")e.gl.uniform4fv(p,h);else if(u.type==="int")e.gl.uniform1iv(p,h);else if(u.type==="ivec2")e.gl.uniform2iv(p,h);else if(u.type==="ivec3")e.gl.uniform3iv(p,h);else if(u.type==="ivec4")e.gl.uniform4iv(p,h);else throw Error(`uniform type ${u.type} is not supported yet.`)}e.executeProgram()}function T9(e,t,n){let r="";t.concat(n).forEach(i=>{let o=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!i.isUniform){let l=i.texData.texShape,{useSqueezeShape:u,uniformShape:p,keptDims:h}=r1(e.packedInputs,i.shape,l),d="",c="",m="";if(p.length===1&&e.packedInputs){let I=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];d=`${I[0]>1}_${I[1]>1}`}else if(p.length===2&&!e.packedInputs)c=`${p[0]>1}_${p[1]>1}`;else if(p.length>2&&!e.packedInputs){let I=w.computeStrides(p);m=`${I[0]===l[1]}_${I[I.length-1]===l[1]}`}let f=i.shape.length,g=p.length===2&&w.arraysEqual(i.shape,l),y=w.sizeFromShape(i.shape)===1,b=T.getBroadcastDims(i.shape,n.shape),x=!e.packedInputs&&f===n.shape.length&&w.arraysEqual(l,n.texData.texShape),v=e.packedInputs||p.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${f}_${x}_${u?h:""}_${p.length}_${y}_${b}_${g}_${d}_${c}_${m}_${v}_${o}`}else{let l=i.isUniform?"uniform":i.texData.texShape;r+=`${i.shape}_${l}_${o}`}});let a=e.userCode,s=e.constructor.name;return s+="_"+r+"_"+a+`${G().getNumber("WEBGL_VERSION")}`,s}function cn(e){return G().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var C9=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Op.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=In();this.outputShape=e,this.enableShapeUniforms=cn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Zm(["r","c","d"],e):Ro(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}},_9=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Op.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=In();this.outputShape=e,this.enableShapeUniforms=cn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Zm(["r","c","d"],e):Ro(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}},E9=class{constructor(e){this.variableNames=["A"],this.outTexUsage=tr.DOWNLOAD;let t=In();this.outputShape=e,this.userCode=`
      ${NE}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}},$9=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=tr.DOWNLOAD;let t=In();this.outputShape=e,this.userCode=`
      ${NE}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}},A9={R:0,G:1,B:2,A:3},II=class{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=In();this.outputShape=e,this.enableShapeUniforms=cn(this.outputShape.length);let a="result";t&&(a="floor(result * 255. + 0.5)");let s="";for(let i=0;i<n.length;i++){let o=n[i];s+=`
          if(offset == ${i}) {
            result = values[${A9[o]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?n1():t1(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${n.length});

        flatIndex = idiv(flatIndex, ${n.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${s}
        }
        ${r.output} = vec4(${a}, 0., 0., 0.);
      }
    `}},F9=class{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=In();this.outputShape=e,this.enableShapeUniforms=cn(this.outputShape.length);let r="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let s=0;s<=1;s++)for(let i=0;i<=1;i++){let o=s*2+i;r+=`
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${s} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${s};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${o}] = values[0];
            } else if (offset == 1) {
              result[${o}] = values[1];
            } else if (offset == 2) {
              result[${o}] = values[2];
            } else {
              result[${o}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?n1():t1(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${n.output} = ${a};
        }
    `}},$E={};_e($E,{bindVertexProgramAttributeStreams:()=>PE,createBufferFromOutputTexture:()=>VE,createFloat16MatrixTexture:()=>ME,createFloat16PackedMatrixTexture:()=>zE,createFloat32MatrixTexture:()=>DE,createIndexBuffer:()=>RE,createPackedMatrixTexture:()=>LE,createUnsignedBytesMatrixTexture:()=>OE,createVertexBuffer:()=>FE,createVertexShader:()=>AE,downloadByteEncodedFloatMatrixFromOutputTexture:()=>GE,downloadFloat32MatrixFromBuffer:()=>UE,downloadMatrixFromPackedOutputTexture:()=>jE,downloadPackedMatrixFromBuffer:()=>HE,getInternalFormatForFloat16MatrixTexture:()=>s1,getInternalFormatForFloat16PackedMatrixTexture:()=>l1,getInternalFormatForFloat32MatrixTexture:()=>a1,getInternalFormatForPackedMatrixTexture:()=>o1,getInternalFormatForUnsignedBytesMatrixTexture:()=>i1,uploadDenseMatrixToTexture:()=>BE,uploadPixelDataToTexture:()=>WE});function AE(e){let t=In(),n=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return rE(e,n)}function FE(e){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return oE(e,t)}function RE(e){let t=new Uint16Array([0,1,2,2,1,3]);return lE(e,t)}function Gd(e,t,n,r,a,s){pE(t,n);let i=uE(e),o=e.TEXTURE_2D;return de(e,()=>e.bindTexture(o,i)),de(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),de(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),de(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),de(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),G().getNumber("WEBGL_VERSION")===1?de(e,()=>e.texImage2D(o,0,r,t,n,0,a,s,null)):de(e,()=>e.texStorage2D(o,1,r,t,n)),de(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[n,t]}}function a1(e){return e.internalFormatFloat}function DE(e,t,n,r){let[a,s]=Ud(t,n);return Gd(e,a,s,a1(r),r.textureFormatFloat,e.FLOAT)}function s1(e){return e.internalFormatHalfFloat}function ME(e,t,n,r){let[a,s]=Ud(t,n);return Gd(e,a,s,s1(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function i1(e){return e.downloadTextureFormat}function OE(e,t,n,r){let[a,s]=Ud(t,n);return Gd(e,a,s,i1(r),e.RGBA,e.UNSIGNED_BYTE)}function o1(e){return e.internalFormatPackedFloat}function LE(e,t,n,r){let[a,s]=Lu(t,n);return Gd(e,a,s,o1(r),e.RGBA,e.FLOAT)}function l1(e){return e.internalFormatPackedHalfFloat}function zE(e,t,n,r){let[a,s]=Lu(t,n);return Gd(e,a,s,l1(r),e.RGBA,r.textureTypeHalfFloat)}function PE(e,t,n){return de(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),rx(e,t,"clipSpacePos",n,3,20,0)&&rx(e,t,"uv",n,2,20,12)}function BE(e,t,n,r,a,s){de(e,()=>e.bindTexture(e.TEXTURE_2D,t));let i,o,l;a instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=s.internalFormatPackedFloat),i.set(a),G().getNumber("WEBGL_VERSION")===2?de(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i)):de(e,()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i)),de(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function WE(e,t,n){de(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?G().getNumber("WEBGL_VERSION")===2?de(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):de(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):G().getNumber("WEBGL_VERSION")===2?de(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):de(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),de(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function VE(e,t,n,r){let a=e.createBuffer();de(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,a));let s=4*4*t*n;return de(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ)),de(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),de(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),a}function UE(e,t,n){let r=e,a=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}function GE(e,t,n,r){let[a,s]=Ud(t,n),i=4,o=new Uint8Array(_Y(t*n,i));return de(e,()=>e.readPixels(0,0,a,s,r.downloadTextureFormat,e.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function HE(e,t,n,r,a,s,i,o){let l=e,u=new Float32Array(EY(s,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function jE(e,t,n){let r=new Float32Array(t*n*4);return de(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)),r}var Kh=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=G().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,eE(t,e)):this.gl=$r(t),e=this.gl,G().getNumber("WEBGL_VERSION")===2){let a=e;this.createVertexArray=()=>de(a,()=>a.createVertexArray()),this.bindVertexArray=s=>de(a,()=>a.bindVertexArray(s)),this.deleteVertexArray=s=>de(a,()=>a.deleteVertexArray(s)),this.getVertexArray=()=>de(a,()=>a.getParameter(a.VERTEX_ARRAY_BINDING))}else if(e!=null){let a=e.getExtension("OES_vertex_array_object");if(a==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>de(e,()=>a.createVertexArrayOES()),this.bindVertexArray=s=>de(e,()=>a.bindVertexArrayOES(s)),this.deleteVertexArray=s=>de(e,()=>a.deleteVertexArrayOES(s)),this.getVertexArray=()=>de(e,()=>e.getParameter(a.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float",r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),G().getNumber("WEBGL_VERSION")===1){let a="OES_texture_float",s="OES_texture_half_float";if(this.textureFloatExtension=cp(this.gl,a),nr(this.gl,s))this.textureHalfFloatExtension=cp(this.gl,s);else if(G().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),nr(this.gl,r))this.colorBufferHalfFloatExtension=cp(this.gl,r);else if(G().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",nr(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(nr(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=FE(this.gl),this.indexBuffer=RE(this.gl),this.framebuffer=dE(this.gl),this.textureConfig=Q0(this.gl,this.textureHalfFloatExtension)}get debug(){return G().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;de(e,()=>e.finish()),de(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),de(e,()=>e.deleteFramebuffer(this.framebuffer)),de(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),de(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),de(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),DE(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),ME(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),OE(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),WE(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),BE(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),zE(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),LE(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(ax(this.gl,this.framebuffer),this.outputTexture=null),de(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>GE(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,r,a,s){return HE(this.gl,e,t,n,r,a,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return UE(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let r=VE(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(G().getBool("WEBGL_FENCE_API_ENABLED")){let r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let s=r.clientWaitSync(a,0,0);return s===r.ALREADY_SIGNALED||s===r.CONDITION_SATISFIED},t=a}else G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>jE(this.gl,t,n))}createProgram(e){this.throwIfDisposed();let t=this.gl;this.vertexShader==null&&(this.vertexShader=AE(t));let n=sE(t);de(t,()=>t.attachShader(n,this.vertexShader)),de(t,()=>t.attachShader(n,e)),iE(t,n);let r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&Gh(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;de(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),PE(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(de(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&Gh(this.gl,this.program),de(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?cE(this.gl,e,t):mE(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),de(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),fE(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[r,a]=Lu(t,n);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Gh(this.gl,this.program),mp(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}de(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),de(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=cp(this.gl,G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,r=this.getQueryTimerExtensionWebGL2(),a=n.createQuery();return n.beginQuery(r.TIME_ELAPSED_EXT,a),a}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let t=this.gl,n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await w.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){let n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let n=this.gl,r=this.getQueryTimerExtensionWebGL2(),a=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),a&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),r=n.getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=R9(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:n}=this.itemsToPoll[t];n()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in G().platform&&(n=G().platform.setTimeoutCustom.bind(G().platform)),w.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Hh(this.gl,e,this.framebuffer),this.debug&&mp(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Hh(this.gl,this.outputTexture,this.framebuffer),this.debug&&mp(this.gl)):ax(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let r=this.gl;Hh(r,e,this.framebuffer),this.debug&&mp(r),this.outputTexture=e,de(r,()=>r.viewport(0,0,t,n)),de(r,()=>r.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),de(this.gl,()=>this.gl.scissor(e,t,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function R9(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}var{addImpl:D9,bincountImpl:qE,bincountReduceImpl:M9,bitwiseAndImpl:O9,castImpl:L9,ceilImpl:z9,concatImpl:P9,equalImpl:B9,expImpl:W9,expm1Impl:V9,floorImpl:U9,gatherNdImpl:G9,gatherV2Impl:H9,greaterImpl:j9,greaterEqualImpl:q9,lessImpl:K9,lessEqualImpl:X9,linSpaceImpl:Z9,logImpl:J9,maxImpl:Y9,maximumImpl:Q9,minimumImpl:eQ,multiplyImpl:tQ,negImpl:nQ,notEqualImpl:rQ,prodImpl:aQ,raggedGatherImpl:sQ,raggedRangeImpl:iQ,raggedTensorToTensorImpl:oQ,rangeImpl:lQ,rsqrtImpl:uQ,scatterImpl:pQ,sigmoidImpl:dQ,simpleAbsImpl:KE,sliceImpl:hQ,sparseFillEmptyRowsImpl:cQ,sparseReshapeImpl:mQ,sparseSegmentReductionImpl:XE,sqrtImpl:fQ,staticRegexReplaceImpl:gQ,stridedSliceImpl:yQ,stringNGramsImpl:bQ,stringSplitImpl:xQ,stringToHashBucketFastImpl:vQ,subImpl:wQ,tileImpl:kQ,topKImpl:IQ,transposeImpl:u1,uniqueImpl:SQ}=L0;function ZE(e,t){return["x","y","z","w","u","v"].slice(0,t).map(n=>`${e}.${n}`)}function gn(e,t){return t===1?[e]:ZE(e,t)}function NQ(e,t){if(e===1)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}var TQ=class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=cn(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let t=gn("rc",this.rank),n=ut(this.rank),r=this.getOutOfBoundsCondition(t),a=this.getSetup(t),s=this.getOutput(t);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${a}

            setOutput(vec4(${s}));
          }
        }
      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let a=`${n===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let s=2;s<this.rank;s++)a=`${e[e.length-1-s]},`+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){let t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}},JE=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=cn(this.outputShape.length);let n="";for(let r=0;r<4;r++){let a="thisRC = rc;";r%2===1&&(a+="thisRC.z += 1;"),r>1&&(a+="thisRC.y += 1;"),n+=`
        ${a}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${CQ(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?n1():t1(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${n}

        setOutput(result);
      }
    `}};function CQ(e,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?WY(["r","c","d"],"inputShape"):Ro(["r","c","d"],e)}
      return ivec3(r, c, d);
    }
  `}var _Q=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){let r=NI(t,n),a=TI(e,r,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);let s=SI(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();let o=this.freeTextures[a].pop();return this.usedTextures[a].push(o),o}let i;return r===rn.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===rn.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===rn.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===rn.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===rn.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(i),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),i}releaseTexture(e,t,n,r){if(this.freeTextures==null)return;let a=NI(n,r),s=TI(t,a,r);s in this.freeTextures||(this.freeTextures[s]=[]);let i=SI(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=G().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");o!==-1&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let l=this.usedTextures[s],u=l&&l.indexOf(e);if(u==null||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(let e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function EQ(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F||t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function SI(e,t,n,r,a){let s=$Q(t,r),i;if(a){let[l,u]=Lu(e[0],e[1]);i=l*u}else{let[l,u]=Ud(e[0],e[1]);i=l*u}let o=EQ(n,s);return i*o}function $Q(e,t){switch(e){case rn.PACKED_2X2_FLOAT32:return o1(t);case rn.PACKED_2X2_FLOAT16:return l1(t);case rn.UNPACKED_FLOAT32:return a1(t);case rn.UNPACKED_FLOAT16:return s1(t);case rn.PACKED_4X1_UNSIGNED_BYTE:return i1(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function AQ(e){return G().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?rn.PACKED_2X2_FLOAT32:rn.UNPACKED_FLOAT32:e?rn.PACKED_2X2_FLOAT16:rn.UNPACKED_FLOAT16}function NI(e,t){if(e===tr.UPLOAD)return rn.PACKED_2X2_FLOAT32;if(e===tr.RENDER||e==null)return AQ(t);if(e===tr.DOWNLOAD||e===tr.PIXELS)return rn.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function TI(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var Vr=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=cn(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},xr="if (isnan(x)) return x;",FQ="return x;",CI="return abs(x);",RQ="return (x >= 0.0) ? x : (exp(x) - 1.0);",DQ=xr+`
  return (x < 0.0) ? 0.0 : x;
`,MQ=xr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Da="return x;",OQ="return 1.0 / (1.0 + exp(-1.0 * x));",LQ="return x;",zQ=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,PQ=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,BQ=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,WQ="return 1.0 / (1.0 + exp(-1.0 * x));",Pa=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=cn(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}},VQ=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=cn(this.outputShape.length);let t=e.length,n=gn("rc",t),r=ut(t),a=NQ(t,n),s=n.slice(-2),i=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${a});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}},UQ=Qr.whereImpl,GQ=1e-7,HQ=1e-4,ub={};function jQ(e){return e in ub||(ub[e]={}),ub[e]}var qQ=G().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),KQ=600;function XQ(){return G().global.screen==null?1024:G().global.screen.height*G().global.screen.width*window.devicePixelRatio*KQ/1024/1024}var p1=class YE extends Hp{nextDataId(){return YE.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!G().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(t!=null){if(t instanceof Kh)n=t;else{let r=$r(G().getNumber("WEBGL_VERSION"),t);n=new Kh(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let r=$r(G().getNumber("WEBGL_VERSION"));n=new Kh(r),this.binaryCache=jQ(G().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new _Q(this.gpgpu),this.numMBBeforeWarning=XQ(),this.texData=new _c(this,cr())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,n,r,a,s,i){let o=this.makeTensorInfo(n,r),l=this.texData.get(o.dataId);l.isPacked=!1,l.texture={texture:t,texShape:[a,s]},l.texShape=[a,s];let u=fp(n),p=new II(u,!1,i),h=this.runWebGLProgram(p,[o],r,[[a,s]]);return h.shape=n,l.texture=null,this.disposeIntermediateTensorInfo(o),h.dataId}write(t,n,r){if((G().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||G().getBool("DEBUG"))&&this.checkNumericalProblems(t),r==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let a={id:this.nextDataId()};return this.texData.set(a,{shape:n,dtype:r,values:t,usage:tr.UPLOAD,refCount:1}),a}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){let n=this.texData.get(t);n.refCount++}decRef(t){if(this.texData.has(t)){let n=this.texData.get(t);n.refCount--}}move(t,n,r,a,s){if(G().getBool("DEBUG")&&this.checkNumericalProblems(n),a==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:r,dtype:a,values:n,usage:tr.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){let n=this.texData.get(t),{values:r,dtype:a,complexTensorInfos:s,slice:i,shape:o,isPacked:l}=n;if(i!=null){let d;l?d=new Pa(o,Da):d=new Vr(o,Da);let c=this.runWebGLProgram(d,[{dataId:t,shape:o,dtype:a}],a),m=this.readSync(c.dataId);return this.disposeIntermediateTensorInfo(c),m}if(r!=null)return this.convertAndCacheOnCPU(t);if(a==="string")return r;let u=this.activeTimers!=null,p;u&&(p=w.now());let h;if(a==="complex64"){let d=this.readSync(s.real.dataId),c=this.readSync(s.imag.dataId);h=T.mergeRealAndImagArrays(d,c)}else h=this.getValuesFromTexture(t);return u&&(this.downloadWaitMs+=w.now()-p),this.convertAndCacheOnCPU(t,h)}async read(t){if(this.pendingRead.has(t)){let m=this.pendingRead.get(t);return new Promise(f=>m.push(f))}let n=this.texData.get(t),{values:r,shape:a,slice:s,dtype:i,complexTensorInfos:o,isPacked:l}=n;if(s!=null){let m;l?m=new Pa(a,Da):m=new Vr(a,Da);let f=this.runWebGLProgram(m,[{dataId:t,shape:a,dtype:i}],i),g=this.read(f.dataId);return this.disposeIntermediateTensorInfo(f),g}if(r!=null)return this.convertAndCacheOnCPU(t);if(G().getBool("DEBUG")&&!G().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&G().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,p;if(i!=="complex64"&&G().get("WEBGL_BUFFER_SUPPORTED")){p=this.decode(t);let m=this.texData.get(p.dataId);u=this.gpgpu.createBufferFromTexture(m.texture.texture,...Mh(a))}this.pendingRead.set(t,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(i==="complex64"){let m=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),f=m[0],g=m[1];h=T.mergeRealAndImagArrays(f,g)}else if(u==null)h=this.getValuesFromTexture(t);else{let m=w.sizeFromShape(a);h=this.gpgpu.downloadFloat32MatrixFromBuffer(u,m)}if(p!=null&&this.disposeIntermediateTensorInfo(p),u!=null){let m=this.gpgpu.gl;de(m,()=>m.deleteBuffer(u))}let d=this.convertAndCacheOnCPU(t,h),c=this.pendingRead.get(t);return this.pendingRead.delete(t),c.forEach(m=>m(d)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&cr().removeDataId(t,this),this.pendingDeletes--),d}readToGPU(t,n={}){let r=this.texData.get(t),{values:a,shape:s,slice:i,dtype:o,isPacked:l,texture:u}=r;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let c;l?c=new Pa(s,Da):c=new Vr(s,Da);let m=this.runWebGLProgram(c,[{dataId:t,shape:s,dtype:o}],o),f=this.readToGPU(m,n);return this.disposeIntermediateTensorInfo(m),f}if(u==null)throw a!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let p=this.decode(t,n.customTexShape),h=cr().makeTensorFromTensorInfo(p),d=this.texData.get(p.dataId);return Object.assign({tensorRef:h},d.texture)}bufferSync(t){let n=this.readSync(t.dataId);if(t.dtype==="string")try{let r=n.map(a=>w.decodeString(a));return Oe(t.shape,t.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Oe(t.shape,t.dtype,n)}checkNumericalProblems(t){if(t!=null)for(let n=0;n<t.length;n++){let r=t[n];if(!tE(r))throw G().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(t){let{shape:n,dtype:r,isPacked:a}=this.texData.get(t),s=w.sizeFromShape(n);if(G().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let d=this.decode(t),c=this.texData.get(d.dataId),m=this.gpgpu.downloadMatrixFromPackedTexture(c.texture.texture,...Mh(n)).subarray(0,s);return this.disposeIntermediateTensorInfo(d),m}let i=G().getBool("WEBGL_PACK")&&a===!0,o=i?fp(n):n,l=i?new $9(o):new E9(o),u=this.runWebGLProgram(l,[{shape:o,dtype:r,dataId:t}],"float32"),p=this.texData.get(u.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(p.texture.texture,p.texShape[0],p.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(u),h}timerAvailable(){return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){let n=this.activeTimers,r=[],a=!1;this.programTimersStack==null?(this.programTimersStack=r,a=!0):this.activeTimers.push(r),this.activeTimers=r,t();let s=w.flatten(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),i=w.flatten(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,a&&(this.programTimersStack=null);let o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let l=await Promise.all(s);o.kernelMs=w.sum(l),o.getExtraProfileInfo=()=>l.map((u,p)=>({name:i[p],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:w.now(),endMs:null}}endTimer(t){return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=w.now(),t)}async getQueryTime(t){if(G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);let n=t;return n.endMs-n.startMs}disposeData(t,n=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(n?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!n&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);let{complexTensorInfos:r}=this.texData.get(t);return r!=null&&(this.disposeData(r.real.dataId,n),this.disposeData(r.imag.dataId,n)),this.texData.delete(t),!0}releaseGPUData(t){let{texture:n,dtype:r,texShape:a,usage:s,isPacked:i,slice:o}=this.texData.get(t),l=o&&o.origDataId||t,u=this.dataRefCount.get(l);u>1?this.dataRefCount.set(l,u-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(a,r),this.textureManager.releaseTexture(n,a,s,i)));let p=this.texData.get(t);p.texture=null,p.texShape=null,p.isPacked=!1,p.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,n=qQ){return G().getBool("WEBGL_CPU_FORWARD")&&t.every(r=>this.texData.get(r.dataId).texture==null&&w.sizeFromShape(r.shape)<n)}getGPGPUContext(){return this.gpgpu}where(t){T.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let n=t.dataSync();return UQ(t.shape,n)}packedUnaryOp(t,n,r){let a=new Pa(t.shape,n),s=this.compileAndRun(a,[t],r);return cr().makeTensorFromTensorInfo(s)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){let a=KE(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,a)}if(G().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,CI,t.dtype);let n=new Vr(t.shape,CI),r=this.compileAndRun(n,[t]);return cr().makeTensorFromTensorInfo(r)}makeTensorInfo(t,n,r){let a;if(n==="string"&&r!=null&&r.length>0&&w.isString(r[0])){let s=r.map(i=>w.encodeString(i));a=this.write(s,t,n)}else a=this.write(r,t,n);return this.texData.get(a).usage=null,{dataId:a,shape:t,dtype:n}}makeOutput(t,n,r){return cr().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,r),this)}unpackTensor(t){let n=new VQ(t.shape);return this.runWebGLProgram(n,[t],t.dtype)}packTensor(t){let n=new TQ(t.shape);return this.runWebGLProgram(n,[t],t.dtype,null,!0)}packedReshape(t,n){let r=[ti(t.shape),...ni(t.shape)],a={dtype:t.dtype,shape:r,dataId:t.dataId},s=[ti(n),...ni(n)],i=new JE(s,r),o=!0,l=[r],u=this.runWebGLProgram(i,[a],t.dtype,l,o);return{dataId:u.dataId,shape:n,dtype:u.dtype}}decode(t,n){let r=this.texData.get(t),{isPacked:a,shape:s,dtype:i}=r;if(n!=null){let d=w.sizeFromShape(s),c=n[0]*n[1]*4;w.assert(d<=c,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let o=fp(s),l;a?l=new _9(o):l=new C9(o);let u=!0,p=[n!=null?n:Mh(o)],h=this.runWebGLProgram(l,[{shape:o,dtype:i,dataId:t}],i,p,u,n);return{dtype:i,shape:s,dataId:h.dataId}}runWebGLProgram(t,n,r,a,s=!1,i){let o=this.makeTensorInfo(t.outputShape,r),l=this.texData.get(o.dataId);if(t.packedOutput&&(l.isPacked=!0),t.outPackingScheme===Op.DENSE){let y=i!=null?i:Mh(t.outputShape);l.texShape=y.map(b=>b*2)}if(t.outTexUsage!=null&&(l.usage=t.outTexUsage),w.sizeFromShape(o.shape)===0)return l.values=w.getTypedArrayFromDType(o.dtype,0),o;let u=[],p=n.map(y=>{if(y.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(y.dataId);if(b.texture==null){if(!t.packedInputs&&w.sizeFromShape(y.shape)<=G().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:y.shape,texData:null,isUniform:!0,uniformValues:b.values};t.packedInputs&&(b.isPacked=!0,b.shape=y.shape)}if(this.uploadToGPU(y.dataId),!!b.isPacked!=!!t.packedInputs)y=b.isPacked?this.unpackTensor(y):this.packTensor(y),u.push(y),b=this.texData.get(y.dataId);else if(b.isPacked&&!Lp(b.shape,y.shape)){let x=y,v=y.shape;y.shape=b.shape,y=this.packedReshape(y,v),u.push(y),b=this.texData.get(y.dataId),x.shape=v}return{shape:y.shape,texData:b,isUniform:!1}});this.uploadToGPU(o.dataId);let h={shape:o.shape,texData:l,isUniform:!1},d=T9(t,p,h),c=this.getAndSaveBinary(d,()=>S9(this.gpgpu,t,p,h)),m=this.activeTimers!=null,f;m&&(f=this.startTimer()),G().get("ENGINE_COMPILE_ONLY")||N9(this.gpgpu,c,p,h,a),u.forEach(y=>this.disposeIntermediateTensorInfo(y)),m&&(f=this.endTimer(f),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(f)}));let g=G().getNumber("WEBGL_FLUSH_THRESHOLD");if(g>0){let y=w.now();y-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!G().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&s===!1){let y=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),y}return o}compileAndRun(t,n,r,a,s=!1){return r=r||n[0].dtype,this.runWebGLProgram(t,n,r,a,s)}getAndSaveBinary(t,n){return t in this.binaryCache||(this.binaryCache[t]=n()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(G().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=B(()=>{if(!G().get("WEBGL_RENDER_FLOAT32_ENABLED")){let t=G().getBool("DEBUG");G().set("DEBUG",!1);let n=this.abs(ve(1e-8)).dataSync()[0];if(G().set("DEBUG",t),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?GQ:HQ}uploadToGPU(t){let n=this.texData.get(t),{shape:r,dtype:a,values:s,texture:i,usage:o,isPacked:l}=n;if(i!=null)return;let u=this.activeTimers!=null,p;u&&(p=w.now());let h=n.texShape;if(h==null&&(h=bE(r,l),n.texShape=h),s!=null){let d=fp(r),c,m=h[1],f=h[0],g=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(l||!g)&&([m,f]=Lu(h[0],h[1])),l?c=new F9(d,g):c=new II(d,g);let y=g?[f,m]:h,b=this.makeTensorInfo(y,a),x=this.texData.get(b.dataId);g?x.usage=tr.PIXELS:x.usage=tr.UPLOAD,x.texShape=y,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),m,f,s);let v=[[f,m]],I=this.runWebGLProgram(c,[b],a,v,!0),N=this.texData.get(I.dataId);n.texShape=N.texShape,n.isPacked=N.isPacked,n.usage=N.usage,G().get("ENGINE_COMPILE_ONLY")?this.disposeData(I.dataId):(n.texture=N.texture,n.values=null,this.texData.delete(I.dataId)),this.disposeIntermediateTensorInfo(b),u&&(this.uploadWaitMs+=w.now()-p)}else{let d=this.acquireTexture(h,o,a,l);n.texture=d}}convertAndCacheOnCPU(t,n){let r=this.texData.get(t),{dtype:a}=r;return n!=null&&(r.values=ZQ(n,a)),r.values}acquireTexture(t,n,r,a){if(this.numBytesInGPU+=this.computeBytes(t,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,n,a)}computeBytes(t,n){return t[0]*t[1]*w.bytesPerElement(n)}checkCompileCompletion(){for(let[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){let t=[];if(this.gpgpu.parallelCompilationExtension){for(let[,n]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(n));return Promise.all(t)}else{for(let[,n]of Object.entries(this.binaryCache)){let r=new Promise(a=>{try{this.checkCompletion_(n),a(!0)}catch(s){throw s}});t.push(r)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await Qv(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(e1(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);let{variablesLocations:n,customUniformLocations:r,infLoc:a,nanLoc:s,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:l}=EE(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=n,t.customUniformLocations=r,t.infLoc=a,t.nanLoc=s,t.outShapeLocation=i,t.outShapeStridesLocation=o,t.outTexShapeLocation=l}}createTensorFromGPUData(t,n,r){t.channels=t.channels||"RGBA";let{texture:a,height:s,width:i,channels:o}=t,l=cr().backend;if(!l.gpgpu.gl.isTexture(a))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let u=l.writeTexture(a,n,r,s,i,o);return cr().makeTensorFromDataId(u,n,r,l)}};p1.nextDataId=0;function ZQ(e,t){if(t==="float32"||t==="complex64")return e;if(t==="int32"||t==="bool"){let n=t==="int32"?new Int32Array(e.length):new Uint8Array(e.length);for(let r=0;r<n.length;++r)n[r]=Math.round(e[r]);return n}else throw new Error(`Unknown dtype ${t}`)}var JQ="4.22.0";function QE(){G().set("WEBGL_FORCE_F16_TEXTURES",!0)}yd.isBrowser()&&jc("webgl",()=>new p1,2);var YQ={forceHalfFloat:QE},d1=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,ri=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=T.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=cn(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}},Mo=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`,Uu=class{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=T.assertAndGetBroadcastShape(t,n);let a=this.outputShape.length;this.enableShapeUniforms=cn(a);let s="";if(r)if(a===0||w.sizeFromShape(this.outputShape)===1)s=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(s=`
          ${ut(a)} coords = getOutputCoords();
        `,a===1)this.enableShapeUniforms?s+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:s+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let i=gn("coords",a);this.enableShapeUniforms?s+=`
            bool nextRowOutOfBounds =
              (${i[a-2]} + 1) >= outShape[${a} - 2];
            bool nextColOutOfBounds =
              (${i[a-1]} + 1) >= outShape[${a} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:s+=`
            bool nextRowOutOfBounds =
              (${i[a-2]} + 1) >= ${this.outputShape[a-2]};
            bool nextColOutOfBounds =
              (${i[a-1]} + 1) >= ${this.outputShape[a-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${s}

        setOutput(result);
      }
    `}};function qn(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var QQ={kernelName:Oi,backendName:"webgl",kernelFunc:qn};function gs(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(s.dataId),o=qn({inputs:{x:r},backend:n}),l=qn({inputs:{x:a},backend:n});return i.complexTensorInfos={real:o,imag:l},s}var eee={kernelName:Ac,backendName:"webgl",kernelFunc:gs},e$="return (a < 0.) ? b * a : a;",t$=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function tee(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r,i=n.makeTensorInfo([],"float32",w.createScalarValue(s,"float32")),o=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Uu(t$,a.shape,i.shape):new ri(e$,a.shape,i.shape),l=n.runWebGLProgram(o,[a,i],"float32");return n.disposeIntermediateTensorInfo(i),l}var nee={kernelName:Bi,backendName:"webgl",kernelFunc:tee},n$="return (a < 0.) ? b * a : a;",r$=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function ree(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Uu(r$,r.shape,a.shape):new ri(n$,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],"float32")}var aee={kernelName:no,backendName:"webgl",kernelFunc:ree},Gu="if (isnan(x)) return x;";function qe({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:a,backend:s})=>{let{x:i}=a,o=s,l=r||i.dtype;if(o.shouldExecuteOnCPU([i])&&n!=null){let h=o.texData.get(i.dataId),d=n(h.values,l);return o.makeTensorInfo(i.shape,l,d)}let u=G().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,p;return u?p=new Pa(i.shape,t):p=new Vr(i.shape,e),o.runWebGLProgram(p,[i],l)}}function on({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:a,dtype:s}){return({inputs:i,backend:o})=>{let{a:l,b:u}=i,p=o;if(r&&l.dtype==="complex64"){let m=p.texData.get(l.dataId),f=p.texData.get(u.dataId),[g,y]=[[m.complexTensorInfos.real,f.complexTensorInfos.real],[m.complexTensorInfos.imag,f.complexTensorInfos.imag]].map(x=>{let[v,I]=x,N={dataId:v.dataId,dtype:v.dtype,shape:l.shape},C={dataId:I.dataId,dtype:I.dtype,shape:u.shape},E=new ri(e,l.shape,u.shape);return p.runWebGLProgram(E,[N,C],sr(v.dtype,I.dtype))}),b=gs({inputs:{real:g,imag:y},backend:p});return p.disposeIntermediateTensorInfo(g),p.disposeIntermediateTensorInfo(y),b}let h=s||sr(l.dtype,u.dtype);if((l.dtype==="string"||u.dtype==="string"||p.shouldExecuteOnCPU([l,u]))&&a!=null){let m=p.texData.get(l.dataId).values,f=p.texData.get(u.dataId).values,g=l.dtype==="string"?T.fromUint8ToStringArray(m):m,y=l.dtype==="string"?T.fromUint8ToStringArray(f):f,[b,x]=a(l.shape,u.shape,g,y,h),v=p.makeTensorInfo(x,h),I=p.texData.get(v.dataId);return I.values=b,v}let d=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,c;return d?c=new Uu(t,l.shape,u.shape,n):c=new ri(e,l.shape,u.shape),p.runWebGLProgram(c,[l,u],h)}}function zp(e,t=!1){if(e==="linear")return t?LQ:FQ;if(e==="relu")return t?PQ:DQ;if(e==="elu")return t?zQ:RQ;if(e==="relu6")return t?BQ:MQ;if(e==="prelu")return t?r$:n$;if(e==="leakyrelu")return t?t$:e$;if(e==="sigmoid")return t?WQ:OQ;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var a$=class{constructor(e,t,n,r=!1,a=!1,s=!1,i=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=cn(this.outputShape.length);let u=r?e[1]:e[2],p=Math.ceil(u/2),h=r?"i * 2, rc.y":"rc.y, i * 2",d=a?"rc.z, i * 2":"i * 2, rc.z",c=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],f="",g="";i&&(o?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:l?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:f=`vec4 activation(vec4 x) {
          ${i}
        }`,g="result = activation(result);");let y=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let b="rc.x",x="rc.x";e[0]<t[0]?b=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(x=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${f}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${b};
        int batchB = ${x};
        for (int i = 0; i < ${p}; i++) {
          vec4 a = getMatrixA(batchA, ${h});
          vec4 b = getMatrixB(batchB, ${d});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${c[0]} * ${m[0]});
          result += (${c[1]} * ${m[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${y}

        ${g}

        setOutput(result);
      }
    `}},_I={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},EI=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=T.assertAndGetBroadcastShape(t,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}},$I="return a * b;";function h1(e){let{inputs:t,backend:n}=e,{a:r,b:a}=t,s=T.upcastType(r.dtype,a.dtype);if(r.dtype==="complex64"){let o=n.texData.get(r.dataId),l=n.texData.get(a.dataId),u=new EI(_I.REAL,r.shape,a.shape),p=new EI(_I.IMAG,r.shape,a.shape),h=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:r.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:a.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:a.shape}],d=n.runWebGLProgram(u,h,"float32"),c=n.runWebGLProgram(p,h,"float32"),m=gs({inputs:{real:d,imag:c},backend:n});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),m}if(n.shouldExecuteOnCPU([r,a])){let o=n.texData.get(r.dataId),l=n.texData.get(a.dataId),[u,p]=tQ(r.shape,a.shape,o.values,l.values,s),h=n.makeTensorInfo(p,s),d=n.texData.get(h.dataId);return d.values=u,h}let i;return G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new Uu($I,r.shape,a.shape):i=new ri($I,r.shape,a.shape),n.runWebGLProgram(i,[r,a],s)}var see={kernelName:Yi,backendName:"webgl",kernelFunc:h1};function iee(e,t,n){let r=[ti(e.shape),...ni(e.shape)],a={dtype:e.dtype,shape:r,dataId:e.dataId},s=[ti(t),...ni(t)],i=new JE(s,r),o=!0,l=[r],u=n.runWebGLProgram(i,[a],e.dtype,l,o);return{dataId:u.dataId,shape:t,dtype:u.dtype}}function pe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=n,o=w.sizeFromShape(a.shape),l=w.inferFromImplicitShape(s,o),u=w.sizeFromShape(l);w.assert(o===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${a.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);let p=i.texData.get(a.dataId);return p.isPacked&&!Lp(a.shape,l)&&!(p.texture!==null&&Lp(p.shape,l))?iee(a,l,i):(i.incRef(a.dataId),{dataId:a.dataId,shape:l,dtype:a.dtype})}var oee={kernelName:lu,backendName:"webgl",kernelFunc:pe},AI=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let i=Math.floor(n/4)*4,o=n%4,l="sumValue += dot(values, ones);";if(t!=null){let p=1/t;l=`sumValue += dot(values * ${w.isInt(p)?p.toPrecision(2):p}, ones);`}let u="";a%n>0&&(u=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${i};
        if (${o===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${o===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${o===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}},lee=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let i="0.0",o="";t==="prod"?i="1.0":t==="min"?(i="1.0 / 1e-20",o="min"):t==="max"&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?l="sumValue":t==="prod"?l="prodValue":t==="all"?l="allValue":t==="any"&&(l="anyValue");let u=Math.floor(n/4)*4,p=n%4,h=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${o}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${o}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,d="vec4";t==="all"?(i="1.0",h=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,d="bvec4"):t==="any"&&(i="0.0",h=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,d="bvec4");let c="";a%n>0&&(c=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${h}
        }

        int inIdx = inOffset + ${u};
        if (${p===1}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${p===2}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${p===3}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${h}
        }
        setOutput(${l});
      }
    `}};function uee(e){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let n=t.length?t[t.length-1].outSize:e[1],r=T.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}function Oo(e,t,n,r){let a=uee(e.shape),s=e;for(let i=0;i<a.length;i++){let{inSize:o,windowSize:l,outSize:u}=a[i],p,h;n==="mean"?p=i===0?new AI({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},o):new AI({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u}):p=new lee({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},n),h=s,s=r.runWebGLProgram(p,[s],t),h.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(h)}return s}var pee=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[t[s]];this.outputShape=n,this.rank=n.length;let r=ut(this.rank),a=dee(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${a}));
    }
    `}};function dee(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let a=0;a<e.length;a++)r[e[a]]=n[a];return r.join()}var hee=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let u=0;u<n.length;u++)n[u]=e[t[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let r=ut(this.rank),a=ZE("rc",this.rank),s=new Array(this.rank);for(let u=0;u<t.length;u++)s[t[u]]=a[u];let i=`vec2(${s.slice(-2).join()})`,o=`++${a[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${i})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${o}) {
        result[1] = ${l};
      }
      --${a[this.rank-1]};
      if(++${a[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${l};
        if(${o}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}};function Jm(e,t,n){let r=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new hee(e.shape,t):new pee(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function cee(e,t,n,r){let a=t,s=e.shape.length,i=w.parseAxisParam(a,e.shape),o=i,l=T.getAxesPermutation(o,s),u=l!=null,p=e;u&&(p=Jm(e,l,r),o=T.getInnerMostAxes(o.length,s)),T.assertAxesAreInnerMostDims("sum",o,s);let[h,d]=T.computeOutAndReduceShapes(p.shape,o),c=h;n&&(c=T.expandShapeToKeepDim(h,i));let m=w.sizeFromShape(d),f=w.sizeFromShape(e.shape)/m,g=pe({inputs:{x:p},attrs:{shape:[f,m]},backend:r}),y=Hc(e.dtype),b=Oo(g,y,"sum",r),x=pe({inputs:{x:b},attrs:{shape:c},backend:r});return r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(b),u&&r.disposeIntermediateTensorInfo(p),x}function Ym(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;return cee(a,s,i,n)}var mee={kernelName:vo,backendName:"webgl",kernelFunc:Ym};function xn(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{perm:s}=r,i=n,o=a.shape.length,l=new Array(o);for(let p=0;p<l.length;p++)l[p]=a.shape[s[p]];let u;if(i.shouldExecuteOnCPU([a])){let p=i.texData.get(a.dataId).values,h=u1(p,a.shape,a.dtype,s,l);u=i.makeTensorInfo(l,a.dtype);let d=i.texData.get(u.dataId);d.values=h}else u=Jm(a,s,i);return u}var fee={kernelName:ua,backendName:"webgl",kernelFunc:xn},s$=1e3;function kc({a:e,b:t,transposeA:n,transposeB:r,backend:a,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){let u=e.shape.length,p=t.shape.length,h=n?e.shape[u-2]:e.shape[u-1],d=r?t.shape[p-1]:t.shape[p-2],c=n?e.shape[u-1]:e.shape[u-2],m=r?t.shape[p-2]:t.shape[p-1],f=e.shape.slice(0,-2),g=t.shape.slice(0,-2),y=w.sizeFromShape(f),b=w.sizeFromShape(g),x=Tu.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([c,m]);w.assert(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`);let v=n?[y,h,c]:[y,c,h],I=r?[b,m,d]:[b,d,m],N=pe({inputs:{x:e},backend:a,attrs:{shape:v}}),C=pe({inputs:{x:t},backend:a,attrs:{shape:I}}),E=[N,C],A=Math.max(y,b),R=n?N.shape[1]:N.shape[2],F=s!=null,S=i!=null,M=l==="leakyrelu",W=l!=null?zp(l,!0):null,U=F||S||M||W!=null,H;if((c===1||m===1)&&R>s$&&U===!1){let K=N,J=C;n&&(K=xn({inputs:{x:N},backend:a,attrs:{perm:[0,2,1]}}),E.push(K)),r&&(J=xn({inputs:{x:C},backend:a,attrs:{perm:[0,2,1]}}),E.push(J));let Y=m!==1,ee=m===1,re=K;Y&&(re=pe({inputs:{x:K},backend:a,attrs:{shape:[A,R,1]}}),E.push(re));let te=m===1?2:1,ae=J;ee&&(ae=pe({inputs:{x:J},backend:a,attrs:{shape:[A,1,R]}}),E.push(ae));let se=h1({inputs:{a:re,b:ae},backend:a});H=Ym({inputs:{x:se},backend:a,attrs:{axis:te,keepDims:!0}}),E.push(se)}else{let K=sr(e.dtype,t.dtype),J=new a$(v,I,[A,c,m],n,r,F,W,S,M),Y=[N,C];if(s!=null&&Y.push(s),S&&Y.push(i),M){let ee=a.makeTensorInfo([],"float32",w.createScalarValue(o,"float32"));Y.push(ee),E.push(ee)}H=a.runWebGLProgram(J,Y,K)}let q=pe({inputs:{x:H},backend:a,attrs:{shape:x}});E.push(H);for(let K of E)a.disposeIntermediateTensorInfo(K);return q}function gee(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:p,leakyreluAlpha:h}=r;return kc({a,b:s,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:h,activation:p})}var yee={kernelName:Bs,backendName:"webgl",kernelFunc:gee},FI="return abs(x);";function bee(e){let{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){let s=n.texData.get(r.dataId),i=KE(s.values);return n.makeTensorInfo(r.shape,r.dtype,i)}let a;return G().getBool("WEBGL_PACK_UNARY_OPERATIONS")?a=new Pa(r.shape,FI):a=new Vr(r.shape,FI),n.runWebGLProgram(a,[r],r.dtype)}var xee={kernelName:Sl,backendName:"webgl",kernelFunc:bee},vee=xr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,wee=qe({opSnippet:vee}),kee={kernelName:oi,backendName:"webgl",kernelFunc:wee},Iee=xr+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,See=qe({opSnippet:Iee}),Nee={kernelName:li,backendName:"webgl",kernelFunc:See},RI="return a + b;",Tee=on({opSnippet:RI,packedOpSnippet:RI,supportsComplex:!0,cpuKernelImpl:D9}),Cee={kernelName:is,backendName:"webgl",kernelFunc:Tee},_ee=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((a,s)=>`T${s}`);let n=[];this.variableNames.forEach(a=>{n.push(`float v${a} = get${a}AtOutCoords();`)});let r=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}},Eee=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((a,s)=>`T${s}`);let n=[];this.variableNames.forEach(a=>{n.push(`vec4 v${a} = get${a}AtOutCoords();`)});let r=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}};function Xh(e){let{inputs:t,backend:n}=e,r=t;if(r.length===1)return qn({inputs:{x:r[0]},backend:n});if(r.length>G().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let o=Math.floor(r.length/2),l=Xh({inputs:r.slice(0,o),backend:n}),u=Xh({inputs:r.slice(o),backend:n});return Xh({inputs:[l,u],backend:n})}let a=r.map(o=>o.dtype).reduce((o,l)=>sr(o,l)),s=r.map(o=>o.shape),i=G().getBool("WEBGL_PACK")?new Eee(r[0].shape,s):new _ee(r[0].shape,s);return n.runWebGLProgram(i,r,a)}var $ee={kernelName:ui,backendName:"webgl",kernelFunc:Xh};function Aee(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=w.parseAxisParam(s,a.shape),u=l,p=T.getAxesPermutation(u,o),h=a;p!=null&&(h=xn({inputs:{x:a},backend:n,attrs:{perm:p}}),u=T.getInnerMostAxes(u.length,o)),T.assertAxesAreInnerMostDims("all",u,o);let[d,c]=T.computeOutAndReduceShapes(h.shape,u),m=w.sizeFromShape(c),f=pe({inputs:{x:h},backend:n,attrs:{shape:[-1,m]}}),g=Oo(f,f.dtype,"all",n),y;if(i){let b=T.expandShapeToKeepDim(d,l);y=pe({inputs:{x:g},backend:n,attrs:{shape:b}})}else y=pe({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),p!=null&&n.disposeIntermediateTensorInfo(h),y}var Fee={kernelName:Nl,backendName:"webgl",kernelFunc:Aee};function Ree(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=w.parseAxisParam(s,a.shape),u=l,p=T.getAxesPermutation(u,o),h=a;p!=null&&(h=xn({inputs:{x:a},backend:n,attrs:{perm:p}}),u=T.getInnerMostAxes(u.length,o)),T.assertAxesAreInnerMostDims("any",u,o);let[d,c]=T.computeOutAndReduceShapes(h.shape,u),m=w.sizeFromShape(c),f=pe({inputs:{x:h},backend:n,attrs:{shape:[-1,m]}}),g=Oo(f,f.dtype,"any",n),y;if(i){let b=T.expandShapeToKeepDim(d,l);y=pe({inputs:{x:g},backend:n,attrs:{shape:b}})}else y=pe({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),p!=null&&n.disposeIntermediateTensorInfo(h),y}var Dee={kernelName:Tl,backendName:"webgl",kernelFunc:Ree},Mee=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:r,batchSize:a,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,s];let i=t==="max"?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${o};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}},Oee=class{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,w.assert(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let a=e[e.length-1],s=Math.ceil(a/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");let i=this.outputShape,o=i.length,l=ut(o),u=gn("coords",o),p,h;if(s===1){h=o+1;let C=ut(h);p=`
        ${C} sourceLocR = ${C}(${u.join()}, 0);
        ++${u[o-1]};
        ${C} sourceLocG = ${C}(${u.join()}, 0);
        ++${u[o-2]};
        ${C} sourceLocA = ${C}(${u.join()}, 0);
        --${u[o-1]};
        ${C} sourceLocB = ${C}(${u.join()}, 0);
        --${u[o-2]};`}else h=o,p=`
        ${l} sourceLocR = coords;
        ++${u[o-1]};
        ${l} sourceLocG = coords;
        ++${u[o-2]};
        ${l} sourceLocA = coords;
        --${u[o-1]};
        ${l} sourceLocB = coords;
        --${u[o-2]};`;let d=["x","y","z","w","u","v"].slice(0,h),c="."+d[h-1],m=d.map(C=>"int "+C),f=gn("sourceLocR",h-1).concat("inIdx.r"),g=gn("sourceLocG",h-1).concat("inIdx.g"),y=gn("sourceLocB",h-1).concat("inIdx.b"),b=gn("sourceLocA",h-1).concat("inIdx.a"),x=n==="max"?"greaterThan":"lessThan",v=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${f.join()}),
                             getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()})));`,I=`vec4(
            getAChannel(${f.join()}),
            hasNextCol ? getAChannel(${g.join()}) : 0.,
            hasNextRow ? getAChannel(${y.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,N=r?"":`
      float getBestIndicesAChannel(${m.join()}) {
        return getChannel(getBestIndicesA(${d.join()}),
                                          vec2(${d.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${m.join()}) {
        return getChannel(getA(${d.join()}),
                               vec2(${d.slice(-2).join()}));
      }
      ${N}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${u[o-1]} < ${i[o-1]-1};
        bool hasNextRow = ${u[o-2]} < ${i[o-2]-1};
        ${p}
        ivec4 srcIdx = ivec4(sourceLocR${c}, sourceLocG${c},
          sourceLocB${c}, sourceLocA${c}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${I};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${v}
          vec4 candidate = ${I};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function i$(e,t,n,r=null){let a=t.shape[0],s=t.shape[1];r!=null&&(a=r.shape[0],s=r.shape[1]);let i=T.computeOptimalWindowSize(s),o={windowSize:i,inSize:s,batchSize:a,outSize:Math.ceil(s/i)},l=new Mee(o,n,r==null),u=[t];r!=null&&u.push(r);let p=e.runWebGLProgram(l,u,"int32");if(p.shape[1]===1)return p;let h=i$(e,t,n,p);return e.disposeIntermediateTensorInfo(p),h}function o$(e,t,n,r=null){let a=r!=null?r.shape:t.shape,s=a[a.length-1],i=T.computeOptimalWindowSize(s),o=new Oee(a,i,n,r==null),l=r==null?[t]:[t,r],u=e.runWebGLProgram(o,l,"int32");if(u.shape.length===t.shape.length){let p=o$(e,t,n,u);return e.disposeIntermediateTensorInfo(u),p}return u}function l$(e,t,n,r){let a=[n];if(T.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,t.shape.length),!G().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let s=[],i=e.texData.get(t.dataId),o=i!==null&&i.isPacked,l=t;o&&(l=e.unpackTensor(t),s.push(l));let[u,p]=T.computeOutAndReduceShapes(l.shape,a),h=w.sizeFromShape(p),d=pe({inputs:{x:l},backend:e,attrs:{shape:[-1,h]}});s.push(d);let c=i$(e,d,r);s.push(c);let m=pe({inputs:{x:c},backend:e,attrs:{shape:u}});return s.forEach(f=>e.disposeIntermediateTensorInfo(f)),m}return o$(e,t,r)}function Lee(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r,i=w.parseAxisParam(s,a.shape),o=T.getAxesPermutation(i,a.shape.length),l=a,u=[];o!=null&&(l=xn({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=T.getInnerMostAxes(i.length,l.shape.length)),T.assertAxesAreInnerMostDims("argMax",[i[0]],l.shape.length);let p=l$(n,l,i[0],"max");return u.forEach(h=>n.disposeIntermediateTensorInfo(h)),p}var zee={kernelName:Cl,backendName:"webgl",kernelFunc:Lee};function Pee(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r,i=w.parseAxisParam(s,a.shape),o=T.getAxesPermutation(i,a.shape.length),l=a,u=[];o!=null&&(l=xn({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=T.getInnerMostAxes(i.length,l.shape.length)),T.assertAxesAreInnerMostDims("argMin",[i[0]],l.shape.length);let p=l$(n,l,i[0],"min");return u.forEach(h=>n.disposeIntermediateTensorInfo(h)),p}var Bee={kernelName:_l,backendName:"webgl",kernelFunc:Pee},Wee=xr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,Vee=qe({opSnippet:Wee}),Uee={kernelName:pi,backendName:"webgl",kernelFunc:Vee},Gee=xr+"return log(x + sqrt(x * x + 1.0));",Hee=qe({opSnippet:Gee}),jee={kernelName:di,backendName:"webgl",kernelFunc:Hee},qee=xr+`
  return atan(x);
`,Kee=qe({opSnippet:qee}),Xee={kernelName:hi,backendName:"webgl",kernelFunc:Kee},Zee=d1+`
  return atan(a, b);
`,Jee=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Mo+`
  return result;
`,Yee=on({opSnippet:Zee,packedOpSnippet:Jee}),Qee={kernelName:mi,backendName:"webgl",kernelFunc:Yee},ete=xr+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,tte=qe({opSnippet:ete}),nte={kernelName:ci,backendName:"webgl",kernelFunc:tte},Pp=class{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,p=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.top,c=e.padInfo.left;this.outputShape=e.outShape;let m=t==="avg",f=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,y="0.0";if(m||(y="-1.0 / 1e-20"),n){let C=">=";this.userCode=`
        const ivec2 strides = ivec2(${i}, ${o});
        const ivec2 pads = ivec2(${d}, ${c});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${C} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?a?f:g:`wR * ${h} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let b="max",x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(x="avgValue / max(count, 1.0)");let v=Math.floor(s/4)*4,I=s%4,N=`
      if (${m}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${b}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${d}, ${c});
      const float initializationValue = ${y};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${y});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${v}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${N}
          }

          int xC = xCCorner + ${v};
          if (${I===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${N}
          } else if (${I===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${N}
          } else if (${I===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${N}
          }
        }
        setOutput(${x});
      }
    `}},c1=class{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,p=e.dilationHeight,h=e.dilationWidth,d=e.effectiveFilterDepth,c=e.effectiveFilterHeight,m=e.effectiveFilterWidth,f=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;let b=t==="avg",x="0.0";if(b||(x="-1.0 / 1e-20"),n){let A=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${o}, ${l});
        const ivec3 pads = ivec3(${f}, ${g}, ${y});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${d};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${c};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${m};
                  wC += ${h}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${A} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${c} * ${m} +
                      wR * ${m} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let v="max",I=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(I="avgValue / max(count, 1.0)");let N=Math.floor(s/4)*4,C=s%4,E=`
      if (${b}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${v}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${o}, ${l});
      const ivec3 pads = ivec3(${f}, ${g}, ${y});
      const float initializationValue = ${x};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${x});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${c};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${N}; wC += 4) {
              int xC = xCCorner + wC * ${h};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                getValue(batch, xD, xR, xC + 3 * ${h}, ch)
              );

              ${E}
            }

            int xC = xCCorner + ${N};
            if (${C===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${E}
            } else if (${C===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                initializationValue,
                initializationValue
              );

              ${E}
            } else if (${C===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                initializationValue
              );

              ${E}
            }
          }
        }
        setOutput(${I});
      }
    `}};function rte(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;zu(a,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,u=1;w.assert(T.eitherStridesOrDilationsAreOne(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let p=T.computePool2DInfo(a.shape,s,i,u,o,l);if(p.filterWidth===1&&p.filterHeight===1&&w.arraysEqual(p.inShape,p.outShape))return qn({inputs:{x:a},backend:n});let h=new Pp(p,"avg",!1);return n.runWebGLProgram(h,[a],"float32")}var ate={kernelName:fi,backendName:"webgl",kernelFunc:rte};function ste(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,p=[1,1,1],h=T.computePool3DInfo(a.shape,s,i,p,o,l,u),d=new c1(h,"avg",!1);return n.runWebGLProgram(d,[a],"float32")}var ite={kernelName:El,backendName:"webgl",kernelFunc:ste},ote=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.top,p=l-1-e.padInfo.left,h=1/(t*n);this.userCode=`
      const ivec2 pads = ivec2(${u}, ${p});
      const float avgMultiplier = float(${h});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
            wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},lte=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,p=e.effectiveFilterDepth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,c=p-1-e.padInfo.front,m=h-1-e.padInfo.top,f=d-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`
      const ivec3 pads = ivec3(${c}, ${m}, ${f});
      const float avgMultiplier = float(${g});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${a}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${h};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function ute(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:p}=r,h=[1,1,1],d=T.computePool3DInfo(i.shape,o,l,h,u,p),c=new lte(d);return n.runWebGLProgram(c,[a],i.dtype)}var pte={kernelName:Kp,backendName:"webgl",kernelFunc:ute};function dte(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;zu([a,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=r,p=T.computePool2DInfo(i.shape,o,l,1,u),h=new ote(p);return n.runWebGLProgram(h,[a],i.dtype)}var hte={kernelName:qp,backendName:"webgl",kernelFunc:dte};function cte(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s}=t,{transposeA:i,transposeB:o}=r;return kc({a,b:s,transposeA:i,transposeB:o,backend:n})}var mte={kernelName:gi,backendName:"webgl",kernelFunc:cte},fte=class{constructor(e,t,n,r,a,s){this.outputShape=[],this.variableNames=["x","mean","variance"],T.assertAndGetBroadcastShape(e,t),T.assertAndGetBroadcastShape(e,n);let i="0.0";r!=null&&(T.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";a!=null&&(T.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${o};
        float inv = scale * inversesqrt(variance + float(${s}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}},gte=class{constructor(e,t,n,r,a,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],T.assertAndGetBroadcastShape(e,t),T.assertAndGetBroadcastShape(e,n);let i="vec4(0.0)";r!=null&&(T.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";a!=null&&(T.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${o};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${s}));

        setOutput((x - mean) * inv + offset);
      }
    `}},yte=({inputs:e,backend:t,attrs:n})=>{let{x:r,mean:a,variance:s,offset:i,scale:o}=e;w.assert(a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),w.assert(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),w.assert(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);let u=[r,a,s],p=null;i!=null&&(p=i.shape,u.push(i));let h=null;o!=null&&(h=o.shape,u.push(o));let d=G().getBool("WEBGL_PACK_NORMALIZATION")?new gte(r.shape,a.shape,s.shape,p,h,l):new fte(r.shape,a.shape,s.shape,p,h,l);return t.runWebGLProgram(d,u,u[0].dtype)},bte={kernelName:Di,backendName:"webgl",kernelFunc:yte},xte=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=ut(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=vte(this.rank),r,a=e.map((s,i)=>`sourceLoc.${ox[i]} = start[${i}] + coords.${ox[i]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${a.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${n}));
      }
    `}},ox=["x","y","z","w","u","v"];function vte(e){if(e===1)return"sourceLoc";if(e<=6)return ox.slice(0,e).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}var wte=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=ut(this.rank),n=gn("coords",this.rank),r=gn("sourceLoc",this.rank),a=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,s=`getChannel(getSource(${r.join()}), ${a})`,i=`
      result.x = ${s};
      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${s};
        --${r[this.rank-1]};
      }
    `,o=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${s};
        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${s};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((u,p)=>`start[${p}]`).join()});`:e.map((u,p)=>`${r[p]} = ${n[p]} + start[${p}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${i}
        ${o}
        setOutput(result);
      }
    `}};function kte(e,t,n,r){let a=r.texData.get(e.dataId),s=r.makeTensorInfo(n,e.dtype),i=r.texData.get(s.dataId);Object.assign(i,a),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=Bt.computeFlatOffset(t,w.computeStrides(e.shape));a.slice&&(o+=a.slice.flatOffset),i.slice={flatOffset:o,origDataId:a.slice&&a.slice.origDataId||e.dataId};let l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),s}function Hu(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r,[o,l]=Bt.parseSliceParams(a,s,i);if(Bt.assertParamsValid(a,o,l),w.sizeFromShape(l)===0)return n.makeTensorInfo(l,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||a.dtype==="string"){let h=n.texData.get(a.dataId),d=hQ(h.values,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,d)}let{isPacked:u}=n.texData.get(a.dataId),p=Bt.isSliceContinous(a.shape,o,l);if(u||!p){let h=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new wte(l):new xte(l),d=[o];return n.runWebGLProgram(h,[a],a.dtype,d)}return n.uploadToGPU(a.dataId),kte(a,o,l,n)}var Ite={kernelName:fu,backendName:"webgl",kernelFunc:Hu},Ste=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;w.assert(a.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let o=s.reduce((b,x)=>b*x),l=T.getReshaped(a.shape,s,o),u=T.getPermuted(l.length,s.length),p=T.getReshapedPermuted(a.shape,s,o),h=T.getSliceBeginCoords(i,s.length),d=T.getSliceSize(p,i,s.length),c=[],m=pe({inputs:{x:a},backend:n,attrs:{shape:l}}),f=xn({inputs:{x:m},backend:n,attrs:{perm:u}}),g=pe({inputs:{x:f},backend:n,attrs:{shape:p}}),y=Hu({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return c.push(m),c.push(f),c.push(g),c.forEach(b=>n.disposeIntermediateTensorInfo(b)),y},Nte={kernelName:$l,backendName:"webgl",kernelFunc:Ste};function Tte(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=n.readSync(a.dataId),l=n.readSync(s.dataId),u=qE(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}var Cte={kernelName:Al,backendName:"webgl",kernelFunc:Tte},_te=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,Ete=`
  return float(int(a.r) & int(b.r));
`;function $te(e){let{inputs:t,backend:n}=e,{a:r,b:a}=t,s=G().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=G().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,a])||i===1){let l=n.texData.get(r.dataId).values,u=n.texData.get(a.dataId).values,[p,h]=O9(r.shape,a.shape,l,u,r.dtype),d=n.makeTensorInfo(h,r.dtype),c=n.texData.get(d.dataId);return c.values=p,d}let o;return s?o=new Uu(_te,r.shape,a.shape,!1):o=new ri(Ete,r.shape,a.shape),n.runWebGLProgram(o,[r,a],r.dtype)}var Ate={kernelName:Fl,backendName:"webgl",kernelFunc:$te};function Fte(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.readSync(r.dataId),i=n.readSync(a.dataId),o=T.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var Rte={kernelName:Xp,backendName:"webgl",kernelFunc:Fte},Dte="return float(a != b);",u$=on({opSnippet:Dte,cpuKernelImpl:rQ,dtype:"bool"}),Mte={kernelName:nu,backendName:"webgl",kernelFunc:u$};function Hd(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.texData.get(r.dataId);return qn({inputs:{x:a.complexTensorInfos.real},backend:n})}var Ote={kernelName:Uc,backendName:"webgl",kernelFunc:Hd},Lte="return float(int(x));";function zte(e,t){let n=new Vr(e.shape,Lte),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function lx(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if(s==="complex64"){if(a.dtype==="complex64")return qn({inputs:{x:a},backend:n});let i=It(a.shape),o=lx({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),l=gs({inputs:{real:o,imag:i},backend:n});return i.dispose(),n.disposeIntermediateTensorInfo(o),l}if(a.dtype==="complex64"){let i=Hd({inputs:{input:a},backend:n}),o=lx({inputs:{x:i},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(i),o}if(!w.hasEncodingLoss(a.dtype,s)){let i=qn({inputs:{x:a},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(n.shouldExecuteOnCPU([a])){let i=n.texData.get(a.dataId).values,[o,l,u]=L9(i,a.shape,a.dtype,s);return n.makeTensorInfo(o,l,u)}if(s==="int32")return zte(a,n);if(s==="bool"){let i=n.makeTensorInfo([],"bool",w.getTypedArrayFromDType("bool",1)),o=u$({inputs:{a,b:i},backend:n});return n.disposeIntermediateTensorInfo(i),o}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${s}`)}var Pte={kernelName:yi,backendName:"webgl",kernelFunc:lx},DI="return ceil(x);",Bte=qe({opSnippet:DI,packedOpSnippet:DI,cpuKernelImpl:z9}),Wte={kernelName:bi,backendName:"webgl",kernelFunc:Bte},Vte=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}},Ute=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function Gte(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:s,clipValueMax:i}=r,o;G().getBool("WEBGL_PACK_CLIP")?o=new Ute(a.shape):o=new Vte(a.shape);let l=[[s],[i]];return n.runWebGLProgram(o,[a],a.dtype,l)}var Hte={kernelName:os,backendName:"webgl",kernelFunc:Gte},jte=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function MI(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function qte(e){let{inputs:t,backend:n}=e,{x:r}=t,a=n.texData.get(r.dataId),s=new jte(r.shape),i=[MI(r,a.complexTensorInfos.real),MI(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(s,i,i[0].dtype)}var Kte={kernelName:Zp,backendName:"webgl",kernelFunc:qte},Xte=class{constructor(e){this.outputShape=[],this.outputShape=T.computeOutShape(e,1),this.variableNames=e.map((s,i)=>`T${i}`);let t=new Array(e.length-1);t[0]=e[0][1];for(let s=1;s<t.length;s++)t[s]=t[s-1]+e[s][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<t.length;s++){let i=t[s-1];n.push(`else if (yC < ${t[s]}) setOutput(getT${s}(yR, yC-${i}));`)}let r=t.length,a=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${a}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}},Zte=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=T.computeOutShape(e,t);let n=this.outputShape,r=n.length,a=ut(r),s=gn("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((m,f)=>`T${f}`);let o=new Array(e.length-1);o[0]=e[0][t];for(let m=1;m<o.length;m++)o[m]=o[m-1]+e[m][t];let l=i[t],u=i.slice(-2),p=i.join(),h=`if (${l} < ${o[0]}) {
        return getChannel(
            getT0(${p}), vec2(${u.join()}));
        }`;for(let m=1;m<o.length;m++){let f=o[m-1];h+=`
        if (${l} < ${o[m]}  && ${l} >= ${o[m-1]}) {
          return getChannel(
            getT${m}(${Lh(i,l,f)}),
            vec2(${Lh(u,l,f)}));
        }`}let d=o.length,c=o[o.length-1];h+=`
        return getChannel(
          getT${d}(${Lh(i,l,c)}),
          vec2(${Lh(u,l,c)}));`,this.userCode=`
      float getValue(${i.map(m=>"int "+m)}) {
        ${h}
      }

      void main() {
        ${a} coords = getOutputCoords();
        vec4 result = vec4(getValue(${s}), 0., 0., 0.);

        ${s[r-1]} = ${s[r-1]} + 1;
        if (${s[r-1]} < ${n[r-1]}) {
          result.g = getValue(${s});
        }

        ${s[r-2]} = ${s[r-2]} + 1;
        if (${s[r-2]} < ${n[r-2]}) {
          result.a = getValue(${s});
        }

        ${s[r-1]} = ${s[r-1]} - 1;
        if (${s[r-2]} < ${n[r-2]} &&
            ${s[r-1]} < ${n[r-1]}) {
          result.b = getValue(${s});
        }
        setOutput(result);
      }
    `}};function Lh(e,t,n){let r=e.indexOf(t);return e.map((a,s)=>s===r?`${a} - ${n}`:a).join()}function Qm(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.texData.get(r.dataId);return qn({inputs:{x:a.complexTensorInfos.imag},backend:n})}var Jte={kernelName:Pc,backendName:"webgl",kernelFunc:Qm};function gp(e,t,n){let r=e[0].dtype;if(r==="complex64"){let c=e.map(b=>Hd({inputs:{input:b},backend:n})),m=e.map(b=>Qm({inputs:{input:b},backend:n})),f=gp(c,t,n),g=gp(m,t,n),y=gs({inputs:{real:f,imag:g},backend:n});return c.forEach(b=>n.disposeIntermediateTensorInfo(b)),m.forEach(b=>n.disposeIntermediateTensorInfo(b)),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),y}let a=n.shouldExecuteOnCPU(e);if(r==="string"&&(a=!0),a){let c=e.map(v=>{let I=[-1,w.sizeFromShape(v.shape.slice(t))];return pe({inputs:{x:v},backend:n,attrs:{shape:I}})}),m=c.map(v=>({vals:n.readSync(v.dataId),shape:v.shape})),f=T.computeOutShape(c.map(v=>v.shape),1),g=c[0].shape[0]===1,y=P9(m,f,r,g),b=T.computeOutShape(e.map(v=>v.shape),t),x=n.makeTensorInfo(b,r,y);return c.forEach(v=>n.disposeIntermediateTensorInfo(v)),x}let s=e.filter(c=>w.sizeFromShape(c.shape)>0),i=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(s.length===1){let c=i?new Vr(e[0].shape,Da):new Pa(e[0].shape,Da);return n.runWebGLProgram(c,e,r)}let o=G().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>o){let c=[];for(let f=0;f<s.length;f+=o){let g=s.slice(f,f+o);c.push(gp(g,t,n))}let m=gp(c,t,n);for(let f of c)n.disposeIntermediateTensorInfo(f);return m}if(i){let c=new Zte(s.map(m=>m.shape),t);return n.runWebGLProgram(c,s,r)}let{tensors2D:l,outShape:u}=Yte(s,t,n),p=new Xte(l.map(c=>c.shape)),h=n.runWebGLProgram(p,l,r);l.forEach(c=>n.disposeIntermediateTensorInfo(c));let d=pe({inputs:{x:h},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(h),d}function Yte(e,t,n){let r=T.computeOutShape(e.map(a=>a.shape),t);return{tensors2D:e.map(a=>pe({inputs:{x:a},attrs:{shape:[-1,w.sizeFromShape(a.shape.slice(t))]},backend:n})),outShape:r}}function p$(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=w.parseAxisParam(a,t[0].shape)[0],i=t.map(u=>u.shape);T.assertParamsConsistent(i,s);let o=T.computeOutShape(t.map(u=>u.shape),s);if(w.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(u=>w.sizeFromShape(u.shape)>0);return l.length===1?qn({inputs:{x:l[0]},backend:n}):gp(l,s,n)}var Qte={kernelName:Rl,backendName:"webgl",kernelFunc:p$},d$=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let s=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,p=e.dilationWidth,h=e.filterHeight,d=e.filterWidth,c=Math.floor(e.inChannels/4)*4,m=e.inChannels%4,f=e.dataFormat==="channelsLast",g=f?1:2,y=f?2:3,b=f?3:1,x="",v="";n&&(r?x=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:a?x=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:x=`
          float activation(float x) {
            ${n}
          }
        `,v="result = activation(result);");let I=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${x}

      const ivec2 strides = ivec2(${o}, ${l});
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${b}];

        ivec2 xRCCorner =
            ivec2(coords[${g}], coords[${y}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${h}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${d}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${c}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${f}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${m===1}) {

              if (${f}) {
                dotProd +=
                    getX(batch, xR, xC, ${c}) *
                    getW(wR, wC, ${c}, d2);
              } else {
                dotProd +=
                    getX(batch, ${c}, xR, xC) *
                    getW(wR, wC, ${c}, d2);
              }

            } else if (${m===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${c}, d2),
                getW(wR, wC, ${c} + 1, d2)
              );

              if (${f}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${c}),
                  getX(batch, xR, xC, ${c} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${c}, xR, xC),
                  getX(batch, ${c} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${m===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${c}, d2),
                getW(wR, wC, ${c} + 1, d2),
                getW(wR, wC, ${c} + 2, d2)
              );

              if (${f}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${c}),
                  getX(batch, xR, xC, ${c} + 1),
                  getX(batch, xR, xC, ${c} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${c}, xR, xC),
                  getX(batch, ${c} + 1, xR, xC),
                  getX(batch, ${c} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${I}
        ${v}
        setOutput(result);
      }
    `}},ene=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,p=e.filterDepth,h=e.filterHeight,d=e.filterWidth,c=Math.floor(e.inChannels/4)*4,m=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${a}, ${s}, ${i});
      const ivec3 pads = ivec3(${t}, ${n}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${o};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${h}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${c}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${m===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${c}) *
                  getW(wF, wR, wC, ${c}, d2);
              } else if (${m===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${c}),
                  getX(batch, xF, xR, xC, ${c} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${c}, d2),
                  getW(wF, wR, wC, ${c} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${m===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${c}),
                  getX(batch, xF, xR, xC, ${c} + 1),
                  getX(batch, xF, xR, xC, ${c} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${c}, d2),
                  getW(wF, wR, wC, ${c} + 1, d2),
                  getW(wF, wR, wC, ${c} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},h$=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=cn(this.outputShape.length);let s=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,p=u,h=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let f=0;f<u;f++)h+=`
           vec4 xTexelC${f*2};
           int xTexelC${f*2}Ready;
           vec4 xTexelC${f*2+1};
           int xTexelC${f*2+1}Ready;
           vec4 xC${f};`;h+=`
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let f=0;f<u;f++)h+=`
           xTexelC${f*2} = vec4(0.0);
           xTexelC${f*2}Ready = 0;
           xTexelC${f*2+1} = vec4(0.0);
           xTexelC${f*2+1}Ready = 0;
           xC${f} = vec4(0.0);`;h+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let f=0;f<(p+1)/2;f++){let g=f*2;if(h+=`
           xC = xCCorner + ${g*o};
           `,i===1){if(g<u&&(s%2===1?(h+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }
               `,o===1&&g>0?h+=`
                 xC${g} = vec4(xTexelC${g-2}.zw, xTexelC${g}.xy);
                 `:h+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${g} = vec4(previous.zw, xTexelC${g}.xy);
                   } else {
                     xC${g} = vec4(0.0, 0.0, xTexelC${g}.xy);
                   }
                   `):h+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 xC${g} = xTexelC${g};
                 `,g+1<u)){let y=s%2===0?w.nearestLargerEven(o):o;o%2===0&&s%2===1||o%2!==0&&s%2!==1?(h+=`
                   xCOffset = xC + imod(pads[1], 2) + ${y};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                     xTexelC${g+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${g+1}.zw = vec2(0.0);
                     }
                     xTexelC${g+1}Ready = 1;
                   }
                   `,o>1?h+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${g+1} = vec4(previous.zw, xTexelC${g+1}.xy);
                     } else {
                      xC${g+1} = vec4(0.0, 0.0, xTexelC${g+1}.xy);
                     }
                     `:h+=`
                     xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.xy);
                     `):y===1?h+=`
                     xC${g+1} = xTexelC${g};
                     `:h+=`
                     xCOffset = xC + ${y};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                       xTexelC${g+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${g+1}.zw = vec2(0.0);
                       }
                       xTexelC${g+1}Ready = 1;
                     }

                     xC${g+1} = xTexelC${g+1};
                     `}}else g<u&&(s%2===1?(h+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${g+1}Ready == 0) {
                   xTexelC${g+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${g+1}.zw = vec2(0.0);
                   }
                   xTexelC${g+1}Ready = 1;
                 }

                 xC${g} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);
               `,g+1<u&&(h+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${g+1} = vec4(xTexelC${g+1}.xy, final.xy);
                 `)):(h+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                   xTexelC${g+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g+1}.zw = vec2(0.);
                   }
                   xTexelC${g+1}Ready = 1;
                 }

                 xC${g} = vec4(
                   xTexelC${g}.xy, xTexelC${g+1}.xy);
               `,g+1<u&&(h+=`
                   xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);
                 `)));g<u&&(h+=`
             wTexel = getW(r, ${g}, d1, d2);
             dotProd += xC${g}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${g}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,g+1<u&&(h+=`
               wTexel = getW(r, ${g+1}, d1, d2);
               dotProd += xC${g+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${g+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}h+=`
     }
   `,h+=`
     }
   `,h+=`
     }
   `;let d="",c="";n&&(r?d=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n}
         }`:a?d=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n}
         }`:d=`vec4 activation(vec4 x) {
           ${n}
         }`,c="result = activation(result);");let m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${d}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${h}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${m}
         ${c}
         setOutput(result);
       }
     `}},tne=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=cn(this.outputShape.length);let{dataFormat:n}=t,r=In(),a=n==="channelsLast",s=a?1:2,i=a?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,l="";for(let u=0;u<=1;u++)for(let p=0;p<=1;p++)l+=`
          blockIndex = rc.z + ${p};
          pos = rc.y + ${u};

          ${o}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${s}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${a}) {
                  innerDims = vec2(d1, ch);
                  result[${u*2+p}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${u*2+p}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${r.output} = result;
      }
    `}};function Ic(e,t){let n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&n===1&&e[0]>1?[e[0],1]:null}function c$({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let l=e.shape,u=r.texData.get(e.dataId),p=n.inChannels,h=l[0]*l[1]*l[2],d=n.outChannels,c=n.dataFormat==="channelsLast",m=!1,f=!1,g,y=[];if(s!=null){let b=Ic(s.shape,c);b!=null&&(s=pe({inputs:{x:s},backend:r,attrs:{shape:b}}),y.push(s))}if(a!=null){let b=Ic(a.shape,c);b!=null&&(a=pe({inputs:{x:a},backend:r,attrs:{shape:b}}),y.push(a))}if(!((h===1||d===1)&&p>s$)&&u.isPacked&&c&&u.texture!=null&&l[2]%2!==0&&w.arraysEqual(u.shape.slice(-3),l.slice(-3))){let b=l[0]*l[1]*(l[2]+1),x={dataId:e.dataId,shape:[1,b,n.inChannels],dtype:e.dtype},v=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,w.assert(Lp(u.shape,x.shape),()=>`packed reshape ${u.shape} to ${x.shape} isn't free`);let I=pe({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});y.push(I);let N=kc({a:x,b:I,backend:r,transposeA:m,transposeB:f,bias:a,activation:o,preluActivationWeights:s,leakyreluAlpha:i}),C=r.texData.get(N.dataId);w.assert(C.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=v,C.shape=n.outShape,g=qn({inputs:{x:N},backend:r}),g.shape=n.outShape,y.push(N)}else{let b=n.outHeight*n.outWidth,x=pe({inputs:{x:e},backend:r,attrs:{shape:c?[n.batchSize,b,n.inChannels]:[n.batchSize,n.inChannels,b]}}),v=pe({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),I=kc({a:c?x:v,b:c?v:x,transposeA:!c,transposeB:f,backend:r,bias:a,activation:o,preluActivationWeights:s,leakyreluAlpha:i});g=pe({inputs:{x:I},backend:r,attrs:{shape:n.outShape}}),y.push(x),y.push(v),y.push(I)}for(let b of y)r.disposeIntermediateTensorInfo(b);return g}function m$({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let{filterWidth:l,filterHeight:u,inChannels:p,outWidth:h,outHeight:d,dataFormat:c}=n,m=c==="channelsLast",f=l*u*p,g=d*h,y=[n.batchSize,f,g],b=!0,x=!1,v=[];if(s!=null){let K=Ic(s.shape,m);K!=null&&(s=pe({inputs:{x:s},backend:r,attrs:{shape:K}}),v.push(s))}if(a!=null){let K=Ic(a.shape,m);K!=null&&(a=pe({inputs:{x:a},backend:r,attrs:{shape:K}}),v.push(a))}let I=pe({inputs:{x:t},backend:r,attrs:{shape:[1,f,w.sizeFromShape(t.shape)/f]}});v.push(I);let N=new tne(y,n),C=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],E=r.runWebGLProgram(N,[e],"float32",C),A=pe({inputs:{x:E},backend:r,attrs:{shape:y}});v.push(E),v.push(A);let R=a!=null,F=s!=null,S=o==="leakyrelu",M=o?zp(o,!0):null,W=new a$(m?A.shape:I.shape,m?I.shape:A.shape,m?[n.batchSize,g,n.outChannels]:[n.batchSize,n.outChannels,g],b,x,R,M,F,S),U=m?[A,I]:[I,A];if(a&&U.push(a),F&&U.push(s),S){let K=r.makeTensorInfo([],"float32",w.createScalarValue(i,"float32"));U.push(K),v.push(K)}let H=r.runWebGLProgram(W,U,"float32"),q=pe({inputs:{x:H},backend:r,attrs:{shape:n.outShape}});v.push(H);for(let K of v)r.disposeIntermediateTensorInfo(K);return q}function nne(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:p}=r,h=T.convertConv2DDataFormat(l),d=T.computeConv2DInfo(a.shape,s.shape,i,u,o,p,!1,h),c;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))c=c$({x:a,filter:s,convInfo:d,backend:n});else if(d.strideWidth<=2&&h==="channelsLast"&&G().getBool("WEBGL_EXP_CONV")){let f=new h$(d),g=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];c=n.runWebGLProgram(f,[a,s],"float32",g)}else if(G().getBool("WEBGL_CONV_IM2COL"))c=m$({x:a,filter:s,convInfo:d,backend:n});else{let f=new d$(d);c=n.runWebGLProgram(f,[a,s],"float32")}let m=pe({inputs:{x:c},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(c),m}var rne={kernelName:xi,backendName:"webgl",kernelFunc:nne},ane=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${s?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},sne=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=e.dataFormat==="channelsLast",i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=s?1:2,u=s?2:3,p=s?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${s}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},ine=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${a};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${s};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${i};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},one=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${o}, ${l}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${a}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function lne(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:p}=r,h=T.convertConv2DDataFormat(l),d=T.computeConv2DInfo(a.shape,p,i,1,o,u,!1,h),c=new ane(d);return n.runWebGLProgram(c,[a,s],"float32")}var une={kernelName:Fc,backendName:"webgl",kernelFunc:lne},pne=class{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=cn(this.outputShape.length);let t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,a=n-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            int wCPerm = ${n} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}};function dne(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:p}=r,h=T.convertConv2DDataFormat(u),d=T.computeConv2DInfo(i,s.shape,o,1,l,p,!1,h);if(G().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&h==="channelsLast"){let c=[[d.strideHeight,d.strideWidth]],m=new pne(d);return n.runWebGLProgram(m,[a,s],"float32",c)}else{let c=new sne(d);return n.runWebGLProgram(c,[a,s],"float32")}}var hne={kernelName:vi,backendName:"webgl",kernelFunc:dne};function cne(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,u=T.computeConv3DInfo(a.shape,s.shape,i,l,o),p=new ene(u);return n.runWebGLProgram(p,[a,s],"float32")}var mne={kernelName:wi,backendName:"webgl",kernelFunc:cne};function fne(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r,u=T.computeConv3DInfo(a.shape,l,i,1,o),p=new ine(u);return n.runWebGLProgram(p,[a,s],"float32")}var gne={kernelName:Dl,backendName:"webgl",kernelFunc:fne};function yne(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r,u=T.computeConv3DInfo(l,s.shape,o,1,i),p=new one(u);return n.runWebGLProgram(p,[a,s],"float32")}var bne={kernelName:Ml,backendName:"webgl",kernelFunc:yne},xne=Gu+`
  return cos(x);
`,vne=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Mo}
  return result;
`,wne=qe({opSnippet:xne,packedOpSnippet:vne}),kne={kernelName:ki,backendName:"webgl",kernelFunc:wne},Ine=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Sne=qe({opSnippet:Ine}),Nne={kernelName:Ii,backendName:"webgl",kernelFunc:Sne},Tne=class{constructor(e,t,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[s,i,o,l]=e,[u]=t,[p,h]=n;this.outputShape=[u,p,h,l];let d=r==="bilinear"?1:0,[c,m]=[`${i-1}.0`,`${o-1}.0`],[f,g,y]=p>1?[`${(i-1)/(p-1)}`,"(y2-y1) * height_ratio",`y1*${c} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${c}`],[b,x,v]=h>1?[`${(o-1)/(h-1)}`,"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`
      const float height_ratio = float(${f});
      const float width_ratio = float(${b});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${s}) {
          return;
        }

        float height_scale = ${g};
        float width_scale = ${x};

        float in_y = ${y};
        if( in_y < 0.0 || in_y > ${c} ) {
          setOutput(float(${a}));
          return;
        }
        float in_x = ${v};
        if( in_x < 0.0 || in_x > ${m} ) {
          setOutput(float(${a}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${d} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}},Cne=e=>{let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,p=new Tne(a.shape,s.shape,o,l,u);return n.runWebGLProgram(p,[a,s,i],"float32")},_ne={kernelName:Ll,backendName:"webgl",kernelFunc:Cne},Bp;(function(e){e.Prod="*",e.Sum="+"})(Bp||(Bp={}));var OI=class{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let a=this.outputShape.length,s=this.op===Bp.Prod?"1.0":"0.0",i=n?s:`getX(${LI(a,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1],l="",u="";n?(l=r?`end != ${o-1}`:"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${ut(a)} coords = getOutputCoords();
        int end = ${zI(a,"coords",this.op)};
        float val = ${i};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${u};
          ${zI(a,"coords",this.op)} = idx;
          val ${this.op}= getX(${LI(a,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function LI(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.x, ${t}.y`;if(e===3)return`${t}.x, ${t}.y, ${t}.z`;if(e===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function zI(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.y`;if(e===3)return`${t}.z`;if(e===4)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function f$(e,t,n,r,a,s){let i=t.shape.length,o=T.getAxesPermutation([r],i),l=t;o!=null&&(l=xn({inputs:{x:t},backend:n,attrs:{perm:o}}));let u=T.getInnerMostAxes(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);let p=l.shape[u],h=qn({inputs:{x:l},backend:n});for(let d=0;d<=Math.ceil(Math.log2(p))-1;d++){let c=new OI(e,l.shape,!1,s),m=[[d]],f=h;h=n.runWebGLProgram(c,[h],h.dtype,m),n.disposeIntermediateTensorInfo(f)}if(a){let d=new OI(e,l.shape,a,s),c=h;h=n.runWebGLProgram(d,[h],h.dtype),n.disposeIntermediateTensorInfo(c)}if(o!=null){let d=T.getUndoAxesPermutation(o),c=xn({inputs:{x:h},backend:n,attrs:{perm:d}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(l),c}return h}function Ene(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return f$(Bp.Prod,a,n,s,i,o)}var $ne={kernelName:Ol,backendName:"webgl",kernelFunc:Ene};function Ane(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return f$(Bp.Sum,a,n,s,i,o)}var Fne={kernelName:Si,backendName:"webgl",kernelFunc:Ane};function Rne(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(a.shape.length===1){let l=n.readSync(a.dataId),u=n.readSync(s.dataId),p=qE(l,u,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,p)}else if(a.shape.length===2){let l=n.bufferSync(a),u=n.bufferSync(s),p=M9(l,u,i,o);return n.makeTensorInfo(p.shape,s.dtype,p.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}var Dne={kernelName:Jp,backendName:"webgl",kernelFunc:Rne},Mne=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function One(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r,o=a.shape[0],l=i==="NHWC"?a.shape[1]:a.shape[2],u=i==="NHWC"?a.shape[2]:a.shape[3],p=i==="NHWC"?a.shape[3]:a.shape[1],h=l*s,d=u*s,c=p/(s*s),m=i==="NHWC"?[o,h,d,c]:[o,c,h,d],f=new Mne(m,s,i);return n.runWebGLProgram(f,[a],a.dtype)}var Lne={kernelName:zl,backendName:"webgl",kernelFunc:One},g$=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=cn(this.outputShape.length);let s=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels,l="",u="";n&&(r?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:a?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:l=`
          float activation(float x) {
            ${n}
          }
        `,u="result = activation(result);");let p=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${s}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${p}
        ${u}
        setOutput(result);
      }
    `}},y$=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=cn(this.outputShape.length);let s=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,p=e.filterWidth,h=p,d=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<p;g++)d+=`
          vec4 xTexelC${g*2};
          int xTexelC${g*2}Ready;
          vec4 xTexelC${g*2+1};
          int xTexelC${g*2+1}Ready;
          vec4 xC${g};`;d+=`
    for (int r = 0; r < ${u}; r++) {
      `;for(let g=0;g<p;g++)d+=`
          xTexelC${g*2} = vec4(0.0);
          xTexelC${g*2}Ready = 0;
          xTexelC${g*2+1} = vec4(0.0);
          xTexelC${g*2+1}Ready = 0;
          xC${g} = vec4(0.0);`;d+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let g=0;g<(h+1)/2;g++){let y=g*2;if(d+=`
          xC = xCCorner + ${y*l};
          `,o===1){if(y<p&&(i%2===1?(d+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }
              `,l===1&&y>0?d+=`
                xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                `:d+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                  } else {
                    xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                  }
                  `):d+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xC${y} = xTexelC${y};
                `,y+1<p)){let b=i%2===0?w.nearestLargerEven(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(d+=`
                  xCOffset = xC + imod(pads[1], 2) + ${b};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                    xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${y+1}.zw = vec2(0.0);
                    }
                    xTexelC${y+1}Ready = 1;
                  }
                  `,l>1?d+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                    } else {
                     xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                    }
                    `:d+=`
                    xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                    `):b===1?d+=`
                    xC${y+1} = xTexelC${y};
                    `:d+=`
                    xCOffset = xC + ${b};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                      xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${y+1}.zw = vec2(0.0);
                      }
                      xTexelC${y+1}Ready = 1;
                    }

                    xC${y+1} = xTexelC${y+1};
                    `}}else y<p&&(i%2===1?(d+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                  xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${y+1}.zw = vec2(0.0);
                  }
                  xTexelC${y+1}Ready = 1;
                }

                xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
              `,y+1<p&&(d+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                `)):(d+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                  xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y+1}.zw = vec2(0.);
                  }
                  xTexelC${y+1}Ready = 1;
                }

                xC${y} = vec4(
                  xTexelC${y}.xy, xTexelC${y+1}.xy);
              `,y+1<p&&(d+=`
                  xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                `)));y<p&&(d+=`
            wTexel = getW(r, ${y}, d1, q);
            dotProd += xC${y} * vec4(wTexel.xz, wTexel.xz);
          `,y+1<p&&(d+=`
              wTexel = getW(r, ${y+1}, d1, q);
              dotProd += xC${y+1} * vec4(wTexel.xz, wTexel.xz);
            `))}d+=`
    }
  `,d+=`
      }
    `;let c="",m="";n&&(r?c=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:a?c=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:c=`vec4 activation(vec4 x) {
          ${n}
        }`,m="result = activation(result);");let f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${s};
        int q = d2 - d1 * ${s};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${d}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${f}
        ${m}
        setOutput(result);
      }
    `}};function zne(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r,p=l;p==null&&(p=[1,1]),w.assert(T.eitherStridesOrDilationsAreOne(i,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${p}'`);let h=T.computeConv2DInfo(a.shape,s.shape,i,p,o,u,!0),d;G().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?d=new y$(h):d=new g$(h);let c=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(d,[a,s],"float32",c)}var Pne={kernelName:Ni,backendName:"webgl",kernelFunc:zne},Bne=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${s} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Wne=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${o}; dm++) {
              int d2 = d1 * ${o} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Vne(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:p}=r,h=T.computeConv2DInfo(a.shape,p,i,o,l,u,!0),d=new Bne(h);return n.runWebGLProgram(d,[a,s],"float32")}var Une={kernelName:Rc,backendName:"webgl",kernelFunc:Vne};function Gne(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:p}=r,h=T.computeConv2DInfo(p,s.shape,i,o,l,u,!0),d=new Wne(h);return n.runWebGLProgram(d,[a,s],"float32")}var Hne={kernelName:Dc,backendName:"webgl",kernelFunc:Gne},jne=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function qne(e){let{inputs:t,backend:n}=e,{x:r}=t,a=[...r.shape,...r.shape],s=w.sizeFromShape(r.shape),i=pe({inputs:{x:r},backend:n,attrs:{shape:[s]}}),o=new jne(s),l=n.runWebGLProgram(o,[i],i.dtype),u=pe({inputs:{x:l},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}var Kne={kernelName:Yp,backendName:"webgl",kernelFunc:qne},Xne=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:r,strideHeight:a,strideWidth:s,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:p,left:h}=r;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${s});
      const ivec2 pads = ivec2(${p}, ${h});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${o}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function Zne(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,u=T.computeDilation2DInfo(a.shape,s.shape,i,o,"NHWC",l),p,h=new Xne(u);p=n.runWebGLProgram(h,[a,s],"float32");let d=pe({inputs:{x:p},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(p),d}var Jne={kernelName:Ti,backendName:"webgl",kernelFunc:Zne};function Yne(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=T.decodeEinsumEquation(a,s.length);T.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:p}=T.getEinsumComputePath(o,l),h=p.length,d=null,c=i.length,m=[];for(let f=0;f<h;++f){for(let g of p[f]){let{permutationIndices:y,expandDims:b}=T.getEinsumPermutation(c,l[g]),x;T.isIdentityPermutation(y)?x=s[g]:(x=xn({inputs:{x:s[g]},backend:n,attrs:{perm:y}}),m.push(x));let v=x.shape.slice();for(let I=0;I<b.length;++I)v.splice(b[I],0,1);w.arraysEqual(x.shape,v)||(x=pe({inputs:{x},backend:n,attrs:{shape:v}}),m.push(x)),d===null?d=x:(d=h1({inputs:{a:x,b:d},backend:n}),m.push(d))}f<h-1&&(u[f]>=0&&(d=Ym({inputs:{x:d},backend:n,attrs:{axis:u[f]-(i.length-c),keepDims:!1}}),m.push(d)),c--)}for(let f of m)f!==d&&n.disposeIntermediateTensorInfo(f);return d}var Qne={kernelName:Oc,backendName:"webgl",kernelFunc:Yne},ere="return (x >= 0.0) ? x : (exp(x) - 1.0);",tre=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,nre=qe({opSnippet:ere,packedOpSnippet:tre}),rre={kernelName:_i,backendName:"webgl",kernelFunc:nre},are="return (b >= 0.0) ? a : a * (b + 1.0);",sre=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,ire=e=>{let{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Uu(sre,r.shape,a.shape):new ri(are,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],r.dtype)},ore={kernelName:Pl,backendName:"webgl",kernelFunc:ire},lre=`
  return vec4(equal(a, b));
`,ure="return float(a == b);",pre=on({opSnippet:ure,packedOpSnippet:lre,dtype:"bool",cpuKernelImpl:B9}),dre={kernelName:Bl,backendName:"webgl",kernelFunc:pre},hre=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${T.ERF_P};
  float a1 = ${T.ERF_A1};
  float a2 = ${T.ERF_A2};
  float a3 = ${T.ERF_A3};
  float a4 = ${T.ERF_A4};
  float a5 = ${T.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,cre=qe({opSnippet:hre}),mre={kernelName:Ei,backendName:"webgl",kernelFunc:cre},fre=Gu+`
  return exp(x);
`,gre=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,b$=qe({opSnippet:fre,packedOpSnippet:gre,cpuKernelImpl:W9,dtype:"float32"}),yre={kernelName:$i,backendName:"webgl",kernelFunc:b$};function ux(e){let{inputs:t,attrs:n,backend:r}=e,{dim:a}=n,{input:s}=t,i=s.shape.length,o=s.shape.slice(),l=a;return a<0&&(w.assert(-(i+1)<=a,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+a+1),o.splice(l,0,1),pe({inputs:{x:s},backend:r,attrs:{shape:o}})}var bre={kernelName:Wl,backendName:"webgl",kernelFunc:ux},PI="return exp(x) - 1.0;",xre=qe({opSnippet:PI,packedOpSnippet:PI,cpuKernelImpl:V9}),vre={kernelName:Ai,backendName:"webgl",kernelFunc:xre},BI=class{constructor(e,t,n){this.variableNames=["real","imag"];let r=t[1];this.outputShape=t;let a=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,s=n?`${r}.0`:"1.0",i;if(e==="real")i="return real * expR - imag * expI;";else if(e==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${a};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${s};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function x$(e,t,n){let r=n.texData.get(e.dataId),a=w.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],i=a/s,o=pe({inputs:{x:e},backend:n,attrs:{shape:[i,s]}}),l=o.shape,u=new BI("real",l,t),p=new BI("imag",l,t),h=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],d=n.runWebGLProgram(u,h,"float32"),c=n.runWebGLProgram(p,h,"float32"),m=gs({inputs:{real:d,imag:c},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c);let f=pe({inputs:{x:m},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(m),f}function wre(e){let{inputs:t,backend:n}=e,{input:r}=t;return x$(r,!1,n)}var kre={kernelName:Lc,backendName:"webgl",kernelFunc:wre},Ire=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function jd(e){let{backend:t,attrs:n}=e,{shape:r,value:a}=n,{dtype:s}=n;if(s=s||w.inferDtype(a),s==="string"){let i=w.getArrayFromDType(s,w.sizeFromShape(r));return i.fill(a),t.makeTensorInfo(r,s,i)}else{let i=new Ire(r,a),o=[[a]];return t.runWebGLProgram(i,[],s,o)}}var Sre={kernelName:Qp,backendName:"webgl",kernelFunc:jd},Nre=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}},Tre={kernelName:Vl,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{let{image:n}=e,r=t,a=new Nre(n.shape);return r.runWebGLProgram(a,[n],n.dtype)}},WI="return floor(x);",Cre=qe({opSnippet:WI,packedOpSnippet:WI,cpuKernelImpl:U9}),_re={kernelName:Fi,backendName:"webgl",kernelFunc:Cre},Ere=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,$re=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,Are=on({opSnippet:Ere,packedOpSnippet:$re,dtype:"int32"}),Fre={kernelName:Ri,backendName:"webgl",kernelFunc:Are},Rre=class{constructor(e){this.variableNames=["A"];let t=In(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}},Dre=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=In(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${n}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}},Mre={kernelName:ec,backendName:"webgl",kernelFunc:Ore},Ko,pb=G().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function Ore(e){let{inputs:t,backend:n,attrs:r}=e,{pixels:a}=t,{numChannels:s}=r,i=typeof HTMLVideoElement!="undefined"&&a instanceof HTMLVideoElement,o=typeof HTMLImageElement!="undefined"&&a instanceof HTMLImageElement,[l,u]=i?[a.videoWidth,a.videoHeight]:[a.width,a.height],p=[u,l],h=[u,l,s];if(o||i){let f=G().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Ko==null||f!==pb)&&(pb=f,Ko=document.createElement("canvas").getContext("2d",{willReadFrequently:pb})),Ko.canvas.width=l,Ko.canvas.height=u,Ko.drawImage(a,0,0,l,u),a=Ko.canvas}let d=n.makeTensorInfo(p,"int32");n.texData.get(d.dataId).usage=tr.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),a);let c=G().getBool("WEBGL_PACK")?new Dre(h):new Rre(h),m=n.runWebGLProgram(c,[d],"int32");return n.disposeData(d.dataId),m}function Lre(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:p,dilations:h,dimRoundingMode:d,activation:c,leakyreluAlpha:m}=r,f=T.convertConv2DDataFormat(p),g=T.computeConv2DInfo(a.shape,s.shape,l,h,u,d,!1,f),y,b=[],x=i!=null,v=o!=null,I=c==="leakyrelu",N=()=>{let E=[a,s],A=(R,F)=>{if(F==="NCHW"&&R.shape.length===1&&R.shape[0]!==1){let S=pe({inputs:{x:R},backend:n,attrs:{shape:[R.shape[0],1,1]}});return b.push(S),S}return R};if(x&&E.push(A(i,p)),v&&E.push(A(o,p)),I){let R=n.makeTensorInfo([],"float32",w.createScalarValue(m,"float32"));E.push(R),b.push(R)}return E};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))y=c$({x:a,filter:s,convInfo:g,backend:n,bias:i,activation:c,preluActivationWeights:o,leakyreluAlpha:m});else if(g.strideWidth<=2&&f==="channelsLast"&&G().getBool("WEBGL_EXP_CONV")){let E=c?zp(c,!0):null,A=new h$(g,x,E,v,I),R=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],F=N();y=n.runWebGLProgram(A,F,"float32",R)}else if(G().getBool("WEBGL_CONV_IM2COL"))y=m$({x:a,filter:s,convInfo:g,backend:n,bias:i,activation:c,preluActivationWeights:o,leakyreluAlpha:m});else{let E=c?zp(c,!1):null,A=new d$(g,x,E,v,I),R=N();y=n.runWebGLProgram(A,R,"float32")}let C=pe({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return b.push(y),b.forEach(E=>n.disposeIntermediateTensorInfo(E)),C}var zre={kernelName:Ws,backendName:"webgl",kernelFunc:Lre};function Pre(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:p,dimRoundingMode:h,activation:d,leakyreluAlpha:c}=r,m=[],f=p;f==null&&(f=[1,1]),w.assert(T.eitherStridesOrDilationsAreOne(l,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${f}'`);let g=T.computeConv2DInfo(a.shape,s.shape,l,f,u,h,!0),y=G().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=d?zp(d,y):null,x=[a,s],v=i!=null,I=o!=null,N=d==="leakyrelu";if(v&&x.push(i),I&&x.push(o),N){let R=n.makeTensorInfo([],"float32",w.createScalarValue(c,"float32"));x.push(R),m.push(R)}let C;y?C=new y$(g,v,b,I,N):C=new g$(g,v,b,I,N);let E=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],A=n.runWebGLProgram(C,x,"float32",E);return m.forEach(R=>n.disposeIntermediateTensorInfo(R)),A}var Bre={kernelName:Vs,backendName:"webgl",kernelFunc:Pre},Wre=class{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;let a=ut(n.length),s=`
    int index;`;for(let i=0;i<this.sliceDim;i++)s+=`
          index = round(getIndices(coords[0], ${i}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};
          flattenIndex += index * ${this.strides[i]};`;this.userCode=`
         void main() {
          ${a} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${s}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function Vre(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=a.shape,i=s[s.length-1],o=w.sizeFromShape(r.shape),[l,u,p,h]=T.prepareAndValidate(r,a),d=pe({inputs:{x:a},backend:n,attrs:{shape:[u,i]}}),c=pe({inputs:{x:r},backend:n,attrs:{shape:[w.sizeFromShape(r.shape)/p,p]}});if(n.shouldExecuteOnCPU([r,a])||r.dtype==="string"){let y=n.readSync(a.dataId),b=n.bufferSync(r),x=G9(y,b,r.dtype,u,i,p,h,r.shape,o);return n.makeTensorInfo(l,r.dtype,x.values)}let m=new Wre(i,h,[u,p],r.shape),f=n.runWebGLProgram(m,[c,d],c.dtype),g=pe({inputs:{x:f},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),g}var Ure={kernelName:Gl,backendName:"webgl",kernelFunc:Vre},Gre=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=ut(this.rank),r=Hre(e,2);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}};function Hre(e,t){let n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let a=0;a<e.length;a++)a===2?r.push("index"):r.push(`${n[a]}`);return r.join()}function v$(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r,l=w.parseAxisParam(i,a.shape)[0];if(G().get("DEBUG")){let b=n.readSync(s.dataId),x=a.shape[l];for(let v=0;v<b.length;++v){let I=b[v];w.assert(I<=x-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${x-1}]`)}}let u=T.segment_util.collectGatherOpShapeInfo(a,s,l,o),p=w.sizeFromShape(s.shape),h=[],d=pe({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),c=pe({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,p/u.batchSize]}});h.push(d),h.push(c);let m=[u.batchSize,u.outerSize,p/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([a,s])||a.dtype==="string"){let b=n.bufferSync(c),x=n.bufferSync(d),v=H9(x,b,m);return h.forEach(I=>n.disposeIntermediateTensorInfo(I)),n.makeTensorInfo(u.outputShape,v.dtype,v.values)}let f=new Gre(d.shape,m),g=n.runWebGLProgram(f,[d,c],d.dtype);h.push(g);let y=pe({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return h.forEach(b=>n.disposeIntermediateTensorInfo(b)),y}var jre={kernelName:Ul,backendName:"webgl",kernelFunc:v$},qre="return float(a > b);",Kre=`
  return vec4(greaterThan(a, b));
`,Xre=on({opSnippet:qre,packedOpSnippet:Kre,cpuKernelImpl:j9,dtype:"bool"}),Zre={kernelName:Hl,backendName:"webgl",kernelFunc:Xre},Jre="return float(a >= b);",Yre=`
  return vec4(greaterThanEqual(a, b));
`,Qre=on({opSnippet:Jre,packedOpSnippet:Yre,dtype:"bool",cpuKernelImpl:q9}),eae={kernelName:Mi,backendName:"webgl",kernelFunc:Qre};function tae(e){let{inputs:t,backend:n}=e,{input:r}=t;return x$(r,!0,n)}var nae={kernelName:zc,backendName:"webgl",kernelFunc:tae},rae="return float(!isnan(x) && !isinf(x));",aae=qe({opSnippet:rae,dtype:"bool"}),sae={kernelName:Li,backendName:"webgl",kernelFunc:aae},iae="return float(isinf(x));",oae=qe({opSnippet:iae,dtype:"bool"}),lae={kernelName:zi,backendName:"webgl",kernelFunc:oae},uae="return float(isnan(x));",pae=qe({opSnippet:uae,dtype:"bool"}),dae={kernelName:Pi,backendName:"webgl",kernelFunc:pae},hae="return float(a < b);",cae=`
  return vec4(lessThan(a, b));
`,mae=on({opSnippet:hae,packedOpSnippet:cae,cpuKernelImpl:K9,dtype:"bool"}),fae={kernelName:jl,backendName:"webgl",kernelFunc:mae},gae="return float(a <= b);",yae=`
  return vec4(lessThanEqual(a, b));
`,bae=on({opSnippet:gae,packedOpSnippet:yae,cpuKernelImpl:X9,dtype:"bool"}),xae={kernelName:ql,backendName:"webgl",kernelFunc:bae};function vae(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=Z9(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}var wae={kernelName:Kl,backendName:"webgl",kernelFunc:vae},kae=Gu+`
  return x < 0.0 ? 0./0. : log(x);
`,Iae=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Sae=qe({opSnippet:kae,packedOpSnippet:Iae,cpuKernelImpl:J9}),Nae={kernelName:Wi,backendName:"webgl",kernelFunc:Sae},Tae=Gu+`
  return log(1.0 + x);
`,Cae=qe({opSnippet:Tae}),_ae={kernelName:Vi,backendName:"webgl",kernelFunc:Cae},Eae="return float(a >= 1.0 && b >= 1.0);",$ae=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Aae=on({opSnippet:Eae,packedOpSnippet:$ae,dtype:"bool"}),Fae={kernelName:Xl,backendName:"webgl",kernelFunc:Aae},Rae="return float(!(x >= 1.0));",Dae=qe({opSnippet:Rae}),Mae={kernelName:Zl,backendName:"webgl",kernelFunc:Dae},Oae="return float(a >= 1.0 || b >= 1.0);",Lae=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,zae=on({opSnippet:Oae,packedOpSnippet:Lae,dtype:"bool"}),Pae={kernelName:Jl,backendName:"webgl",kernelFunc:zae},Bae=class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[];let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;a===.5?o=`inversesqrt(${l})`:a===1?o=`1.0/(${l})`:o=`exp(log(${l}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${s}; j <= ${s}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${o};
        setOutput(val);
      }
    `}},Wae=class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;a===.5?o=`inversesqrt(${l})`:a===1?o=`1.0/(${l})`:o=`exp(log(${l}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${s};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${s}; j <= ${s}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${o};
        setOutput(result);
      }
    `}},Vae=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r,u=G().getBool("WEBGL_PACK_NORMALIZATION")?new Wae(a.shape,s,i,o,l):new Bae(a.shape,s,i,o,l);return n.runWebGLProgram(u,[a],a.dtype)},Uae={kernelName:Ui,backendName:"webgl",kernelFunc:Vae},Gae=class{constructor(e,t,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=a,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${a})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${a});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}},Hae=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:p}=r,h=new Gae(a.shape,o,l,u,p);return n.runWebGLProgram(h,[a,s,i],a.dtype)},jae={kernelName:Yl,backendName:"webgl",kernelFunc:Hae};function qae(e,t,n,r){let a=w.sizeFromShape(t),s=w.sizeFromShape(e.shape)/a,i=pe({inputs:{x:e},attrs:{shape:[s,a]},backend:r}),o=Oo(i,e.dtype,"max",r),l=pe({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),l}function w$(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=a.shape.length,l=w.parseAxisParam(s,a.shape),u=l,p=T.getAxesPermutation(u,o),h=p!=null,d=n.shouldExecuteOnCPU([a]),c=a;if(h){if(d){let b=n.texData.get(c.dataId).values,x=new Array(o);for(let N=0;N<x.length;N++)x[N]=a.shape[p[N]];let v=u1(b,a.shape,a.dtype,p,x);c=n.makeTensorInfo(x,a.dtype);let I=n.texData.get(c.dataId);I.values=v}else c=Jm(a,p,n);u=T.getInnerMostAxes(u.length,o)}T.assertAxesAreInnerMostDims("max",u,o);let[m,f]=T.computeOutAndReduceShapes(c.shape,u),g=m;i&&(g=T.expandShapeToKeepDim(m,l));let y;if(d){let b=n.texData.get(c.dataId).values,x=Y9(b,w.sizeFromShape(f),g,a.dtype);y=n.makeTensorInfo(g,a.dtype);let v=n.texData.get(y.dataId);v.values=x}else y=qae(c,f,g,n);return h&&n.disposeIntermediateTensorInfo(c),y}var Kae={kernelName:Gi,backendName:"webgl",kernelFunc:w$},Xae=d1+`
  return max(a, b);
`,Zae=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Mo+`
  return result;
`,Jae=on({opSnippet:Xae,packedOpSnippet:Zae,cpuKernelImpl:Q9}),Yae={kernelName:Hi,backendName:"webgl",kernelFunc:Jae};function Qae(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;zu(a,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,u=1;w.assert(T.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let p=T.computePool2DInfo(a.shape,s,i,u,o,l);if(p.filterWidth===1&&p.filterHeight===1&&w.arraysEqual(p.inShape,p.outShape))return qn({inputs:{x:a},backend:n});let h=new Pp(p,"max",!1);return n.runWebGLProgram(h,[a],a.dtype)}var ese={kernelName:ji,backendName:"webgl",kernelFunc:Qae};function tse(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=r,p=[1,1,1],h=T.computePool3DInfo(a.shape,s,i,p,o,u,l),d=new c1(h,"max",!1);return n.runWebGLProgram(d,[a],a.dtype)}var nse={kernelName:Ql,backendName:"webgl",kernelFunc:tse},rse=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,s=e.effectiveFilterWidth,i=a-1-e.padInfo.top,o=s-1-e.padInfo.left,l=a*s-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${a};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${s} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},ase=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,p=o-1-e.padInfo.front,h=l-1-e.padInfo.top,d=u-1-e.padInfo.left,c=o*l*u-1;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${h}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${o};
           wD += ${a}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${s}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${c} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function sse(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:p}=r,h=[1,1,1],d=T.computePool3DInfo(i.shape,o,l,h,u,p),c=new c1(d,"max",!0),m=n.runWebGLProgram(c,[i],i.dtype),f=new ase(d),g=n.runWebGLProgram(f,[a,m],i.dtype);return n.disposeIntermediateTensorInfo(m),g}var ise={kernelName:td,backendName:"webgl",kernelFunc:sse};function ose(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;zu([s,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:p,dimRoundingMode:h}=r,d=T.computePool2DInfo(o.shape,l,u,1,p,h),c=!0,m=new Pp(d,"max",c),f=n.runWebGLProgram(m,[o],o.dtype),g=new rse(d),y=n.runWebGLProgram(g,[a,f],o.dtype);return n.disposeIntermediateTensorInfo(f),y}var lse={kernelName:ed,backendName:"webgl",kernelFunc:ose};function use(e,t,n,r){let a=new Pp(n,"max",!1),s=r.runWebGLProgram(a,[e],"float32");a=new Pp(n,"max",!0,!0,t);let i=r.runWebGLProgram(a,[e],"float32");return[s,i]}var pse={kernelName:nd,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:a,strides:s,pad:i,includeBatchInIndex:o}=t,l=n;w.assert(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let u=[1,1];w.assert(T.eitherStridesOrDilationsAreOne(s,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`);let p=T.computePool2DInfo(r.shape,a,s,u,i),[h,d]=use(r,o,p,l);return[h,d]}};function dse(e,t,n,r){let a=w.sizeFromShape(t),s=w.sizeFromShape(e.shape)/a,i=pe({inputs:{x:e},attrs:{shape:[s,a]},backend:r}),o=Oo(i,"float32","mean",r),l=pe({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),l}var hse={kernelName:qi,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{keepDims:a,axis:s}=t,i=n,o=r.shape.length,l=w.parseAxisParam(s,r.shape),u=l,p=T.getAxesPermutation(u,o),h=p!=null,d=i.shouldExecuteOnCPU([r]),c=[],m=r;if(h){if(d){let x=i.texData.get(m.dataId).values,v=new Array(o);for(let C=0;C<v.length;C++)v[C]=r.shape[p[C]];let I=u1(x,r.shape,r.dtype,p,v);m=i.makeTensorInfo(v,r.dtype);let N=i.texData.get(m.dataId);N.values=I}else m=Jm(r,p,i);c.push(m),u=T.getInnerMostAxes(u.length,o)}T.assertAxesAreInnerMostDims("sum",u,o);let[f,g]=T.computeOutAndReduceShapes(m.shape,u),y=f;a&&(y=T.expandShapeToKeepDim(f,l));let b=dse(m,g,y,i);for(let x of c)i.disposeIntermediateTensorInfo(x);return b}};function cse(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=w.parseAxisParam(s,a.shape),u=l,p=T.getAxesPermutation(u,o),h=a;p!=null&&(h=xn({inputs:{x:a},backend:n,attrs:{perm:p}}),u=T.getInnerMostAxes(u.length,a.shape.length)),T.assertAxesAreInnerMostDims("min",u,o);let[d,c]=T.computeOutAndReduceShapes(h.shape,u),m=w.sizeFromShape(c),f=pe({inputs:{x:h},backend:n,attrs:{shape:[-1,m]}}),g=Oo(f,f.dtype,"min",n),y;if(i){let b=T.expandShapeToKeepDim(d,l);y=pe({inputs:{x:g},backend:n,attrs:{shape:b}})}else y=pe({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),p!=null&&n.disposeIntermediateTensorInfo(h),y}var mse={kernelName:Ki,backendName:"webgl",kernelFunc:cse},fse=d1+`
  return min(a, b);
`,gse=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Mo+`
  return result;
`,yse=on({opSnippet:fse,packedOpSnippet:gse,cpuKernelImpl:eQ}),bse={kernelName:Xi,backendName:"webgl",kernelFunc:yse},xse=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((u,p)=>u[0]+e[p]+u[1]);let r=e.length,a=ut(r),s=t.map(u=>u[0]).join(","),i=t.map((u,p)=>u[0]+e[p]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l=n==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${s};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${s});
      ${a} end = ${a}(${i});

      void main() {
        ${a} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${a} coords = outC - start;
        setOutput(getX(${o}));
      }
    `}},vse=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((c,m)=>c[0]+e[m]+c[1]);let r=e.length,a=ut(r),s=t.map(c=>c[0]).join(","),i=t.map((c,m)=>c[0]+e[m]).join(","),o=gn("rc",r),l=gn("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,p=r===1?"source":`vec2(${l.slice(-2).join()})`,h=n==="reflect"?0:1,d="";if(r===1){let c=`
        ${a} source = rc;
        if (source < start) {
          source = start * 2 - source - ${h};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${h};
        }
        source -= start;
      `;d=`
        ${a} rc = outputLoc;
        ${c}
        result[0] = getChannel(getX(${l.join()}), ${p});
        ${o[r-1]} += 1;
        if(${u}) {
          ${c}
          result[1] = getChannel(getX(${l.join()}), ${p});
        }
      `}else{let c=`
        ${a} source = rc;
        ${a} lt = ${a}(lessThan(source, start));
        ${a} gte = ${a}(greaterThanEqual(source, end));
        ${a} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${h}) +
                gte * ((end - 1) * 2 - source + ${h});
        source -= start;
      `;d=`
        ${a} rc = outputLoc;
        ${c}
        result[0] = getChannel(getX(${l.join()}), ${p});
        ${o[r-1]} += 1;
        if(${u}) {
          ${c}
          result[1] = getChannel(getX(${l.join()}), ${p});
        }
        rc = outputLoc;
        ${o[r-2]} += 1;
        if(${o[r-2]} < ${this.outputShape[r-2]}) {
          ${c}
          result[2] = getChannel(getX(${l.join()}), ${p});
          ${o[r-1]} += 1;
          if(${u}) {
            ${c}
            result[3] = getChannel(getX(${l.join()}), ${p});
          }
        }
      `}this.userCode=`
      const ${a} start = ${a}(${s});
      const ${a} end = ${a}(${i});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}},wse=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{paddings:a,mode:s}=n,i=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new vse(r.shape,a,s):new xse(r.shape,a,s);return t.runWebGLProgram(i,[r],r.dtype)},kse={kernelName:Zi,backendName:"webgl",kernelFunc:wse},Ise=`if (b == 0.0) return NAN;
  return mod(a, b);`,Sse=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Mo+`
  return result;
`,Nse=on({opSnippet:Ise,packedOpSnippet:Sse}),Tse={kernelName:Ji,backendName:"webgl",kernelFunc:Nse},Cse=class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}},_se=`
if (a == b) {
  return 1.0;
};
return a / b;`,Ese=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,k$=on({opSnippet:_se,packedOpSnippet:Ese,checkOutOfBounds:!0}),$se={kernelName:Ci,backendName:"webgl",kernelFunc:k$},VI="return a - b;",I$=on({opSnippet:VI,packedOpSnippet:VI,supportsComplex:!0,cpuKernelImpl:wQ}),Ase={kernelName:Io,backendName:"webgl",kernelFunc:I$};function S$(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=w.parseAxisParam([s],a.shape),o=w$({inputs:{x:a},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=T.expandShapeToKeepDim(o.shape,i),u=pe({inputs:{x:o},backend:n,attrs:{shape:l}}),p=I$({inputs:{a,b:u},backend:n}),h=b$({inputs:{x:p},backend:n}),d=Ym({inputs:{x:h},backend:n,attrs:{axis:i,keepDims:!1}}),c=pe({inputs:{x:d},backend:n,attrs:{shape:l}}),m=k$({inputs:{a:h,b:c},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),m}var Fse={kernelName:wo,backendName:"webgl",kernelFunc:S$};function Rse(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r,l=o?a:S$({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),u=l.shape[0],p=l.shape[1],h=new Cse(u,p,s),d=[[i]],c=n.runWebGLProgram(h,[l],"int32",d);return o||n.disposeIntermediateTensorInfo(l),c}var Dse={kernelName:eu,backendName:"webgl",kernelFunc:Rse},Mse=xr+`
  return -x;
`,Ose=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Lse(e){let{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){let s=n.texData.get(r.dataId),[i,o]=nQ(s.values,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,i)}let a;return G().getBool("WEBGL_PACK_UNARY_OPERATIONS")?a=new Pa(r.shape,Ose):a=new Vr(r.shape,Mse),n.runWebGLProgram(a,[r],r.dtype)}var zse={kernelName:tu,backendName:"webgl",kernelFunc:Lse},Pse=Qr.nonMaxSuppressionV3Impl;function Bse(e){T.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(a.dataId),p=n.readSync(s.dataId),{selectedIndices:h}=Pse(u,p,i,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}var Wse={kernelName:ru,backendName:"webgl",kernelFunc:Bse},Vse=Qr.nonMaxSuppressionV4Impl;function Use(e){T.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,p=n.readSync(a.dataId),h=n.readSync(s.dataId),{selectedIndices:d,validOutputs:c}=Vse(p,h,i,o,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([c]))]}var Gse={kernelName:au,backendName:"webgl",kernelFunc:Use},Hse=Qr.nonMaxSuppressionV5Impl;function jse(e){T.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,p=n.readSync(a.dataId),h=n.readSync(s.dataId),d=i,c=o,m=l,f=u,{selectedIndices:g,selectedScores:y}=Hse(p,h,d,c,m,f);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var qse={kernelName:su,backendName:"webgl",kernelFunc:jse},Kse=class{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${n}),
                      float(index == coords.y)));
      }
    `}},Xse=e=>{let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r,u=w.sizeFromShape(a.shape),p=new Kse(u,i,o,l),h=pe({inputs:{x:a},backend:n,attrs:{shape:[u]}}),d=n.runWebGLProgram(p,[h],s);n.disposeIntermediateTensorInfo(h);let c=[...a.shape,i],m=pe({inputs:{x:d},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(d),m},Zse={kernelName:Qi,backendName:"webgl",kernelFunc:Xse};function Sc(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="complex64"){let a=Hd({inputs:{input:r},backend:n}),s=Sc({inputs:{x:a},backend:n}),i=Qm({inputs:{input:r},backend:n}),o=Sc({inputs:{x:i},backend:n}),l=gs({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return jd({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}var Jse={kernelName:Su,backendName:"webgl",kernelFunc:Sc};function N$(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){let a=Hd({inputs:{input:r},backend:n}),s=N$({inputs:{x:a},backend:n}),i=Qm({inputs:{input:r},backend:n}),o=Sc({inputs:{x:i},backend:n}),l=gs({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return jd({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}var Yse={kernelName:iu,backendName:"webgl",kernelFunc:N$};function Qse(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(t.length===1)return ux({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach(p=>{w.assertShapesMatch(s,p.shape,"All tensors passed to stack must have matching shapes"),w.assert(i===p.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(p=>{let h=ux({inputs:{input:p},backend:n,attrs:{dim:a}});return o.push(h),h}),u=p$({inputs:l,backend:n,attrs:{axis:a}});return o.forEach(p=>n.disposeIntermediateTensorInfo(p)),u}var eie={kernelName:ou,backendName:"webgl",kernelFunc:Qse},tie=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((l,u)=>l[0]+e[u]+l[1]);let r=e.length,a=ut(r),s=t.map(l=>l[0]).join(","),i=t.map((l,u)=>l[0]+e[u]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${s};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${s});
      ${a} end = ${a}(${i});

      void main() {
        ${a} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${a} coords = outC - start;
          setOutput(getX(${o}));
        }
      }
    `}},nie=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((m,f)=>m[0]+e[f]+m[1]);let r=e.length,a=ut(r),s=t.map(m=>m[0]).join(","),i=t.map((m,f)=>m[0]+e[f]).join(","),o=gn("rc",r),l=gn("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,p=r===1?"source":`vec2(${l.slice(-2).join()})`,h=[`${a} rc = outputLoc;`,`${o[r-1]} += 1;
       if(${u}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${o[r-2]} += 1;
       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${o[r-1]} += 1;
         if(${u}) {`],d=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",c="";for(let m=0,f=r===1?2:4;m<f;m++)c+=`
        ${h[m]}
        if (${d}) {
          result[${m}] = float(value);
        } else {
          ${a} source = rc - start;
          result[${m}] = getChannel(getX(${l.join()}), ${p});
        }
      `;c+=r===1?"} ":"}}",this.userCode=`
      const ${a} start = ${a}(${s});
      const ${a} end = ${a}(${i});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${c}
        setOutput(result);
      }
    `}},T$=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;if(w.sizeFromShape(a.shape)===0){let u=s.map((p,h)=>p[0]+a.shape[h]+p[1]);return jd({backend:n,attrs:{shape:u,value:i,dtype:a.dtype}})}let o=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new nie(a.shape,s,i):new tie(a.shape,s,i),l=[[i]];return n.runWebGLProgram(o,[a],a.dtype,l)},rie={kernelName:eo,backendName:"webgl",kernelFunc:T$},aie=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,sie=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Mo+`
  return result;
`,iie=on({opSnippet:aie,packedOpSnippet:sie}),oie={kernelName:to,backendName:"webgl",kernelFunc:iie};function lie(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=[],u=w.parseAxisParam(s,a.shape),p=u,h=T.getAxesPermutation(p,o),d=a;h!=null&&(d=xn({inputs:{x:a},backend:n,attrs:{perm:h}}),p=T.getInnerMostAxes(p.length,o),l.push(d)),T.assertAxesAreInnerMostDims("prod",p,o);let c;if(n.shouldExecuteOnCPU([d])){let m=n.texData.get(d.dataId).values,{outVals:f,outShape:g,outDtype:y}=aQ(d.shape,d.dtype,m,p);c=n.makeTensorInfo(g,y,f)}else{let[m,f]=T.computeOutAndReduceShapes(d.shape,p),g=w.sizeFromShape(f),y=pe({inputs:{x:d},backend:n,attrs:{shape:[-1,g]}}),b=Hc(a.dtype),x=Oo(y,b,"prod",n);c=pe({inputs:{x},backend:n,attrs:{shape:m}}),l.push(y),l.push(x)}if(i){l.push(c);let m=T.expandShapeToKeepDim(c.shape,u);c=pe({inputs:{x:c},backend:n,attrs:{shape:m}})}return l.forEach(m=>n.disposeIntermediateTensorInfo(m)),c}var uie={kernelName:ro,backendName:"webgl",kernelFunc:lie};function pie(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=r,l=a.map(y=>n.readSync(y.dataId)),u=a.map(y=>y.shape),p=n.readSync(s.dataId),h=n.readSync(i.dataId),[d,c,m]=sQ(l,u,p,s.shape,s.dtype,h,i.shape,o),f=d.map(y=>n.makeTensorInfo([y.length],"int32",y)),g=n.makeTensorInfo(m,s.dtype,c);return f.concat([g])}var die={kernelName:Bc,backendName:"webgl",kernelFunc:pie};function hie(e){let{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,p]=iQ(i,r.shape,r.dtype,o,a.shape,l,s.shape),h=n.makeTensorInfo([u.length],"int32",u),d=n.makeTensorInfo([p.length],r.dtype,p);return[h,d]}var cie={kernelName:Wc,backendName:"webgl",kernelFunc:hie};function mie(e){let{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.readSync(a.dataId),p=n.readSync(s.dataId),h=n.readSync(i.dataId),d=o.map(g=>n.readSync(g.dataId)),c=o.map(g=>g.shape),[m,f]=oQ(u,a.shape,p,s.shape,s.dtype,h,i.shape,d,c,l);return n.makeTensorInfo(m,s.dtype,f)}var fie={kernelName:Vc,backendName:"webgl",kernelFunc:mie},C$=e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:i}=n,o=lQ(r,a,s,i);return t.makeTensorInfo([o.length],i,o)},gie={kernelName:rd,backendName:"webgl",kernelFunc:C$},yie="return 1.0 / x;",bie=qe({opSnippet:yie}),xie={kernelName:ao,backendName:"webgl",kernelFunc:bie},vie=xr+`
  return (x < 0.0) ? 0.0 : x;
`,wie=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,kie=qe({opSnippet:vie,packedOpSnippet:wie}),Iie={kernelName:so,backendName:"webgl",kernelFunc:kie},Sie=xr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Nie=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Tie=qe({opSnippet:Sie,packedOpSnippet:Nie}),Cie={kernelName:lo,backendName:"webgl",kernelFunc:Tie},_ie=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u=[r&&t>1?i-1:i,r&&n>1?o-1:o],p=[r&&t>1?t-1:t,r&&n>1?n-1:n],h;a?h="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":h="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/p[0]},
          ${u[1]/p[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${h};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}},Eie=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u=[r&&t>1?i-1:i,r&&n>1?o-1:o],p=[r&&t>1?t-1:t,r&&n>1?n-1:n],h;a?h="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":h="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/p[0]},
          ${u[1]/p[1]},
          ${u[1]/p[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${h};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function $ie(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,p=G().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Eie(a.shape,l,u,s,i):new _ie(a.shape,l,u,s,i);return n.runWebGLProgram(p,[a],"float32")}var Aie={kernelName:oo,backendName:"webgl",kernelFunc:$ie},Fie=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],p=o[1]/l[1],h=1/u,d=1/p,c=Math.ceil(h)*2+2,m=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${p});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${d});

        const int winHeight = int(${c});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Rie(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new Fie(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}var Die={kernelName:pu,backendName:"webgl",kernelFunc:Rie},Mie=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u=[r&&t>1?i-1:i,r&&n>1?o-1:o],p=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=r?"0.5":"0.0",d;a?d="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/p[0]},
          ${u[1]/p[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}},Oie=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u=[r&&t>1?i-1:i,r&&n>1?o-1:o],p=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=r?"0.5":"0.0",d;a?d="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/p[0]},
          ${u[1]/p[1]},
          ${u[1]/p[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function Lie(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,p=G().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Oie(a.shape,l,u,s,i):new Mie(a.shape,l,u,s,i);return n.runWebGLProgram(p,[a],a.dtype)}var zie={kernelName:io,backendName:"webgl",kernelFunc:Lie},Pie=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],p=o[1]/l[1],h=1/u,d=1/p,c=Math.ceil(h)*2+2,m=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${p});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${d});

        const int winHeight = int(${c});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${o[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${o[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${a}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Bie(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new Pie(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}var Wie={kernelName:uu,backendName:"webgl",kernelFunc:Bie},Vie=class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}let r=i=>t.indexOf(i)!==-1&&e[i]!==1?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`,a=e.map((i,o)=>r(o)).join(","),s=ut(n);this.userCode=`
      void main() {
        ${s} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}},Uie=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let r=gn("rc",n),a=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=ut(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${a}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${o(r.slice())};
          if(${a}){
            result.g = ${l(r.slice())};
          }
          if(${s}) {
            result.b = ${u(r.slice())};
            if(${a}) {
              result.a = ${p(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function o(c){return h(c)}function l(c){return c[n-1]="("+c[n-1]+" + 1)",h(c)}function u(c){return c[n-2]="("+c[n-2]+" + 1)",h(c)}function p(c){return c[n-1]="("+c[n-1]+" + 1)",c[n-2]="("+c[n-2]+" + 1)",h(c)}function h(c){let m=e.map((y,b)=>d(b,c)),f=m.join(","),g=m.slice(-2).join(",");return`getChannel(getX(${f}), vec2(${g}))`}function d(c,m){return t.indexOf(c)!==-1&&e[c]!==1?`${e[c]} - ${m[c]} - 1`:`${m[c]}`}}};function Gie(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,i=a.shape.length,o=w.parseAxisParam(s,a.shape);if(i===0)return qn({inputs:{x:a},backend:n});let l=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Uie(a.shape,o):new Vie(a.shape,o);return n.runWebGLProgram(l,[a],a.dtype)}var Hie={kernelName:uo,backendName:"webgl",kernelFunc:Gie},jie=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],r=e[2];this.outputShape=e;let a="";typeof t=="number"?a=`float outputValue = ${t.toFixed(2)};`:a=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${a}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}},qie={kernelName:Nu,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:a,fillValue:s,center:i}=t,o=n,l=new jie(r.shape,s),[u,p]=T.getImageCenter(i,r.shape[1],r.shape[2]),h=[[u,p,Math.sin(a),Math.cos(a)]];return o.runWebGLProgram(l,[r],r.dtype,h)}},Kie=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,Xie=qe({opSnippet:Kie}),Zie={kernelName:po,backendName:"webgl",kernelFunc:Xie},Jie="return inversesqrt(x);",Yie=qe({opSnippet:Jie,cpuKernelImpl:uQ}),Qie={kernelName:ho,backendName:"webgl",kernelFunc:Yie},m1=class{constructor(e,t,n,r,a,s,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;let l=ut(a.length),u=ut(s.length),p="";n===1?p="i":n===2&&(p="i, j");let h=`getIndices(${p})`,d="";r===1?d="i":r===2&&(d="i, coords[1]");let c=`getUpdates(${d})`,m="";o&&(m="coords[0], coords[1]");let f=`getDefaultValue(${m})`,g=t>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${a});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${h});
              flattenedIndex += index * ${g};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${c};
              found = true;
            }
          }
          setOutput(mix(${f}, sum, float(found)));
        }
      `}},eoe=class{constructor(e,t,n,r,a,s,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;let l=ut(a.length),u=ut(s.length),p="";n===1?p="i":n===2&&(p="i, j");let h=`getIndices(${p})`,d="";r===1?d="i":r===2&&(d="i, coords[1]");let c=`getUpdates(${d})`,m="";o&&(m="coords[0], coords[1]");let f=`getDefaultValue(${m})`,g=t>1?"strides[j]":"strides",y=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${l} strides = ${l}(${a});

        void main() {
          ${u} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${h});
              flattenedIndex += index.xz * ${g};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${y};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${c};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${f}, sum, found));
        }
      `}};function toe(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:p,outputSize:h}=T.calculateShapes(s,a,i),d=[h/u,u];if(h===0)return n.makeTensorInfo(i,a.dtype);let c=pe({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),m=pe({inputs:{x:s},backend:n,attrs:{shape:[l,u]}}),f=n.makeTensorInfo([],"float32",new Float32Array([0])),g;G().getBool("WEBGL_PACK")?g=new eoe(l,o,c.shape.length,m.shape.length,p,d):g=new m1(l,o,c.shape.length,m.shape.length,p,d);let y=n.runWebGLProgram(g,[m,c,f],m.dtype),b=pe({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(f),b}var noe={kernelName:du,backendName:"webgl",kernelFunc:toe},roe=class{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];let a="while (left < right) {",s=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=G().getNumber("WEBGL_VERSION")===2?a:s,o=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${i}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${o} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function aoe(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=new roe(a.shape[0],a.shape[1],s.shape[1],i),l=[[a.shape[1]]];return n.runWebGLProgram(o,[a,s],"int32",l)}var soe={kernelName:cu,backendName:"webgl",kernelFunc:aoe},ioe=class{constructor(e,t,n){this.variableNames=["c","a","b"],this.outputShape=t;let r,a;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)a="resRC",r="resRC";else{let i=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],l=[];for(let u=0;u<t.length;u++)l.push(`${i[u]}`),u<e&&o.push(`${i[u]}`);r=o.join(),a=l.join()}let s=ut(n);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${a}));
        } else {
          setOutput(getB(${a}));
        }
      }
    `}};function ooe(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,i=new ioe(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(i,[r,a,s],sr(a.dtype,s.dtype))}var loe={kernelName:mu,backendName:"webgl",kernelFunc:ooe},uoe=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${T.SELU_SCALEALPHA};
  float scale = ${T.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,poe=qe({opSnippet:uoe}),doe={kernelName:co,backendName:"webgl",kernelFunc:poe},hoe=Gu+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,coe=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,moe=qe({opSnippet:hoe,packedOpSnippet:coe,cpuKernelImpl:dQ}),foe={kernelName:yo,backendName:"webgl",kernelFunc:moe},goe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,yoe=qe({opSnippet:goe}),boe={kernelName:go,backendName:"webgl",kernelFunc:yoe},xoe=Gu+`
  return sin(x);
`,voe=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Mo}
  return result;
`,woe=qe({opSnippet:xoe,packedOpSnippet:voe}),koe={kernelName:mo,backendName:"webgl",kernelFunc:woe},Ioe=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Soe=qe({opSnippet:Ioe}),Noe={kernelName:fo,backendName:"webgl",kernelFunc:Soe},Toe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,Coe=qe({opSnippet:Toe}),_oe={kernelName:bo,backendName:"webgl",kernelFunc:Coe},Eoe=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;w.assert(a.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let o=s.reduce((y,b)=>y*b),l=[[0,0]];l.push(...i);for(let y=1+s.length;y<a.shape.length;++y)l.push([0,0]);let u=[],p=T$({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),h=T.getReshaped(p.shape,s,o,!1),d=T.getPermuted(h.length,s.length,!1),c=T.getReshapedPermuted(p.shape,s,o,!1),m=pe({inputs:{x:p},backend:n,attrs:{shape:h}}),f=xn({inputs:{x:m},backend:n,attrs:{perm:d}}),g=pe({inputs:{x:f},backend:n,attrs:{shape:c}});return u.push(p),u.push(m),u.push(f),u.forEach(y=>n.disposeIntermediateTensorInfo(y)),g},$oe={kernelName:gu,backendName:"webgl",kernelFunc:Eoe};function Aoe(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(a.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${a.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=n.readSync(r.dataId),l=n.readSync(a.dataId),u=n.readSync(s.dataId),p=n.readSync(i.dataId)[0],[h,d,c,m,f]=cQ(o,r.shape,r.dtype,l,a.dtype,u,p);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],a.dtype,c),n.makeTensorInfo([m.length],"bool",new Uint8Array(m.map(g=>Number(g)))),n.makeTensorInfo([f.length],r.dtype,new Int32Array(f))]}var Foe={kernelName:ad,backendName:"webgl",kernelFunc:Aoe};function Roe(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(a.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${a.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.readSync(a.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(s.dataId)),[u,p,h]=mQ(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(p,r.dtype,u),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}var Doe={kernelName:bu,backendName:"webgl",kernelFunc:Roe};function Moe(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${a.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,p]=XE(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(p,r.dtype,u)}var Ooe={kernelName:sd,backendName:"webgl",kernelFunc:Moe};function Loe(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${a.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,p]=XE(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(p,r.dtype,u)}var zoe={kernelName:id,backendName:"webgl",kernelFunc:Loe};function Poe(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:p,strides:h,outputSize:d}=T.calculateShapes(s,a,o),c=!1;if(s.dtype==="string"){let y=n.bufferSync(a),b=n.bufferSync(s),x=w.decodeString(n.readSync(i.dataId)[0]),v=pQ(y,b,o,d,p,u,l,h,x,c);return n.makeTensorInfo(o,v.dtype,v.values)}let m=new m1(u,l,a.shape.length,s.shape.length,h,[d,1],c),f=n.runWebGLProgram(m,[s,a,i],s.dtype),g=pe({inputs:{x:f},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(f),g}var Boe={kernelName:xu,backendName:"webgl",kernelFunc:Poe};function Woe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=w.parseAxisParam(i,a.shape)[0],l=T.prepareSplitSize(a,s,o),u=a.shape.length,p=new Array(u).fill(0),h=a.shape.slice();return l.map(d=>{let c=[...h];c[o]=d;let m=Hu({inputs:{x:a},backend:n,attrs:{begin:p,size:c}});return p[o]+=d,m})}var Voe={kernelName:yu,backendName:"webgl",kernelFunc:Woe},UI="return sqrt(x);",Uoe=qe({opSnippet:UI,packedOpSnippet:UI,cpuKernelImpl:fQ}),Goe={kernelName:xo,backendName:"webgl",kernelFunc:Uoe},Hoe="return x * x;",joe=qe({opSnippet:Hoe}),qoe={kernelName:od,backendName:"webgl",kernelFunc:joe},GI="return (a - b) * (a - b);",Koe=on({opSnippet:GI,packedOpSnippet:GI}),Xoe={kernelName:ko,backendName:"webgl",kernelFunc:Koe};function Zoe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");let s=n.readSync(a.dataId),i=T.fromUint8ToStringArray(s),o=gQ(i,"string",r);return n.makeTensorInfo(a.shape,"string",o)}var Joe={kernelName:ld,backendName:"webgl",kernelFunc:Zoe};function Yoe({inputs:e,attrs:t,backend:n}){let{x:r}=e,a=xr+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,s=new Vr(r.shape,a);return n.runWebGLProgram(s,[r],r.dtype)}var Qoe={kernelName:us,backendName:"webgl",kernelFunc:Yoe},ele=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;let r=n.length,a=ut(n.length),s=ut(n.length),i="";if(r===1)i="coords * strides + begin";else{let o=0;i=n.map((l,u)=>(o++,n.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${o-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`
      ${a} begin = ${a}(${e});
      ${a} strides = ${a}(${t});

      void main() {
        ${s} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}};function tle(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:p,newAxisMask:h,shrinkAxisMask:d}=r,{finalShapeSparse:c,finalShape:m,isIdentity:f,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:v}=Bt.sliceInfo(a.shape,s,i,o,l,u,p,h,d),I;if(f)I=pe({inputs:{x:a},backend:n,attrs:{shape:m}});else if(g||y){w.assert(a.shape.length>=1,()=>`Input must have rank at least 1, got: ${a.shape.length}`);let C=Bt.computeOutShape(b,x,v),E=Hu({inputs:{x:a},backend:n,attrs:{begin:b,size:C}});I=pe({inputs:{x:E},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(E)}else if(n.shouldExecuteOnCPU([a])){let C=n.readSync(a.dataId),E=Oe(a.shape,a.dtype,C),A=yQ(c,E,v,b);I=n.makeTensorInfo(m,a.dtype,A.values)}else{let C=new ele(b,v,c);I=n.runWebGLProgram(C,[a],a.dtype)}let N=pe({inputs:{x:I},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(I),N}var nle={kernelName:vu,backendName:"webgl",kernelFunc:tle};function rle(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:p,dataSplits:h}=t,d=n.readSync(p.dataId),c=n.readSync(h.dataId),[m,f]=bQ(d,c,a,s,i,o,l,u);return[n.makeTensorInfo([m.length],"string",m),n.makeTensorInfo(h.shape,"int32",f)]}var ale={kernelName:ud,backendName:"webgl",kernelFunc:rle};function sle(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.readSync(s.dataId),l=n.readSync(i.dataId)[0],[u,p,h]=xQ(o,l,a),d=p.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",p),n.makeTensorInfo([2],"int32",new Int32Array(h))]}var ile={kernelName:pd,backendName:"webgl",kernelFunc:sle};function ole(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let i=n.readSync(s.dataId),o=vQ(i,a);return n.makeTensorInfo(s.shape,"int32",o)}var lle={kernelName:dd,backendName:"webgl",kernelFunc:ole},ule="return tan(x);",ple=qe({opSnippet:ule}),dle={kernelName:So,backendName:"webgl",kernelFunc:ple},hle=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,cle=qe({opSnippet:hle}),mle={kernelName:No,backendName:"webgl",kernelFunc:cle};function fle(e){let{inputs:t,backend:n,attrs:r}=e,{tensor:a,indices:s,updates:i}=t,{}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:p,outputSize:h}=T.calculateShapes(i,s,a.shape),d=[h/u,u];if(h===0)return n.makeTensorInfo(a.shape,s.dtype);let c=pe({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),m=pe({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),f=pe({inputs:{x:a},backend:n,attrs:{shape:d}}),g=new m1(l,o,c.shape.length,m.shape.length,p,d,!1,!0),y=n.runWebGLProgram(g,[m,c,f],f.dtype),b=pe({inputs:{x:y},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),b}var gle={kernelName:hu,backendName:"webgl",kernelFunc:fle},yle=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[s]*t[s];this.outputShape=n,this.rank=n.length;let r=ut(this.rank),a=ble(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${a}));
      }
    `}};function ble(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${e[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let a=0;a<e.length;a++)r.push(`imod(${n[a]}, ${e[a]})`);return r.join()}function _$(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;if(a.dtype==="string"||a.shape.length>5){let o=n.readSync(a.dataId),l=a.dtype==="string"?o.map(h=>w.decodeString(h)):o,u=Oe(a.shape,a.dtype,l),p=kQ(u,s);return n.makeTensorInfo(p.shape,p.dtype,p.values)}let i=new yle(a.shape,s);return n.runWebGLProgram(i,[a],a.dtype)}var xle={kernelName:ls,backendName:"webgl",kernelFunc:_$},vle=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},wle=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function Ts(e,t){t!==null&&e.disposeIntermediateTensorInfo(t)}function HI(e){let t=1;for(;t<e;)t*=2;return t}function kle(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r,o=G().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=G().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=a.shape,p=u[u.length-1];if(n.shouldExecuteOnCPU([a])||p<o||s>l){let A=n.readSync(a.dataId),[R,F]=IQ(A,u,a.dtype,s,i);return[n.makeTensorInfo(R.shape,R.dtype,R.values),n.makeTensorInfo(F.shape,F.dtype,F.values)]}if(s===0)return u[u.length-1]=0,[n.makeTensorInfo(u,a.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(p===1)return[a,jd({attrs:{shape:u,dtype:"int32",value:0},backend:n})];let h=n.texData.get(a.dataId),d=h!==null&&h.isPacked,c=d?n.unpackTensor(a):a,m=w.sizeFromShape(u)/p,f=pe({inputs:{x:c},attrs:{shape:[m,p]},backend:n});d&&Ts(n,c);let g=HI(s),y=HI(p),b=null,x=()=>b===null?[f,f]:[f,b],v=(A,R,F)=>{let S=x(),M=new vle(F),W=[[p],[b===null?1:0],[Number.NEGATIVE_INFINITY],[A],[R]],U=b;b=n.runWebGLProgram(M,S,"int32",W),Ts(n,U)};for(let A=1;A<g;A*=2){let R=A*2;for(let F=A;F>=1;F/=2)v(R,F,[m,y])}for(let A=y;A>g;A/=2){let R=x(),F=new wle([m,A/2]),S=[[p],[b===null?1:0],[g]],M=b;b=n.runWebGLProgram(F,R,"int32",S),Ts(n,M);let W=g/2,U=W*2;for(let H=W;H>=1;H/=2)v(U,H,b.shape)}let I=b;b=Hu({inputs:{x:b},backend:n,attrs:{begin:0,size:[m,s]}}),Ts(n,I);let N=v$({inputs:{x:f,indices:b},backend:n,attrs:{axis:1,batchDims:1}});Ts(n,f);let C=u.slice(0,-1);C.push(s),I=b,b=pe({inputs:{x:b},attrs:{shape:C},backend:n}),Ts(n,I);let E=N;return N=pe({inputs:{x:N},attrs:{shape:C},backend:n}),Ts(n,E),[N,b]}var Ile={kernelName:wu,backendName:"webgl",kernelFunc:kle},Sle=class{constructor(e,t,n,r,a,s){this.variableNames=["Image","Transforms"],this.outputShape=s;let i=n==="nearest"?1:2,o;switch(r){case"constant":o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4;break;default:o=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${o} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${a});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${a});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function Nle(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[p,h,d,c]=a.shape,[m,f]=u!=null?u:[h,d],g=[p,m,f,c],y=new Sle(h,d,i,o,l,g);return n.runWebGLProgram(y,[a,s],"float32")}var Tle={kernelName:ku,backendName:"webgl",kernelFunc:Nle};function Cle(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;zu(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=r.readSync(s.dataId),{outputValues:o,outputShape:l,indices:u}=SQ(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}var _le={kernelName:hd,backendName:"webgl",kernelFunc:Cle};function Ele(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a,o=i.shape.length,l=a.shape[s],u=new Array(o-1),p=0;for(let f=0;f<o;f++)f!==s&&(u[p++]=i.shape[f]);let h=[],d=new Array(o).fill(0),c=i.shape.slice();c[s]=1;let m=new Array(l);for(let f=0;f<m.length;f++){d[s]=f;let g=Hu({inputs:{x:i},backend:n,attrs:{begin:d,size:c}}),y=pe({inputs:{x:g},backend:n,attrs:{shape:u}});m[f]=y,h.push(g)}return h.forEach(f=>n.disposeIntermediateTensorInfo(f)),m}var $le={kernelName:Iu,backendName:"webgl",kernelFunc:Ele},Ale=class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,r=e.batchSize,a=e.inSize,s=e.numSegments,i=s*Math.ceil(a/n);this.outputShape=[r,i];let o="0.0",l="sumValue",u=Math.floor(n/4)*4,p=n%4,h=`
        sumValue += dot(values, segFilter);
    `,d="";a%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `);let c="";a%n>0&&(c=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${o};

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${c}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${s})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${s})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${h}
        }

        int inIdx = inOffset + ${u};
        if (${p===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${h}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${h}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${h}
        }
        setOutput(${l});
      }
    `}};function Fle(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r,o=a.shape.length,l=[],u=0,p=T.getAxesPermutation([u],o),h=a;p!=null&&(h=xn({inputs:{x:a},backend:n,attrs:{perm:p}}),l.push(h),u=T.getInnerMostAxes(1,o)[0]);let d=T.segment_util.computeOutShape(h.shape,u,i),c=w.sizeFromShape([h.shape[u]]),m=pe({inputs:{x:h},backend:n,attrs:{shape:[-1,c]}});l.push(m);let f=Hc(a.dtype),g=(v,I,N,C,E)=>{let A=v.shape[0],R=v.shape[1],F=T.segment_util.segOpComputeOptimalWindowSize(R,E),S={windowSize:F,inSize:R,batchSize:A,numSegments:E},M=new Ale(S,I),W=n.compileAndRun(M,[v,N],C);if(l.push(W),W.shape[1]===E)return W;let U=C$({backend:n,attrs:{start:0,stop:E,step:1,dtype:"float32"}}),H=_$({inputs:{x:U},backend:n,attrs:{reps:[R/F]}});return l.push(U),l.push(H),g(W,I,H,C,E)},y=g(m,"unsortedSegmentSum",s,f,i),b=pe({inputs:{x:y},backend:n,attrs:{shape:d}}),x=b;if(p!=null){l.push(b);let v=T.getUndoAxesPermutation(p);x=xn({inputs:{x},backend:n,attrs:{perm:v}})}return l.forEach(v=>n.disposeIntermediateTensorInfo(v)),x}var Rle={kernelName:cd,backendName:"webgl",kernelFunc:Fle},Dle=[yee,xee,kee,Nee,Cee,$ee,Fee,Dee,zee,Bee,Uee,jee,Xee,Qee,nte,ate,ite,pte,hte,mte,bte,Nte,Cte,Ate,Rte,Pte,Wte,Hte,eee,Kte,Qte,rne,une,hne,mne,gne,bne,kne,Nne,_ne,$ne,Fne,Dne,Lne,Pne,Une,Hne,Kne,Jne,Qne,rre,ore,dre,mre,yre,bre,vre,kre,Sre,Tre,_re,Fre,Mre,zre,Bre,Ure,jre,Zre,eae,QQ,nae,Jte,sae,lae,dae,nee,fae,xae,wae,Nae,_ae,Fae,Mae,Pae,Uae,jae,Kae,Yae,ese,nse,ise,lse,pse,hse,mse,bse,kse,Tse,Dse,see,zse,Wse,Gse,qse,Mte,Zse,Yse,eie,rie,oie,aee,uie,die,cie,fie,gie,Ote,$se,xie,Iie,Cie,oee,Aie,Die,zie,Wie,Hie,qie,Zie,Qie,noe,soe,loe,doe,foe,boe,koe,Noe,Ite,Fse,_oe,$oe,Foe,Doe,Ooe,zoe,Boe,Voe,Goe,qoe,Xoe,Joe,Qoe,nle,ale,ile,lle,Ase,mee,dle,mle,gle,xle,Ile,Tle,fee,_le,$le,Rle,Jse];for(let e of Dle)md(e);var Xe;(function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"})(Xe||(Xe={}));var Wp;(function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"})(Wp||(Wp={}));var E$;function Mle(e){E$=e.wasm.cwrap(Bs,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function Ole(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s,bias:i,preluActivationWeights:o}=t;if(a.dtype!=="float32"||s.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:l,transposeB:u,activation:p,leakyreluAlpha:h}=r,d=n.dataIdMap.get(a.dataId).id,c=n.dataIdMap.get(s.dataId).id,m=0;if(i!=null){let E=n.dataIdMap.get(i.dataId);if(E.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${E.shape.length}.`);m=E.id}let f=o==null?0:n.dataIdMap.get(o.dataId).id,g=Wp[p];if(g==null)throw new Error(`${p} activation not yet supported for FusedConv2D in the wasm backend.`);let y=l?a.shape[2]:a.shape[1],b=u?s.shape[1]:s.shape[2],x=Tu.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)),v=n.makeOutput([...x,y,b],a.dtype),I=n.dataIdMap.get(v.dataId).id,N=new Uint8Array(new Int32Array(a.shape).buffer),C=new Uint8Array(new Int32Array(s.shape).buffer);return E$(d,N,a.shape.length,c,C,s.shape.length,l,u,g,m,f,h||0,I),v}var Lle={kernelName:Bs,backendName:"wasm",setupFunc:Mle,kernelFunc:Ole};function He(e,t){let n;function r(s){n=s.wasm.cwrap(e,null,["number","number","number"])}function a(s){let{backend:i,inputs:{x:o}}=s,l=i.dataIdMap.get(o.dataId).id,u=i.makeOutput(o.shape,t||o.dtype),p=i.dataIdMap.get(u.dataId).id;return w.sizeFromShape(u.shape)===0||n(l,Xe[o.dtype],p),u}return{kernelName:e,backendName:"wasm",setupFunc:r,kernelFunc:a}}var zle=He(Sl),Ple=He(oi),Ble=He(li);function Lt(e,t,n){let r;function a(i){r=i.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])}function s(i){let{backend:o,inputs:l}=i,{a:u,b:p}=l,h=o.dataIdMap.get(u.dataId).id,d=o.dataIdMap.get(p.dataId).id,c=n!=null?n:u.dtype,m=T.assertAndGetBroadcastShape(u.shape,p.shape),f=o.makeOutput(m,c);if(w.sizeFromShape(m)===0)return f;let g=new Uint8Array(new Int32Array(u.shape).buffer),y=new Uint8Array(new Int32Array(p.shape).buffer),b=o.dataIdMap.get(f.dataId).id;return r(h,g,u.shape.length,d,y,p.shape.length,Xe[u.dtype],b),f}return{kernelName:e,backendName:"wasm",setupFunc:a,kernelFunc:s}}var Wle=!0,Vle=Lt(is,Wle),$$;function Ule(e){$$=e.wasm.cwrap(ui,null,["array","number","number","number"])}function Gle(e){let{inputs:t,backend:n}=e,r=n.makeOutput(t[0].shape,t[0].dtype);if(w.sizeFromShape(r.shape)===0)return r;let a=t.map(o=>n.dataIdMap.get(o.dataId).id),s=new Uint8Array(new Int32Array(a).buffer),i=n.dataIdMap.get(r.dataId).id;return $$(s,a.length,Xe[r.dtype],i),r}var Hle={kernelName:ui,backendName:"wasm",setupFunc:Ule,kernelFunc:Gle};function ef(e){let{inputs:{x:t},backend:n}=e;if(t.dtype==="string")return yn(n.readSync(t.dataId),t.shape,t.dtype);let r=n.makeOutput(t.shape,t.dtype),a=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(r).set(a),r}var jle={kernelName:Oi,backendName:"wasm",kernelFunc:ef},A$;function qle(e){A$=e.wasm.cwrap(ua,null,["number","array","number","number","number","array","number"])}function as(e){let{inputs:t,backend:n,attrs:r}=e,[a,s]=Xle(t.x.shape,r.perm),i=!0;for(let m=0;m<s.length;m++)s[m]!==m&&(i=!1);let o=Kle(t.x.shape,r.perm),l={dataId:t.x.dataId,shape:a,dtype:t.x.dtype};if(i){let m=ef({inputs:t,backend:n});return m.shape=o,m}let u=n.makeOutput(o,l.dtype),p=n.dataIdMap.get(l.dataId).id,h=n.dataIdMap.get(u.dataId).id,d=new Uint8Array(new Int32Array(s).buffer),c=new Uint8Array(new Int32Array(l.shape).buffer);return A$(p,c,l.shape.length,Xe[l.dtype],h,d,s.length),u}function Kle(e,t){let n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];return n}function Xle(e,t){let n=[],r=[];for(let a=0;a<e.length;++a)e[a]!==1&&n.push(e[a]),e[t[a]]!==1&&r.push(t[a]);for(let a=0;a<r.length;++a){let s=-1;for(let i=0;i<r.length;++i)r[i]>=a&&(s===-1||r[s]>r[i])&&(s=i);r[s]=a}return[n,r]}var Zle={kernelName:ua,backendName:"wasm",kernelFunc:as,setupFunc:qle};function ys(e,t,n){let r=e.shape,a=e.shape.length,s=w.parseAxisParam(t,r),i=s,o=T.getAxesPermutation(i,a),l=null,u=!1;if(o!=null){let p=new Array(a);for(let d=0;d<p.length;d++)p[d]=r[o[d]];i=T.getInnerMostAxes(i.length,a),l=as({inputs:{x:e},attrs:{perm:o},backend:n});let h=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(l.dataId).id!==h&&(u=!0)}return{transposed:l,originalAxes:s,axes:i,inputWasTransposed:u}}var F$;function Jle(e){F$=e.wasm.cwrap(Nl,null,["number, number, number"])}function Yle(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:p,originalAxes:h,inputWasTransposed:d}=ys(i,a,t);if(d){let b=t.dataIdMap.get(u.dataId).id;l=u,o=b}let c=l.shape.length;T.assertAxesAreInnerMostDims("all",p,c);let[m,f]=T.computeOutAndReduceShapes(l.shape,p),g=w.sizeFromShape(f),y=t.makeOutput(m,i.dtype);if(w.sizeFromShape(l.shape)!==0){let b=t.dataIdMap.get(y.dataId).id;F$(o,g,b)}if(d&&t.disposeData(u.dataId),s){let b=T.expandShapeToKeepDim(y.shape,h);y.shape=b}return y}var Qle={kernelName:Nl,backendName:"wasm",setupFunc:Jle,kernelFunc:Yle},R$;function eue(e){R$=e.wasm.cwrap(Tl,null,["number, number, number"])}function tue(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:p,originalAxes:h,inputWasTransposed:d}=ys(i,a,t);if(d){let b=t.dataIdMap.get(u.dataId).id;l=u,o=b}let c=l.shape.length;T.assertAxesAreInnerMostDims("any",p,c);let[m,f]=T.computeOutAndReduceShapes(l.shape,p),g=w.sizeFromShape(f),y=t.makeOutput(m,i.dtype);if(w.sizeFromShape(l.shape)!==0){let b=t.dataIdMap.get(y.dataId).id;R$(o,g,b)}if(d&&t.disposeData(u.dataId),s){let b=T.expandShapeToKeepDim(y.shape,h);y.shape=b}return y}var nue={kernelName:Tl,backendName:"wasm",setupFunc:eue,kernelFunc:tue};function D$(e){let t;function n(a){t=a.wasm.cwrap(e,null,["number","number","number","number","number"])}function r(a){let{backend:s,inputs:i,attrs:o}=a,{axis:l}=o,{x:u}=i,p=s.dataIdMap.get(u.dataId).id,h=p,d=u,{transposed:c,axes:m,inputWasTransposed:f}=ys(u,l,s);if(f){let I=s.dataIdMap.get(c.dataId).id;I!==p&&(d=c,h=I)}let g=d.shape.slice(0,-1),y=s.makeOutput(g,"int32"),b=s.dataIdMap.get(y.dataId).id,x=w.sizeFromShape(y.shape),v=d.shape[m[0]];return t(h,Xe[d.dtype],x,v,b),f&&s.disposeData(c.dataId),y}return{kernelName:e,backendName:"wasm",setupFunc:n,kernelFunc:r}}var rue=D$(Cl),aue=D$(_l),sue=He(pi),iue=He(di),oue=He(hi),lue=Lt(mi,!1),uue=He(ci),M$;function pue(e){M$=e.wasm.cwrap(fi,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function due(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,s=r.dataIdMap.get(a.dataId).id,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,p=T.computePool2DInfo(a.shape,i,o,1,l,u),h=p.filterHeight,d=p.filterWidth,c=p.padInfo.top,m=p.padInfo.right,f=p.padInfo.bottom,g=p.padInfo.left,y=p.strideHeight,b=p.strideWidth,x=p.inChannels;if(p.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);if(p.dilationWidth!==1||p.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${p.dilationHeight}, ${p.dilationWidth}].`);let v=r.makeOutput(p.outShape,"float32"),I=r.dataIdMap.get(v.dataId).id;return M$(s,a.shape[0],a.shape[1],a.shape[2],h,d,c,m,f,g,y,b,x,I),v}var hue={kernelName:fi,backendName:"wasm",setupFunc:pue,kernelFunc:due},O$;function cue(e){O$=e.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function mue(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,p=T.computePool3DInfo(a.shape,s,i,1,o,l,u),h=n.makeOutput(p.outShape,a.dtype);return O$(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(h.dataId).id,p.batchSize,p.inChannels,p.inDepth,p.inHeight,p.inWidth,p.outDepth,p.outHeight,p.outWidth,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left),h}var fue={kernelName:El,backendName:"wasm",setupFunc:cue,kernelFunc:mue},L$;function gue(e){L$=e.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function yue(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r,p=T.computePool3DInfo(s.shape,i,o,1,l,u),h=n.makeOutput(s.shape,s.dtype);return L$(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(h.dataId).id,p.batchSize,p.inChannels,p.inDepth,p.inHeight,p.inWidth,p.outDepth,p.outHeight,p.outWidth,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left,p.filterDepth,p.filterHeight,p.filterWidth),h}var bue={kernelName:Kp,backendName:"wasm",setupFunc:gue,kernelFunc:yue},z$;function xue(e){z$=e.wasm.cwrap("AvgPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function vue(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l}=r,u=T.computePool2DInfo(s.shape,i,o,1,l),p=n.makeOutput(s.shape,s.dtype);return z$(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(p.dataId).id,u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.top,u.padInfo.left,u.filterHeight,u.filterWidth),p}var wue={kernelName:qp,backendName:"wasm",setupFunc:xue,kernelFunc:vue};function An(e){let{inputs:t,attrs:n}=e,{x:r}=t,{shape:a}=n,s=w.sizeFromShape(r.shape),i=w.inferFromImplicitShape(a,s);return w.assert(s===w.sizeFromShape(i),()=>`new shape: ${i}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:i,dtype:r.dtype}}var kue={kernelName:lu,backendName:"wasm",kernelFunc:An},P$;function Iue(e){P$=e.wasm.cwrap(gi,null,["number","array","number","number","array","number","number","number","number"])}function Sue(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s}=t,{transposeA:i,transposeB:o}=r;if(a.dtype!=="float32"||s.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let l=a.shape.length,u=s.shape.length,p=i?a.shape[l-2]:a.shape[l-1],h=o?s.shape[u-1]:s.shape[u-2],d=i?a.shape[l-1]:a.shape[l-2],c=o?s.shape[u-2]:s.shape[u-1],m=a.shape.slice(0,-2),f=s.shape.slice(0,-2),g=w.sizeFromShape(m),y=w.sizeFromShape(f),b=Tu.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([d,c]);w.assert(p===h,()=>`Error in matMul: inner shapes (${p}) and (${h}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`);let x=i?[g,p,d]:[g,d,p],v=o?[y,c,h]:[y,h,c],I=An({inputs:{x:a},backend:n,attrs:{shape:x}}),N=An({inputs:{x:s},backend:n,attrs:{shape:v}}),C=n.dataIdMap.get(I.dataId).id,E=n.dataIdMap.get(N.dataId).id,A=i?I.shape[2]:I.shape[1],R=o?N.shape[1]:N.shape[2],F=Math.max(g,y),S=n.makeOutput([F,A,R],I.dtype),M=n.dataIdMap.get(S.dataId).id,W=new Uint8Array(new Int32Array(I.shape).buffer),U=new Uint8Array(new Int32Array(N.shape).buffer);return P$(C,W,I.shape.length,E,U,N.shape.length,i,o,M),n.disposeData(I.dataId),n.disposeData(N.dataId),S.shape=b,S}var Nue={kernelName:gi,backendName:"wasm",setupFunc:Iue,kernelFunc:Sue};function ai(e){let{inputs:{x:t},attrs:{begin:n,size:r},backend:a}=e,[s,i]=Bt.parseSliceParams(t,n,r),o=Bt.isSliceContinous(t.shape,s,i),l=a.readSync(t.dataId),u=a.makeOutput(i,t.dtype),p=w.computeStrides(t.shape),h=a.dataIdMap.get(u.dataId);if(o){let m=Bt.computeFlatOffset(s,p);return t.dtype==="string"?h.stringBytes=l.slice(m,m+w.sizeFromShape(i)):a.typedArrayFromHeap(u).set(l.subarray(m,m+w.sizeFromShape(i))),u}if(t.dtype==="string"){let m=bc(l,s,i,t.shape,t.dtype);return h.stringBytes=m,u}let d=a.typedArrayFromHeap(u),c=t.shape.length;if(c===2)Tue(l,p[0],d,s,i);else if(c===3)Cue(l,p[0],p[1],d,s,i);else if(c===4)_ue(l,p[0],p[1],p[2],d,s,i);else{let m=bc(l,s,i,t.shape,t.dtype);d.set(m)}return u}function Tue(e,t,n,r,a){let s=0,i=r[0],o=r[1],l=i+a[0];for(let u=i;u<l;u++){let p=u*t+o;n.set(e.subarray(p,p+a[1]),s),s+=a[1]}}function Cue(e,t,n,r,a,s){let i=0,o=a[0],l=a[1],u=a[2],p=o+s[0],h=l+s[1];for(let d=o;d<p;d++)for(let c=l;c<h;c++){let m=d*t+c*n+u;r.set(e.subarray(m,m+s[2]),i),i+=s[2]}}function _ue(e,t,n,r,a,s,i){let o=0,l=s[0],u=s[1],p=s[2],h=l+i[0],d=u+i[1],c=p+i[2],m=s[3];for(let f=l;f<h;f++)for(let g=u;g<d;g++)for(let y=p;y<c;y++){let b=f*t+g*n+y*r+m;a.set(e.subarray(b,b+i[3]),o),o+=i[3]}}var Eue={kernelName:fu,backendName:"wasm",kernelFunc:ai};function $ue(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r,o=s.reduce((y,b)=>y*b),l=T.getReshaped(a.shape,s,o),u=T.getPermuted(l.length,s.length),p=T.getReshapedPermuted(a.shape,s,o),h=T.getSliceBeginCoords(i,s.length),d=T.getSliceSize(p,i,s.length),c=An({inputs:{x:a},backend:n,attrs:{shape:l}}),m=as({inputs:{x:c},backend:n,attrs:{perm:u}}),f=An({inputs:{x:m},backend:n,attrs:{shape:p}}),g=ai({inputs:{x:f},backend:n,attrs:{begin:h,size:d}});return n.disposeData(c.dataId),n.disposeData(m.dataId),n.disposeData(f.dataId),g}var Aue={kernelName:$l,backendName:"wasm",kernelFunc:$ue},B$;function Fue(e){B$=e.wasm.cwrap(Al,null,["number","number","boolean","number","number","number"])}function Rue(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,weights:s}=n,{size:i}=r,o=s.shape.reduce((h,d)=>h*d,1)!==0,l=a.shape.length===1?[i]:[a.shape[0],i],u=t.makeOutput(l,s.dtype);function p(h){return t.dataIdMap.get(h.dataId).id}return B$(p(a),i,o,p(s),Xe[s.dtype],p(u)),u}var Due={kernelName:Al,backendName:"wasm",setupFunc:Fue,kernelFunc:Rue},Mue=!0,Oue=Lt(Fl,Mue);function Lue(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.typedArrayFromHeap(r),i=n.typedArrayFromHeap(a),o=T.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeOutput([o.length],"int32",void 0,new Int32Array(o))}var zue={kernelName:Xp,backendName:"wasm",kernelFunc:Lue};function bs(e){let{inputs:{x:t},attrs:{dtype:n},backend:r}=e,a=r.makeOutput(t.shape,n),s=r.typedArrayFromHeap(t);return r.typedArrayFromHeap(a).set(s),a}var Pue={kernelName:yi,backendName:"wasm",kernelFunc:bs},Bue=He(bi),W$;function Wue(e){W$=e.wasm.cwrap(os,null,["number","number","number","number"])}function Vue(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:s,clipValueMax:i}=r,o=n.dataIdMap.get(a.dataId).id,l=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(l.dataId).id;return W$(o,s,i,u),l}var Uue={kernelName:os,backendName:"wasm",setupFunc:Wue,kernelFunc:Vue};function V$(e){let{inputs:t,backend:n}=e,r=w.parseAxisParam(e.attrs.axis,t[0].shape)[0],a=t.map(c=>c.shape);T.assertParamsConsistent(a,r);let s=T.computeOutShape(t.map(c=>c.shape),r),i=t.filter(c=>w.sizeFromShape(c.shape)>0);if(i.length===1)return ef({inputs:{x:i[0]},backend:n});let o=n.makeOutput(s,t[0].dtype);if(w.sizeFromShape(s)===0)return o;if(i[0].dtype==="string"){let c=i.map(x=>{let v=[-1,w.sizeFromShape(x.shape.slice(r))];return An({inputs:{x},backend:n,attrs:{shape:v}})}),m=c.map(x=>({vals:n.readSync(x.dataId),shape:x.shape}));s=T.computeOutShape(c.map(x=>x.shape),1);let f=c[0].shape[0]===1,g=B0(m,s,t[0].dtype,f),y=T.computeOutShape(i.map(x=>x.shape),r);o.shape=y;let b=n.dataIdMap.get(o.dataId);return b.stringBytes=T.fromStringArrayToUint8(g),c.forEach(x=>n.disposeData(x.dataId)),o}let l=w.sizeFromShape(i[0].shape.slice(0,r)),u=0,p=i.map(c=>{let m=w.sizeFromShape(c.shape.slice(r));return u+=m,m}),h=i.map(c=>n.typedArrayFromHeap(c)),d=n.typedArrayFromHeap(o);for(let c=0;c<l;c++){let m=c*u;for(let f=0;f<h.length;f++){let g=p[f],y=c*g,b=h[f].subarray(y,y+g);d.set(b,m),m+=g}}return o}var Gue={kernelName:Rl,backendName:"wasm",kernelFunc:V$},U$;function Hue(e){U$=e.wasm.cwrap(xi,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function jue(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,i=r.dataIdMap.get(a.dataId).id,o=r.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:p,dimRoundingMode:h,dataFormat:d}=n,c=T.convertConv2DDataFormat(d),m=T.computeConv2DInfo(a.shape,s.shape,l,u,p,h,!1,c),f=m.filterHeight,g=m.filterWidth,y=m.padInfo.top,b=m.padInfo.right,x=m.padInfo.bottom,v=m.padInfo.left,I=m.dilationHeight,N=m.dilationWidth,C=m.strideHeight,E=m.strideWidth,A=m.inChannels,R=m.outChannels,F=m.padInfo.type==="SAME"?1:0;if(m.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${m.dataFormat}'. Please use 'channelsLast'.`);let S=r.makeOutput(m.outShape,"float32"),M=r.dataIdMap.get(S.dataId).id;return U$(i,a.shape[0],a.shape[1],a.shape[2],o,f,g,y,b,x,v,F,I,N,C,E,A,R,M),S}var que={kernelName:xi,backendName:"wasm",setupFunc:Hue,kernelFunc:jue},G$;function Kue(e){G$=e.wasm.cwrap(vi,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Xue(e){let{backend:t,inputs:n,attrs:r}=e,{dy:a,filter:s}=n,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,inputShape:p}=r,h=1,d=T.convertConv2DDataFormat(l),c=T.computeConv2DInfo(p,s.shape,i,h,o,u,!1,d),{batchSize:m,filterHeight:f,filterWidth:g,inChannels:y,inHeight:b,inWidth:x,outChannels:v,outHeight:I,outWidth:N,strideHeight:C,strideWidth:E}=c,A=f-1-c.padInfo.top,R=g-1-c.padInfo.left,F=c.dataFormat==="channelsLast",S=w.computeStrides(c.inShape),M=w.computeStrides(a.shape),[W,U,H]=w.computeStrides(s.shape),q=S[0],K=F?S[1]:S[2],J=F?S[2]:1,Y=F?1:S[1],ee=M[0],re=F?M[1]:M[2],te=F?M[2]:1,ae=F?1:M[1],se=t.makeOutput(c.inShape,"float32"),xe=t.dataIdMap.get(se.dataId).id,ue=t.dataIdMap.get(a.dataId).id,be=t.dataIdMap.get(s.dataId).id;return G$(ue,be,m,f,g,b,x,y,I,N,v,C,E,A,R,W,U,H,q,K,J,Y,ee,re,te,ae,xe),se}var Zue={kernelName:vi,backendName:"wasm",setupFunc:Kue,kernelFunc:Xue},H$;function Jue(e){H$=e.wasm.cwrap(wi,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Yue(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;if(a.dtype!=="float32")throw new Error(`Tensor x must have dtype float32, got ${a.dtype}`);if(s.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=T.computeConv3DInfo(a.shape,s.shape,i,l,o),p=n.makeOutput(u.outShape,a.dtype);return H$(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(p.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),p}var Que={kernelName:wi,backendName:"wasm",setupFunc:Jue,kernelFunc:Yue},j$;function epe(e){j$=e.wasm.cwrap(Dl,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function tpe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r;if(a.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);if(s.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=T.computeConv3DInfo(a.shape,l,i,1,o),p=n.makeOutput(u.filterShape,s.dtype);return j$(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(p.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),p}var npe={kernelName:Dl,backendName:"wasm",setupFunc:epe,kernelFunc:tpe},q$;function rpe(e){q$=e.wasm.cwrap(Ml,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function ape(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r;if(a.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);if(s.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=T.computeConv3DInfo(l,s.shape,o,1,i),p=n.makeOutput(u.inShape,a.dtype);return q$(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(p.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),p}var spe={kernelName:Ml,backendName:"wasm",setupFunc:rpe,kernelFunc:ape},ipe=He(ki),ope=He(Ii),px;(function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"})(px||(px={}));var K$;function lpe(e){K$=e.wasm.cwrap(Ll,null,["number","number","number","number","array","number","number","number","number","number"])}function upe(e){let{backend:t,inputs:n,attrs:r}=e,{method:a,extrapolationValue:s,cropSize:i}=r,{image:o,boxes:l,boxInd:u}=n,p=l.shape[0],[h,d]=i,c=[p,h,d,o.shape[3]],m=t.dataIdMap.get(o.dataId),f;o.dtype!=="float32"&&(f=bs({backend:t,inputs:{x:o},attrs:{dtype:"float32"}}),m=t.dataIdMap.get(f.dataId));let g=m.id,y=t.dataIdMap.get(l.dataId).id,b=t.dataIdMap.get(u.dataId).id,x=t.makeOutput(c,"float32"),v=t.dataIdMap.get(x.dataId).id,I=new Uint8Array(new Int32Array(o.shape).buffer);return K$(g,y,b,p,I,h,d,px[a],s,v),f!=null&&t.disposeData(f.dataId),x}var ppe={kernelName:Ll,backendName:"wasm",setupFunc:lpe,kernelFunc:upe},X$;function dpe(e){X$=e.wasm.cwrap(Ol,null,["number","number","number","number","number","number"])}function hpe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r,l=a.shape.length;w.assert(a.dtype==="float32"||a.dtype==="int32",()=>`cumprod does not support ${a.dtype} tensors in the WASM backend`);let u=T.getAxesPermutation([s],l),p=a;u!==null&&(p=as({inputs:{x:a},attrs:{perm:u},backend:n}));let h=T.getInnerMostAxes(1,l)[0];T.assertAxesAreInnerMostDims("cumprod",[h],l);let d=n.makeOutput(p.shape,p.dtype),c=p.shape[h],m=n.dataIdMap.get(p.dataId).id,f=n.dataIdMap.get(d.dataId).id;X$(m,i?1:0,o?1:0,c,f,Xe[a.dtype]);let g=d;if(u!==null){let y=T.getUndoAxesPermutation(u);g=as({inputs:{x:d},attrs:{perm:y},backend:n}),n.disposeData(p.dataId),n.disposeData(d.dataId)}return g}var cpe={kernelName:Ol,backendName:"wasm",setupFunc:dpe,kernelFunc:hpe},Z$;function mpe(e){Z$=e.wasm.cwrap(Si,null,["number","number","number","number","number","number"])}function fpe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r,l=a.shape.length;w.assert(a.dtype==="float32"||a.dtype==="int32",()=>`cumsum does not support ${a.dtype} tensors in the WASM backend`);let u=T.getAxesPermutation([s],l),p=a;u!==null&&(p=as({inputs:{x:a},attrs:{perm:u},backend:n}));let h=T.getInnerMostAxes(1,l)[0];T.assertAxesAreInnerMostDims("cumsum",[h],l);let d=n.makeOutput(p.shape,p.dtype),c=p.shape[h],m=n.dataIdMap.get(p.dataId).id,f=n.dataIdMap.get(d.dataId).id;Z$(m,i?1:0,o?1:0,c,f,Xe[a.dtype]);let g=d;if(u!==null){let y=T.getUndoAxesPermutation(u);g=as({inputs:{x:d},attrs:{perm:y},backend:n}),n.disposeData(p.dataId),n.disposeData(d.dataId)}return g}var gpe={kernelName:Si,backendName:"wasm",setupFunc:mpe,kernelFunc:fpe},J$;function ype(e){J$=e.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])}function bpe(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,weights:s}=n,{size:i,binaryOutput:o}=r,l=s.shape.reduce((d,c)=>d*c,1)!==0,u=a.shape.length===1?[i]:[a.shape[0],i],p=t.makeOutput(u,s.dtype);function h(d){return t.dataIdMap.get(d.dataId).id}return J$(h(a),new Uint8Array(new Int32Array(a.shape).buffer),a.shape.length,i,l,h(s),Xe[s.dtype],o,h(p)),p}var xpe={kernelName:Jp,backendName:"wasm",setupFunc:ype,kernelFunc:bpe},Y$;function vpe(e){Y$=e.wasm.cwrap(zl,null,["number","number","number","array","number","array","array","number","number"])}function wpe(e){let{backend:t,inputs:n,attrs:r}=e,{x:a}=n,{blockSize:s,dataFormat:i}=r,o=a.shape[0],l=i==="NHWC"?a.shape[1]:a.shape[2],u=i==="NHWC"?a.shape[2]:a.shape[3],p=i==="NHWC"?a.shape[3]:a.shape[1],h=l*s,d=u*s,c=p/(s*s),m=i==="NHWC"?[o,h,d,c]:[o,c,h,d],f=t.makeOutput(m,"float32"),g=t.dataIdMap.get(a.dataId).id,y=new Uint8Array(new Int32Array(w.computeStrides(a.shape)).buffer),b=new Uint8Array(new Int32Array(m).buffer),x=new Uint8Array(new Int32Array(w.computeStrides(m)).buffer),v=t.dataIdMap.get(f.dataId).id;return Y$(g,s,i==="NHWC"?1:0,y,a.shape.length-1,b,x,m.length,v),f}var kpe={kernelName:zl,backendName:"wasm",setupFunc:vpe,kernelFunc:wpe},Q$;function Ipe(e){Q$=e.wasm.cwrap(Ni,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Spe(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,i=r.dataIdMap.get(a.dataId).id,o=r.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:p,dimRoundingMode:h}=n,d=u==null?[1,1]:u,c=T.computeConv2DInfo(a.shape,s.shape,l,d,p,h,!0),m=c.filterHeight,f=c.filterWidth,g=c.padInfo.top,y=c.padInfo.right,b=c.padInfo.bottom,x=c.padInfo.left,v=c.dilationHeight,I=c.dilationWidth,N=c.strideHeight,C=c.strideWidth,E=c.inChannels,A=c.outChannels,R=c.padInfo.type==="SAME"?1:0;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);let F=r.makeOutput(c.outShape,"float32"),S=r.dataIdMap.get(F.dataId).id;return Q$(i,a.shape[0],a.shape[1],a.shape[2],o,m,f,g,y,b,x,R,v,I,N,C,E,A,S),F}var Npe={kernelName:Ni,backendName:"wasm",setupFunc:Ipe,kernelFunc:Spe},eA;function Tpe(e){eA=e.wasm.cwrap("Diag",null,["number","number","number","number"])}function Cpe(e){let{inputs:t,backend:n}=e,{x:r}=t,a=w.sizeFromShape(r.shape),s=n.makeOutput([...r.shape,...r.shape],r.dtype);return eA(n.dataIdMap.get(r.dataId).id,Xe[r.dtype],a,n.dataIdMap.get(s.dataId).id),s}var _pe={kernelName:Yp,backendName:"wasm",setupFunc:Tpe,kernelFunc:Cpe},tA;function Epe(e){tA=e.wasm.cwrap(Ti,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function $pe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;if(a.dtype!==s.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${a.dtype} and ${s.dtype}`);let u=T.computeDilation2DInfo(a.shape,s.shape,i,o,"NHWC",l),p=n.makeOutput(u.outShape,a.dtype);return tA(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(p.dataId).id,Xe[a.dtype],u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.filterHeight,u.filterWidth,u.padInfo.top,u.padInfo.left),p}var Ape={kernelName:Ti,backendName:"wasm",setupFunc:Epe,kernelFunc:$pe},nA;function Fpe(e){nA=e.wasm.cwrap(il,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Rpe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=r;if(a.dtype!==s.dtype||a.dtype!==i.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${s.dtype}, and ${i.dtype}`);let p=T.computeDilation2DInfo(a.shape,s.shape,o,l,"NHWC",u),h=n.makeOutput(s.shape,s.dtype);return nA(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(h.dataId).id,Xe[a.dtype],p.batchSize,p.inChannels,p.inHeight,p.inWidth,p.outHeight,p.outWidth,p.strideHeight,p.strideWidth,p.dilationHeight,p.dilationWidth,p.filterHeight,p.filterWidth,p.padInfo.top,p.padInfo.left),h}var Dpe={kernelName:il,backendName:"wasm",setupFunc:Fpe,kernelFunc:Rpe},rA;function Mpe(e){rA=e.wasm.cwrap(sl,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Ope(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=r;if(a.dtype!==s.dtype||a.dtype!==i.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${s.dtype}, and ${i.dtype}`);let p=T.computeDilation2DInfo(a.shape,s.shape,o,l,"NHWC",u),h=n.makeOutput(a.shape,a.dtype);return rA(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(h.dataId).id,Xe[a.dtype],p.batchSize,p.inChannels,p.inHeight,p.inWidth,p.outHeight,p.outWidth,p.strideHeight,p.strideWidth,p.dilationHeight,p.dilationWidth,p.filterHeight,p.filterWidth,p.padInfo.top,p.padInfo.left),h}var Lpe={kernelName:sl,backendName:"wasm",setupFunc:Mpe,kernelFunc:Ope},zpe=He(_i),aA;function Ppe(e){aA=e.wasm.cwrap(Pl,null,["number","number","number"])}function Bpe(e){let{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=n.makeOutput(a.shape,"float32"),i=o=>n.dataIdMap.get(o.dataId).id;return aA(i(a),i(r),i(s)),s}var Wpe={kernelName:Pl,backendName:"wasm",setupFunc:Ppe,kernelFunc:Bpe},Vpe=!1,Upe=Lt(Bl,Vpe,"bool"),Gpe=He(Ei),Hpe=He($i,"float32");function dx(e){let{inputs:t,attrs:n,backend:r}=e,{input:a}=t,{dim:s}=n,i=a.shape.length,o=a.shape.slice(),l=s;return s<0&&(w.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),An({inputs:{x:a},backend:r,attrs:{shape:o}})}var jpe={kernelName:Wl,backendName:"wasm",kernelFunc:dx},qpe=He(Ai,"float32");function sA(e){let{attrs:{shape:t,value:n},backend:r}=e,{attrs:{dtype:a}}=e;a=a||w.inferDtype(n);let s=r.makeOutput(t,a);return r.typedArrayFromHeap(s).fill(n),s}var Kpe={kernelName:Qp,backendName:"wasm",kernelFunc:sA},iA;function Xpe(e){iA=e.wasm.cwrap(Vl,null,["number","number","number","number","number","number"])}function Zpe(e){let{inputs:t,backend:n}=e,{image:r}=t,a=n.makeOutput(r.shape,r.dtype),s=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(a.dataId).id,[o,l,u,p]=r.shape;return iA(s,o,l,u,p,i),a}var Jpe={kernelName:Vl,backendName:"wasm",kernelFunc:Zpe,setupFunc:Xpe},Ype=He(Fi),Qpe=!1,ede=Lt(Ri,Qpe),oA;function tde(e){oA=e.wasm.cwrap(Di,null,["number","number","number","number","number","number","number"])}function nde(e){let{backend:t,inputs:n,attrs:r}=e,{varianceEpsilon:a}=r,{x:s,mean:i,variance:o,offset:l,scale:u}=n,p=t.dataIdMap.get(s.dataId).id,h=t.dataIdMap.get(i.dataId).id,d=t.dataIdMap.get(o.dataId).id,c=l!=null?t.dataIdMap.get(l.dataId).id:0,m=u!=null?t.dataIdMap.get(u.dataId).id:0,f=t.makeOutput(s.shape,s.dtype);if(w.sizeFromShape(s.shape)===0)return f;let g=t.dataIdMap.get(f.dataId).id;return oA(p,h,d,c,m,a,g),f}var rde={kernelName:Di,backendName:"wasm",setupFunc:tde,kernelFunc:nde},lA;function ade(e){lA=e.wasm.cwrap(Ws,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function sde(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:p,dataFormat:h,dimRoundingMode:d,activation:c,leakyreluAlpha:m}=n,f=T.computeConv2DInfo(a.shape,s.shape,l,p,u,d),g=Wp[c];if(g==null)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);let y=r.dataIdMap.get(a.dataId).id,b=r.dataIdMap.get(s.dataId).id,x=f.outChannels,v=0;if(i!=null){let te=r.dataIdMap.get(i.dataId);if(te.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${te.shape.length}.`);if(te.shape[0]!==x)throw new Error(`FusedConv2D bias shape (${te.shape}) does not match the number of output channels (${x})`);v=te.id}let I=f.filterHeight,N=f.filterWidth,C=f.padInfo.top,E=f.padInfo.right,A=f.padInfo.bottom,R=f.padInfo.left,F=f.dilationHeight,S=f.dilationWidth,M=f.strideHeight,W=f.strideWidth,U=f.inChannels,H=f.padInfo.type==="SAME"?1:0,q=f.batchSize,K=f.inHeight,J=f.inWidth;if(h!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${h}'. Please use 'NHWC'.`);let Y=r.makeOutput(f.outShape,"float32"),ee=r.dataIdMap.get(Y.dataId).id,re=o==null?0:r.dataIdMap.get(o.dataId).id;return lA(y,q,K,J,b,I,N,v,C,E,A,R,H,F,S,M,W,U,x,g,re,m||0,ee),Y}var ide={kernelName:Ws,backendName:"wasm",setupFunc:ade,kernelFunc:sde},uA;function ode(e){uA=e.wasm.cwrap(Vs,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function lde(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:p,dataFormat:h,dimRoundingMode:d,activation:c,leakyreluAlpha:m}=n,f=T.computeConv2DInfo(a.shape,s.shape,l,p,u,d,!0),g=Wp[c];if(g==null)throw new Error(`${c} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let y=r.dataIdMap.get(a.dataId).id,b=r.dataIdMap.get(s.dataId).id,x=f.outChannels,v=0;if(i!=null){let te=r.dataIdMap.get(i.dataId);if(te.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${te.shape.length}.`);if(te.shape[0]!==x)throw new Error(`FusedDepthwiseConv2D bias shape (${te.shape}) does not match the number of output channels (${x})`);v=te.id}let I=f.filterHeight,N=f.filterWidth,C=f.padInfo.top,E=f.padInfo.right,A=f.padInfo.bottom,R=f.padInfo.left,F=f.dilationHeight,S=f.dilationWidth,M=f.strideHeight,W=f.strideWidth,U=f.inChannels,H=f.padInfo.type==="SAME"?1:0,q=f.batchSize,K=f.inHeight,J=f.inWidth;if(h!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${h}'. Please use 'NHWC'.`);let Y=r.makeOutput(f.outShape,"float32"),ee=r.dataIdMap.get(Y.dataId).id,re=o==null?0:r.dataIdMap.get(o.dataId).id;return uA(y,q,K,J,b,I,N,v,C,E,A,R,H,F,S,M,W,U,x,g,re,m||0,ee),Y}var ude={kernelName:Vs,backendName:"wasm",setupFunc:ode,kernelFunc:lde},pA;function pde(e){pA=e.wasm.cwrap(Gl,null,["number","number","number","number","number","number","array","number"])}function dde(e){let{backend:t,inputs:n}=e,{params:r,indices:a}=n,[s,i,o,l]=Yv.prepareAndValidate(r,a),u=t.makeOutput(s,r.dtype);if(i===0)return u;let p=a.shape,h=p[p.length-1],d=t.dataIdMap.get(r.dataId).id,c=t.dataIdMap.get(a.dataId).id,m=new Uint8Array(new Int32Array(l).buffer),f=t.dataIdMap.get(u.dataId).id;return pA(d,Xe[r.dtype],c,i,h,o,m,f),u}var hde={kernelName:Gl,backendName:"wasm",setupFunc:pde,kernelFunc:dde},dA;function cde(e){dA=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function mde(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,indices:s}=n,{axis:i,batchDims:o}=r,l=w.parseAxisParam(i,a.shape)[0],u=t.readSync(s.dataId),p=a.shape[l];for(let C=0;C<u.length;++C){let E=u[C];w.assert(E<=p-1&&E>=0,()=>`GatherV2: the index value ${E} is not in [0, ${p-1}]`)}let h=T.segment_util.collectGatherOpShapeInfo(a,s,l,o),d=An({inputs:{x:a},attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]},backend:t}),c=w.sizeFromShape(s.shape),m=An({inputs:{x:s},attrs:{shape:[h.batchSize,c/h.batchSize]},backend:t}),f=[h.batchSize,h.outerSize,c/h.batchSize,h.sliceSize],g=t.makeOutput(f,a.dtype);if(w.sizeFromShape(a.shape)===0)return g;let y=d.shape.length-1,b=t.dataIdMap.get(d.dataId).id,x=t.dataIdMap.get(m.dataId).id,v=t.dataIdMap.get(g.dataId).id,I=new Uint8Array(new Int32Array(w.computeStrides(d.shape)).buffer),N=new Uint8Array(new Int32Array(w.computeStrides(f)).buffer);return dA(b,Xe[a.dtype],I,y,x,h.batchSize,N,v),t.disposeData(d.dataId),t.disposeData(m.dataId),g.shape=h.outputShape,g}var fde={kernelName:Ul,backendName:"wasm",setupFunc:cde,kernelFunc:mde},gde=!1,yde=Lt(Hl,gde,"bool"),bde=!1,xde=Lt(Mi,bde,"bool"),vde=He(Li,"bool"),wde=He(zi,"bool"),kde=He(Pi,"bool"),hA;function Ide(e){hA=e.wasm.cwrap(Bi,null,["number","number","number","number"])}function Sde(e){let{inputs:{x:t},attrs:{alpha:n},backend:r}=e,a=r.dataIdMap.get(t.dataId).id,s=r.makeOutput(t.shape,"float32");if(w.sizeFromShape(t.shape)!==0){let i=r.dataIdMap.get(s.dataId).id;hA(a,Xe[t.dtype],n,i)}return s}var Nde={kernelName:Bi,backendName:"wasm",setupFunc:Ide,kernelFunc:Sde},Tde=!1,Cde=Lt(jl,Tde,"bool"),_de=!1,Ede=Lt(ql,_de,"bool"),cA;function $de(e){cA=e.wasm.cwrap(Kl,null,["number","number","number","number"])}function Ade(e){let{attrs:t,backend:n}=e,{start:r,stop:a,num:s}=t,i=Math.floor(s),o=n.makeOutput([i],"float32");return cA(n.dataIdMap.get(o.dataId).id,r,a,i),o}var Fde={kernelName:Kl,backendName:"wasm",setupFunc:$de,kernelFunc:Ade},Rde=He(Wi),Dde=He(Vi),Mde=!1,Ode=Lt(Xl,Mde,"bool"),Lde=He(Zl),zde=!1,Pde=Lt(Jl,zde,"bool"),Bde=!1,Wde=Lt(cS,Bde,"bool"),mA;function Vde(e){mA=e.wasm.cwrap(Ui,null,["number","number","number","number","number","number","number"])}function Ude(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r;if(a.dtype!=="float32")throw new Error("LRN error: x must have dtype float32");let u=n.makeOutput(a.shape,a.dtype);return mA(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(u.dataId).id,a.shape[3],s,i,o,l),u}var Gde={kernelName:Ui,backendName:"wasm",setupFunc:Vde,kernelFunc:Ude},fA;function Hde(e){fA=e.wasm.cwrap(Yl,null,["number","number","number","number","number","number","number","number","number"])}function jde(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:p}=r;if(a.dtype!=="float32"||s.dtype!=="float32"||i.dtype!=="float32")throw new Error("LRNGrad error: x, y, and dy must have dtype float32");let h=n.makeOutput(a.shape,a.dtype);return fA(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(h.dataId).id,i.shape[3],o,l,u,p),h}var qde={kernelName:Yl,backendName:"wasm",setupFunc:Hde,kernelFunc:jde},gA;function Kde(e){gA=e.wasm.cwrap(Gi,null,["number","number","number","number"])}function Xde(e){let{backend:t,inputs:n,attrs:r}=e,{reductionIndices:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:p,originalAxes:h,inputWasTransposed:d}=ys(i,a,t);if(d){let b=t.dataIdMap.get(u.dataId).id;l=u,o=b}let c=l.shape.length;T.assertAxesAreInnerMostDims("max",p,c);let[m,f]=T.computeOutAndReduceShapes(l.shape,p),g=w.sizeFromShape(f),y=t.makeOutput(m,i.dtype);if(w.sizeFromShape(l.shape)!==0){let b=t.dataIdMap.get(y.dataId).id;gA(o,Xe[i.dtype],g,b)}if(d&&t.disposeData(u.dataId),s){let b=T.expandShapeToKeepDim(y.shape,h);y.shape=b}return y}var Zde={kernelName:Gi,backendName:"wasm",setupFunc:Kde,kernelFunc:Xde},Jde=!1,Yde=Lt(Hi,Jde),yA;function Qde(e){yA=e.wasm.cwrap(ji,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function ehe(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,s=r.dataIdMap.get(a.dataId).id;w.assert(a.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${a.dtype}.`);let{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,p=T.computePool2DInfo(a.shape,i,o,1,l,u),h=p.filterHeight,d=p.filterWidth,c=p.padInfo.top,m=p.padInfo.right,f=p.padInfo.bottom,g=p.padInfo.left,y=p.dilationHeight,b=p.dilationWidth,x=p.strideHeight,v=p.strideWidth,I=p.inChannels,N=p.outChannels;if(p.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);let C=r.makeOutput(p.outShape,"float32"),E=r.dataIdMap.get(C.dataId).id;return yA(s,a.shape[0],a.shape[1],a.shape[2],h,d,c,m,f,g,y,b,x,v,I,N,E),C}var the={kernelName:ji,backendName:"wasm",setupFunc:Qde,kernelFunc:ehe},bA;function nhe(e){bA=e.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function rhe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,p=T.computePool3DInfo(a.shape,s,i,1,o,l,u),h=n.makeOutput(p.outShape,a.dtype);return bA(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(h.dataId).id,p.batchSize,p.inChannels,p.inDepth,p.inHeight,p.inWidth,p.outDepth,p.outHeight,p.outWidth,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left),h}var ahe={kernelName:Ql,backendName:"wasm",setupFunc:nhe,kernelFunc:rhe},xA;function she(e){xA=e.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function ihe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r,p=T.computePool3DInfo(s.shape,i,o,1,l,u),h=n.makeOutput(s.shape,s.dtype);return xA(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(h.dataId).id,p.batchSize,p.inChannels,p.inDepth,p.inHeight,p.inWidth,p.outDepth,p.outHeight,p.outWidth,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left),h}var ohe={kernelName:td,backendName:"wasm",setupFunc:she,kernelFunc:ihe},vA;function lhe(e){vA=e.wasm.cwrap("MaxPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function uhe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r,p=T.computePool2DInfo(s.shape,i,o,1,l,u),h=n.makeOutput(s.shape,s.dtype);return vA(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(h.dataId).id,p.batchSize,p.inChannels,p.inHeight,p.inWidth,p.outHeight,p.outWidth,p.strideHeight,p.strideWidth,p.dilationHeight,p.dilationWidth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.top,p.padInfo.left),h}var phe={kernelName:ed,backendName:"wasm",setupFunc:lhe,kernelFunc:uhe},wA;function dhe(e){wA=e.wasm.cwrap("MaxPoolWithArgmax",null,["number","number","number","number","boolean","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function hhe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:l}=r;w.assert(a.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`);let u=[1,1];w.assert(T.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let p=T.computePool2DInfo(a.shape,s,i,[1,1],o),h=n.makeOutput(p.outShape,a.dtype),d=n.makeOutput(p.outShape,"int32");return wA(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(h.dataId).id,n.dataIdMap.get(d.dataId).id,Xe[a.dtype],l,p.batchSize,p.inChannels,p.inHeight,p.inWidth,p.outHeight,p.outWidth,p.strideHeight,p.strideWidth,p.dilationHeight,p.dilationWidth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.top,p.padInfo.left),[h,d]}var che={kernelName:nd,backendName:"wasm",setupFunc:dhe,kernelFunc:hhe},kA;function mhe(e){kA=e.wasm.cwrap(qi,null,["number, number, number"])}function fhe(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:p,axes:h,originalAxes:d,inputWasTransposed:c}=ys(i,a,t),m=h;if(c){let v=t.dataIdMap.get(p.dataId).id;v!==o&&(u=p,l=v,m=T.getInnerMostAxes(m.length,u.shape.length))}T.assertAxesAreInnerMostDims("mean",m,u.shape.length);let[f,g]=T.computeOutAndReduceShapes(u.shape,m),y=w.sizeFromShape(g),b=u;u.dtype!=="float32"&&(b=bs({backend:t,inputs:{x:u},attrs:{dtype:"float32"}}),l=t.dataIdMap.get(b.dataId).id);let x=t.makeOutput(f,"float32");if(w.sizeFromShape(u.shape)!==0){let v=t.dataIdMap.get(x.dataId).id;kA(l,y,v)}if(c&&t.disposeData(p.dataId),s){let v=T.expandShapeToKeepDim(x.shape,d);x.shape=v}return u.dtype!=="float32"&&t.disposeData(b.dataId),x}var ghe={kernelName:qi,backendName:"wasm",setupFunc:mhe,kernelFunc:fhe},IA;function yhe(e){IA=e.wasm.cwrap(Ki,null,["number","number","number","number"])}function bhe(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:p,axes:h,originalAxes:d,inputWasTransposed:c}=ys(i,a,t);if(c){let x=t.dataIdMap.get(p.dataId).id;x!==o&&(u=p,l=x)}let m=u.shape.length;T.assertAxesAreInnerMostDims("min",h,m);let[f,g]=T.computeOutAndReduceShapes(u.shape,h),y=w.sizeFromShape(g),b=t.makeOutput(f,u.dtype);if(w.sizeFromShape(u.shape)!==0){let x=t.dataIdMap.get(b.dataId).id;IA(l,Xe[i.dtype],y,x)}if(c&&t.disposeData(p.dataId),s){let x=T.expandShapeToKeepDim(b.shape,d);b.shape=x}return b}var xhe={kernelName:Ki,backendName:"wasm",setupFunc:yhe,kernelFunc:bhe},vhe=!1,whe=Lt(Xi,vhe),hx;(function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"})(hx||(hx={}));var SA;function khe(e){SA=e.wasm.cwrap(Zi,null,["number","array","number","number","array","array","number","number"])}function Ihe(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,mode:a}}=e,s=r.map((m,f)=>m[0]+t.shape[f]+m[1]),i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),p=r.map(m=>m[0]),h=r.map(m=>m[1]),d=new Uint8Array(new Int32Array(p).buffer),c=new Uint8Array(new Int32Array(h).buffer);return SA(i,u,t.shape.length,Xe[t.dtype],d,c,hx[a],l),o}var She={kernelName:Zi,backendName:"wasm",kernelFunc:Ihe,setupFunc:khe},NA;function Nhe(e){NA=e.wasm.cwrap(wo,null,["number","number","number","number"])}function TA(e){let{backend:t,inputs:{logits:n},attrs:{dim:r}}=e,a=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),i=t.dataIdMap.get(s.dataId).id,o=n.shape[r],l=w.sizeFromShape(n.shape)/o;return w.sizeFromShape(s.shape)===0||NA(a,i,o,l),s}var The={kernelName:wo,backendName:"wasm",setupFunc:Nhe,kernelFunc:TA},CA;function Che(e){CA=e.wasm.cwrap(eu,null,["number","number","number","number","number","number"])}function _he(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r;if(a.dtype!=="float32")throw new Error(`Tensor logits must have dtype float32, got ${a.dtype}`);let l=o?a:TA({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),[u,p]=l.shape,h=n.makeOutput([u,s],"int32");return CA(n.dataIdMap.get(l.dataId).id,u,p,s,i,n.dataIdMap.get(h.dataId).id),o||n.disposeData(l.dataId),h}var Ehe={kernelName:eu,backendName:"wasm",setupFunc:Che,kernelFunc:_he},$he=Lt(Ji,!0),Ahe=!0,Fhe=Lt(Yi,Ahe),Rhe=He(tu);function f1(e,t){let n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),r=n[0],a=n[1],s=n[2],i=n[3];return e.wasm._free(t),{pSelectedIndices:r,selectedSize:a,pSelectedScores:s,pValidOutputs:i}}var _A;function Dhe(e){_A=e.wasm.cwrap(ru,"number",["number","number","number","number","number"])}function Mhe(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i}=r,{boxes:o,scores:l}=n,u=t.dataIdMap.get(o.dataId).id,p=t.dataIdMap.get(l.dataId).id,h=_A(u,p,s,a,i),{pSelectedIndices:d,selectedSize:c,pSelectedScores:m,pValidOutputs:f}=f1(t,h);return t.wasm._free(m),t.wasm._free(f),t.makeOutput([c],"int32",d)}var Ohe={kernelName:ru,backendName:"wasm",setupFunc:Dhe,kernelFunc:Mhe},EA;function Lhe(e){EA=e.wasm.cwrap(au,"number",["number","number","number","number","number","bool"])}function zhe(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i,padToMaxOutputSize:o}=r,{boxes:l,scores:u}=n,p=t.dataIdMap.get(l.dataId).id,h=t.dataIdMap.get(u.dataId).id,d=EA(p,h,s,a,i,o),{pSelectedIndices:c,selectedSize:m,pSelectedScores:f,pValidOutputs:g}=f1(t,d);t.wasm._free(f);let y=t.makeOutput([m],"int32",c),b=t.makeOutput([],"int32",g);return[y,b]}var Phe={kernelName:au,backendName:"wasm",setupFunc:Lhe,kernelFunc:zhe},$A;function Bhe(e){$A=e.wasm.cwrap(su,"number",["number","number","number","number","number","number"])}function Whe(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i,softNmsSigma:o}=r,{boxes:l,scores:u}=n,p=t.dataIdMap.get(l.dataId).id,h=t.dataIdMap.get(u.dataId).id,d=$A(p,h,s,a,i,o),{pSelectedIndices:c,selectedSize:m,pSelectedScores:f,pValidOutputs:g}=f1(t,d);t.wasm._free(g);let y=t.makeOutput([m],"int32",c),b=t.makeOutput([m],"float32",f);return[y,b]}var Vhe={kernelName:su,backendName:"wasm",setupFunc:Bhe,kernelFunc:Whe},Uhe=!1,Ghe=Lt(nu,Uhe,"bool"),AA;function Hhe(e){AA=e.wasm.cwrap(Qi,null,["number","number","number","number","number"])}function jhe(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r,u=n.makeOutput([...a.shape,i],s),p=n.dataIdMap.get(u.dataId).id,h=n.dataIdMap.get(a.dataId).id;return AA(h,i,o,l,p),u}var qhe={kernelName:Qi,backendName:"wasm",setupFunc:Hhe,kernelFunc:jhe};function Khe(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(1),r}var Xhe={kernelName:iu,backendName:"wasm",kernelFunc:Khe};function Zhe(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(t.length===1)return dx({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach(p=>{w.assertShapesMatch(s,p.shape,"All tensors passed to stack must have matching shapes"),w.assert(i===p.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(p=>{let h=dx({inputs:{input:p},backend:n,attrs:{dim:a}});return o.push(h),h}),u=V$({inputs:l,backend:n,attrs:{axis:a}});return o.forEach(p=>n.disposeData(p.dataId)),u}var Jhe={kernelName:ou,backendName:"wasm",kernelFunc:Zhe},FA;function Yhe(e){FA=e.wasm.cwrap(eo,null,["number","array","number","number","array","array","number","number"])}function Qhe(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,constantValue:a}}=e,s=r.map((m,f)=>m[0]+t.shape[f]+m[1]);if(w.sizeFromShape(t.shape)===0)return sA({backend:n,attrs:{shape:s,value:a,dtype:t.dtype}});let i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),p=r.map(m=>m[0]),h=r.map(m=>m[1]),d=new Uint8Array(new Int32Array(p).buffer),c=new Uint8Array(new Int32Array(h).buffer);return FA(i,u,t.shape.length,Xe[t.dtype],d,c,a,l),o}var RA={kernelName:eo,backendName:"wasm",kernelFunc:Qhe,setupFunc:Yhe},ece=!1,tce=Lt(to,ece),DA;function nce(e){DA=e.wasm.cwrap(no,null,["number","number","number"])}function rce(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(a.dataId).id,o=s,l=r,u=l;l.dtype!=="float32"&&(u=bs({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),o=n.dataIdMap.get(u.dataId).id);let p=n.makeOutput(r.shape,"float32"),h=n.dataIdMap.get(p.dataId).id;return DA(o,i,h),l.dtype!=="float32"&&n.disposeData(u.dataId),p}var ace={kernelName:no,backendName:"wasm",setupFunc:nce,kernelFunc:rce},MA;function sce(e){MA=e.wasm.cwrap(ro,null,["number","number","number","number"])}function ice(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:p,axes:h,originalAxes:d,inputWasTransposed:c}=ys(i,a,t),m=h;if(c){let x=t.dataIdMap.get(p.dataId).id;x!==o&&(u=p,l=x,m=T.getInnerMostAxes(m.length,u.shape.length))}T.assertAxesAreInnerMostDims("prod",m,u.shape.length);let[f,g]=T.computeOutAndReduceShapes(u.shape,m),y=w.sizeFromShape(g),b=t.makeOutput(f,u.dtype);if(w.sizeFromShape(u.shape)!==0){let x=t.dataIdMap.get(b.dataId).id;MA(l,y,Xe[b.dtype],x)}if(c&&t.disposeData(p.dataId),s){let x=T.expandShapeToKeepDim(b.shape,d);b.shape=x}return b}var oce={kernelName:ro,backendName:"wasm",setupFunc:sce,kernelFunc:ice},lce=e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:i}=n,o=U0(r,a,s,i),l=t.makeOutput([o.length],i);return t.typedArrayFromHeap(l).set(o),l},uce={kernelName:rd,backendName:"wasm",kernelFunc:lce},pce=!0,dce=Lt(Ci,pce),hce=He(ao),cce=He(so),mce=He(lo),OA;function fce(e){OA=e.wasm.cwrap(oo,null,["number","number","number","number","number","number","number","number","number","number"])}function gce(e){let{backend:t,inputs:n,attrs:r}=e,{images:a}=n,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,[p,h,d,c]=a.shape,m=[p,l,u,c],f=t.dataIdMap.get(a.dataId),g;f.dtype!=="float32"&&(g=bs({backend:t,inputs:{x:a},attrs:{dtype:"float32"}}),f=t.dataIdMap.get(g.dataId));let y=f.id,b=t.makeOutput(m,"float32");if(w.sizeFromShape(a.shape)===0)return b;let x=t.dataIdMap.get(b.dataId).id;return OA(y,p,h,d,c,l,u,s?1:0,i?1:0,x),g!=null&&t.disposeData(g.dataId),b}var yce={kernelName:oo,backendName:"wasm",setupFunc:fce,kernelFunc:gce},LA;function bce(e){LA=e.wasm.cwrap(pu,null,["number","number","number","array","array","boolean"])}function xce(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=n.makeOutput(a.shape,"float32"),l=n.dataIdMap.get(a.dataId),u;return l.dtype!=="float32"&&(u=bs({backend:n,inputs:{x:a},attrs:{dtype:"float32"}}),l=n.dataIdMap.get(u.dataId)),LA(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(a.shape).buffer),new Uint8Array(new Int32Array(s.shape).buffer),i),u!=null&&n.disposeData(u.dataId),o}var vce={kernelName:pu,backendName:"wasm",setupFunc:bce,kernelFunc:xce},zA;function wce(e){zA=e.wasm.cwrap(io,null,["number","number","number","number","number","number","number","number","number","number"])}function kce(e){let{backend:t,inputs:n,attrs:r}=e,{images:a}=n,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,[p,h,d,c]=a.shape,m=[p,l,u,c],f=t.makeOutput(m,"float32");if(w.sizeFromShape(a.shape)===0)return f;let g=t.dataIdMap.get(a.dataId),y;g.dtype!=="float32"&&(y=bs({backend:t,inputs:{x:a},attrs:{dtype:"float32"}}),g=t.dataIdMap.get(y.dataId));let b=g.id,x=t.dataIdMap.get(f.dataId).id;return zA(b,p,h,d,c,l,u,s?1:0,i?1:0,x),y!=null&&t.disposeData(y.dataId),f}var Ice={kernelName:io,backendName:"wasm",setupFunc:wce,kernelFunc:kce},PA;function Sce(e){PA=e.wasm.cwrap(uu,null,["number","number","number","array","array","boolean"])}function Nce(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=n.makeOutput(a.shape,"float32"),l=n.dataIdMap.get(a.dataId),u;return l.dtype!=="float32"&&(u=bs({backend:n,inputs:{x:a},attrs:{dtype:"float32"}}),l=n.dataIdMap.get(u.dataId)),PA(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(a.shape).buffer),new Uint8Array(new Int32Array(s.shape).buffer),i),u!=null&&n.disposeData(u.dataId),o}var Tce={kernelName:uu,backendName:"wasm",setupFunc:Sce,kernelFunc:Nce},BA;function Cce(e){BA=e.wasm.cwrap(uo,null,["number","array","number","array","number","number"])}function _ce(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,i=w.parseAxisParam(s,a.shape);if(a.shape.length===0)return ef({inputs:{x:a},backend:n});let o=n.makeOutput(a.shape,a.dtype),l=n.dataIdMap.get(a.dataId).id,u=n.dataIdMap.get(o.dataId).id,p=new Uint8Array(new Int32Array(i).buffer),h=new Uint8Array(new Int32Array(a.shape).buffer);BA(l,p,i.length,h,a.shape.length,u);let d=An({inputs:{x:o},attrs:{shape:a.shape},backend:n});return n.disposeData(o.dataId),d}var Ece={kernelName:uo,backendName:"wasm",kernelFunc:_ce,setupFunc:Cce},WA;function $ce(e){WA=e.wasm.cwrap(Nu,null,["number","number","number","number","number","number","number","number","array","number","number"])}function Ace(e){let{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{radians:s,fillValue:i,center:o}=r,l=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(a.dataId).id,p=n.dataIdMap.get(l.dataId).id,[h,d,c,m]=a.shape,[f,g]=T.getImageCenter(o,d,c),y=i===0,b=255,x=typeof i=="number"?[i,i,i,y?0:b]:[...i,b],v=new Uint8Array(new Int32Array(x).buffer);return WA(u,h,d,c,m,s,f,g,v,x.length,p),l}var Fce={kernelName:Nu,backendName:"wasm",kernelFunc:Ace,setupFunc:$ce},Rce=He(po),Dce=He(ho),VA;function Mce(e){VA=e.wasm.cwrap(du,null,["number","number","number","number","number","number","array","number","number"])}function Oce(e){let{backend:t,inputs:n,attrs:r}=e,{indices:a,updates:s}=n,{shape:i}=r,o=t.makeOutput(i,s.dtype);if(w.sizeFromShape(i)===0)return o;let{sliceRank:l,numUpdates:u,sliceSize:p,strides:h,outputSize:d}=gm.calculateShapes(s,a,i),c=t.dataIdMap.get(a.dataId).id,m=t.dataIdMap.get(s.dataId).id,f=new Uint8Array(new Int32Array(h).buffer),g=t.dataIdMap.get(o.dataId).id;return VA(c,m,Xe[s.dtype],l,u,p,f,d,g),o}var Lce={kernelName:du,backendName:"wasm",setupFunc:Mce,kernelFunc:Oce},UA;function zce(e){UA=e.wasm.cwrap(cu,null,["number","number","number","number","number","number","bool","number"])}function Pce(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r;if(a.dtype!==s.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${a.dtype} and ${s.dtype}`);let o=n.makeOutput(s.shape,"int32");function l(u){return n.dataIdMap.get(u.dataId).id}return UA(l(a),l(s),a.shape[0],a.shape[1],s.shape[1],Xe[a.dtype],i==="left",l(o)),o}var Bce={kernelName:cu,backendName:"wasm",setupFunc:zce,kernelFunc:Pce},GA;function Wce(e){GA=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function Vce(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,i=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(a.dataId).id,l=n.dataIdMap.get(s.dataId).id,u=n.makeOutput(a.shape,a.dtype),p=n.dataIdMap.get(u.dataId).id,h=r.shape.length,d=a.shape.length,c=h===0||h>1||d===1?1:w.sizeFromShape(a.shape.slice(1));return GA(i,o,l,c,p),u}var Uce={kernelName:mu,backendName:"wasm",kernelFunc:Vce,setupFunc:Wce},Gce=He(co),HA;function Hce(e){HA=e.wasm.cwrap(yo,null,["number","number"])}function jce(e){let{backend:t,inputs:{x:n}}=e,r=t.dataIdMap.get(n.dataId).id,a=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(a.dataId).id;return w.sizeFromShape(a.shape)===0||HA(r,s),a}var qce={kernelName:"Sigmoid",backendName:"wasm",setupFunc:Hce,kernelFunc:jce},Kce=He(go),Xce=He(mo),Zce=He(fo),Jce=He(bo);function Yce(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r,o=w.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<a.shape.length;++g)l.push([0,0]);let u=RA.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),p=T.getReshaped(u.shape,s,o,!1),h=T.getPermuted(p.length,s.length,!1),d=T.getReshapedPermuted(u.shape,s,o,!1),c=An({inputs:{x:u},backend:n,attrs:{shape:p}}),m=as({inputs:{x:c},backend:n,attrs:{perm:h}}),f=An({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeData(u.dataId),n.disposeData(c.dataId),n.disposeData(m.dataId),f}var Qce={kernelName:gu,backendName:"wasm",kernelFunc:Yce},jA;function eme(e){jA=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function tme(e){let{backend:t,inputs:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=n,o=r.shape[0],l=r.shape[1],u=t.readSync(s.dataId)[0],p=[o+u,l],h=t.dataIdMap.get(r.dataId).id,d=t.dataIdMap.get(a.dataId).id,c=t.dataIdMap.get(i.dataId).id,m=t.makeOutput(p,r.dtype),f=t.dataIdMap.get(m.dataId).id,g=t.makeOutput(p.slice(0,1),a.dtype),y=t.dataIdMap.get(g.dataId).id,b=t.makeOutput([u],"bool"),x=t.dataIdMap.get(b.dataId).id,v=t.makeOutput([o],r.dtype),I=t.dataIdMap.get(v.dataId).id,N=t.makeOutput([4],"int32"),C=t.dataIdMap.get(N.dataId).id,E=jA(h,d,Xe[a.dtype],o,u,l,c,f,y,x,I,C),A=t.readSync(N.dataId),R;switch(A[0]){case 1:{R=T.getSparseFillEmptyRowsIndicesDenseShapeMismatch(A[1]);break}case 2:{R=T.getSparseFillEmptyRowsNegativeIndexErrorMessage(A[1],A[2]);break}case 3:R=T.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(A[1],A[2],A[3]);break;default:R=""}if(t.disposeData(N.dataId),R)throw t.disposeData(m.dataId),t.disposeData(g.dataId),t.disposeData(b.dataId),t.disposeData(v.dataId),new Error(R);let F=m,S=g;return E!==p[0]&&(F=ai({inputs:{x:m},attrs:{begin:0,size:[E,l]},backend:t}),S=ai({inputs:{x:g},attrs:{begin:0,size:E},backend:t}),t.disposeData(m.dataId),t.disposeData(g.dataId)),[F,S,b,v]}var nme={kernelName:ad,backendName:"wasm",setupFunc:eme,kernelFunc:tme},qA;function rme(e){qA=e.wasm.cwrap(bu,null,["number","number","number","number","number","number","number"])}function ame(e){let{backend:t,inputs:n}=e,{inputIndices:r,inputShape:a,newShape:s}=n;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(a.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${a.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=t.dataIdMap.get(r.dataId).id,o=t.dataIdMap.get(a.dataId).id,l=t.dataIdMap.get(s.dataId).id,u=r.shape[0],p=w.sizeFromShape(s.shape),h=t.makeOutput([u,p],r.dtype),d=t.dataIdMap.get(h.dataId).id,c=t.makeOutput([p],s.dtype),m=t.dataIdMap.get(c.dataId).id,f=t.makeOutput([3],"int32"),g=t.dataIdMap.get(f.dataId).id;qA(i,o,l,u,d,m,g);let y=t.readSync(f.dataId),b;switch(y[0]){case 0:{b=T.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(y[1],y[2]);break}case 1:{b=T.getSparseReshapeNegativeOutputDimErrorMessage(y[1],y[2]);break}case 2:b=T.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let x=Array.from(t.readSync(a.dataId)),v=Array.from(t.readSync(c.dataId));b=T.getSparseReshapeInputOutputMultipleErrorMessage(x,v);break}case 4:{let x=Array.from(t.readSync(a.dataId)),v=Array.from(t.readSync(c.dataId));b=T.getSparseReshapeInputOutputMismatchErrorMessage(x,v);break}default:b=""}if(t.disposeData(f.dataId),b)throw t.disposeData(h.dataId),t.disposeData(c.dataId),new Error(b);return[h,c]}var sme={kernelName:bu,backendName:"wasm",setupFunc:rme,kernelFunc:ame},KA;function XA(e){KA=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function ZA(e,t){let{backend:n,inputs:r}=e,{data:a,indices:s,segmentIds:i}=r,o=s.shape[0],l=n.readSync(i.dataId,o-1,o)[0],u=o>0?l+1:0;if(u<0)throw new Error(T.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let p=a.shape.slice();p[0]=u;let h=n.dataIdMap.get(a.dataId).id,d=n.dataIdMap.get(s.dataId).id,c=n.dataIdMap.get(i.dataId).id,m=n.makeOutput(p,a.dtype),f=n.dataIdMap.get(m.dataId).id,g=n.makeOutput([4],"int32"),y=n.dataIdMap.get(g.dataId).id;KA(h,Xe[a.dtype],a.shape[0],d,c,f,y,t,0);let b=n.readSync(g.dataId),x;switch(b[0]){case 0:{x=T.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break}case 1:{x=T.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break}case 2:x=T.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(b[1],b[2]);break;case 3:x=T.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(b[1],b[2],b[3]);break;default:x=""}if(n.disposeData(g.dataId),x)throw n.disposeData(m.dataId),new Error(x);return m}function ime(e){return ZA(e,!0)}var ome={kernelName:sd,backendName:"wasm",setupFunc:XA,kernelFunc:ime};function lme(e){return ZA(e,!1)}var ume={kernelName:id,backendName:"wasm",setupFunc:XA,kernelFunc:lme},JA;function pme(e){JA=e.wasm.cwrap(xu,null,["number","number","number","number","number","number","number","number","array","number","number"])}function dme(e){let{backend:t,inputs:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=n,{outputShape:o}=r,l=t.makeOutput(o,i.dtype);if(w.sizeFromShape(o)===0)return l;let{sliceRank:u,numUpdates:p,sliceSize:h,strides:d,outputSize:c}=T.calculateShapes(s,a,o),m=t.dataIdMap.get(a.dataId).id,f=t.dataIdMap.get(s.dataId).id,g=t.dataIdMap.get(i.dataId).id,y=new Uint8Array(new Int32Array(d).buffer),b=t.dataIdMap.get(l.dataId).id;return JA(m,f,s.shape.length,g,Xe[i.dtype],u,p,h,y,c,b),l}var hme={kernelName:xu,backendName:"wasm",setupFunc:pme,kernelFunc:dme};function cme(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=n,o=w.parseAxisParam(i,a.shape)[0],l=T.prepareSplitSize(a,s,o),u=new Array(a.shape.length).fill(0),p=a.shape.slice();return l.map(h=>{let d=[...p];d[o]=h;let c=ai({inputs:{x:a},attrs:{begin:u,size:d},backend:r});return u[o]+=h,c})}var mme={kernelName:yu,backendName:"wasm",kernelFunc:cme},fme=He(xo),gme=He(od),yme=!0,bme=Lt(ko,yme),YA;function xme(e){YA=e.wasm.cwrap(us,null,["number","number","number","number"])}function vme(e){let{backend:t,inputs:n,attrs:r}=e,{alpha:a}=r,{x:s}=n,i=t.dataIdMap.get(s.dataId).id,o=t.makeOutput(s.shape,s.dtype),l=t.dataIdMap.get(o.dataId).id;return YA(i,a,Xe[s.dtype],l),o}var wme={kernelName:us,backendName:"wasm",setupFunc:xme,kernelFunc:vme},QA;function kme(e){QA=e.wasm.cwrap(vu,null,["number","array","number","array","array","array","array","array","number","number"])}function Ime(e){let{backend:t,inputs:n,attrs:r}=e,{x:a}=n,{begin:s,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:p,newAxisMask:h,shrinkAxisMask:d}=r,{finalShapeSparse:c,finalShape:m,isIdentity:f,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:v}=Bt.sliceInfo(a.shape,s,i,o,l,u,p,h,d),I;if(f)I=An({inputs:{x:a},backend:t,attrs:{shape:m}});else if(g||y){w.assert(a.shape.length>=1,()=>`Input must have rank at least 1, got: ${a.shape.length}`);let N=Bt.computeOutShape(b,x,v),C=ai({inputs:{x:a},backend:t,attrs:{begin:b,size:N}});I=An({inputs:{x:C},backend:t,attrs:{shape:m}}),t.disposeData(C.dataId)}else{let N=t.makeOutput(c,"float32"),C=t.dataIdMap.get(a.dataId).id,E=new Uint8Array(new Int32Array(w.computeStrides(a.shape)).buffer),A=new Uint8Array(new Int32Array(b).buffer),R=new Uint8Array(new Int32Array(x).buffer),F=new Uint8Array(new Int32Array(v).buffer),S=new Uint8Array(new Int32Array(c).buffer),M=new Uint8Array(new Int32Array(w.computeStrides(c)).buffer),W=t.dataIdMap.get(N.dataId).id;QA(C,E,a.shape.length,A,R,F,S,M,c.length,W),I=An({inputs:{x:N},backend:t,attrs:{shape:m}}),t.disposeData(N.dataId)}return I}var Sme={kernelName:vu,backendName:"wasm",setupFunc:kme,kernelFunc:Ime};function Nme(e){let{backend:t,inputs:n,attrs:r}=e,{data:a,dataSplits:s}=n,{separator:i,nGramWidths:o,leftPad:l,rightPad:u,padWidth:p,preserveShortSequences:h}=r,d=t.readSync(a.dataId),c=t.readSync(s.dataId),[m,f]=H0(d,c,i,o,l,u,p,h),g=t.makeOutput([m.length],"string"),y=t.dataIdMap.get(g.dataId);y.stringBytes=m;let b=t.makeOutput(s.shape,"int32");return t.typedArrayFromHeap(b).set(f),[g,b]}var Tme={kernelName:ud,backendName:"wasm",kernelFunc:Nme};function Cme(e){let{backend:t,inputs:n,attrs:r}=e,{input:a,delimiter:s}=n,{skipEmpty:i}=r,o=t.readSync(a.dataId),l=t.readSync(s.dataId),[u,p,h]=j0(o,l[0],i),d=p.length,c=t.makeOutput([d,2],"int32");t.typedArrayFromHeap(c).set(u);let m=t.makeOutput([d],"string"),f=t.dataIdMap.get(m.dataId);f.stringBytes=p;let g=t.makeOutput([2],"int32");return t.typedArrayFromHeap(g).set(h),[c,m,g]}var _me={kernelName:pd,backendName:"wasm",kernelFunc:Cme};function Eme(e){let{backend:t,inputs:n,attrs:r}=e,{input:a}=n,{numBuckets:s}=r,i=t.readSync(a.dataId),o=q0(i,s),l=t.makeOutput(a.shape,"int32");return t.typedArrayFromHeap(l).set(o),l}var $me={kernelName:dd,backendName:"wasm",kernelFunc:Eme},Ame=!0,Fme=Lt(Io,Ame),eF;function Rme(e){eF=e.wasm.cwrap(vo,null,["number","number","number","number"])}function Dme(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:p,axes:h,originalAxes:d,inputWasTransposed:c}=ys(i,a,t),m=h;if(c){let x=t.dataIdMap.get(p.dataId).id;x!==o&&(u=p,l=x,m=T.getInnerMostAxes(m.length,u.shape.length))}T.assertAxesAreInnerMostDims("sum",m,u.shape.length);let[f,g]=T.computeOutAndReduceShapes(u.shape,m),y=w.sizeFromShape(g),b=t.makeOutput(f,u.dtype);if(w.sizeFromShape(u.shape)!==0){let x=t.dataIdMap.get(b.dataId).id;eF(l,y,Xe[b.dtype],x)}if(c&&t.disposeData(p.dataId),s){let x=T.expandShapeToKeepDim(b.shape,d);b.shape=x}return b}var Mme={kernelName:vo,backendName:"wasm",setupFunc:Rme,kernelFunc:Dme},Ome=He(So),Lme=He(No),tF;function zme(e){tF=e.wasm.cwrap(hu,null,["number","number","number","number","number","number","array","number","number","number"])}function Pme(e){let{backend:t,inputs:n,attrs:r}=e,{tensor:a,indices:s,updates:i}=n,{}=r,o=t.makeOutput(a.shape,a.dtype);if(w.sizeFromShape(a.shape)===0)return o;let{sliceRank:l,numUpdates:u,sliceSize:p,strides:h,outputSize:d}=gm.calculateShapes(i,s,a.shape),c=t.dataIdMap.get(s.dataId).id,m=t.dataIdMap.get(i.dataId).id,f=t.dataIdMap.get(a.dataId).id,g=new Uint8Array(new Int32Array(h).buffer),y=t.dataIdMap.get(o.dataId).id;return tF(c,m,Xe[i.dtype],l,u,p,g,d,y,f),o}var Bme={kernelName:hu,backendName:"wasm",setupFunc:zme,kernelFunc:Pme},nF;function Wme(e){nF=e.wasm.cwrap(ls,null,["number","array","number","array","number","number"])}function Vme(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,s=n.dataIdMap.get(a.dataId).id,{reps:i}=r,o=new Array(a.shape.length);for(let d=0;d<o.length;d++)o[d]=a.shape[d]*i[d];let l=new Uint8Array(new Int32Array(a.shape).buffer),u=new Uint8Array(new Int32Array(o).buffer),p=n.makeOutput(o,a.dtype),h=n.dataIdMap.get(p.dataId).id;return nF(s,l,a.shape.length,u,o.length,Xe[p.dtype],h),p}var Ume={kernelName:ls,backendName:"wasm",setupFunc:Wme,kernelFunc:Vme},rF;function Gme(e){rF=e.wasm.cwrap(wu,null,["number","array","number","number","number","bool","number","number"])}var Hme=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{k:a,sorted:s}=n,i=t.dataIdMap.get(r.dataId).id,o=new Uint8Array(new Int32Array(r.shape).buffer),l=r.shape.slice();l[l.length-1]=a;let u=t.makeOutput(l,r.dtype),p=t.dataIdMap.get(u.dataId).id,h=t.makeOutput(l,"int32"),d=t.dataIdMap.get(h.dataId).id;return rF(i,o,r.shape.length,Xe[r.dtype],a,s,p,d),[u,h]},jme={kernelName:wu,backendName:"wasm",setupFunc:Gme,kernelFunc:Hme},aF;function qme(e){aF=e.wasm.cwrap(ku,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])}function Kme(e){let{backend:t,inputs:n,attrs:r}=e,{image:a,transforms:s}=n,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[p,h,d,c]=a.shape,[m,f]=u!=null?u:[h,d],g=[p,m,f,c],y=new Uint8Array(new Int32Array(w.computeStrides(a.shape)).buffer),b=new Uint8Array(new Int32Array(w.computeStrides(g)).buffer),x=t.makeOutput(g,a.dtype),v=t.dataIdMap.get(x.dataId).id,I=t.dataIdMap.get(a.dataId).id,N=t.dataIdMap.get(s.dataId).id,C=i==="nearest"?1:2,E;switch(o){case"constant":E=1;break;case"reflect":E=2;break;case"wrap":E=3;break;case"nearest":E=4;break;default:E=1;break}return aF(I,N,s.shape[0]>1,p,m,f,c,d,h,y,a.shape.length-1,b,g.length-1,C,E,l,v),x}var Xme={kernelName:ku,backendName:"wasm",setupFunc:qme,kernelFunc:Kme};function Zme(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t,{outputValues:i,outputShape:o,indices:l}=X0(r.readSync(s.dataId),a,s.shape,s.dtype);return[r.makeOutput(o,s.dtype,void 0,i),r.makeOutput([l.length],"int32",void 0,l)]}var Jme={kernelName:hd,backendName:"wasm",kernelFunc:Zme};function Yme(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a.shape[s],o=a.shape.length,l=new Array(o-1),u=0;for(let c=0;c<o;c++)c!==s&&(l[u++]=a.shape[c]);let p=new Array(i),h=new Array(o).fill(0),d=a.shape.slice();d[s]=1;for(let c=0;c<p.length;c++)h[s]=c,p[c]=ai({inputs:{x:a},attrs:{begin:h,size:d},backend:n});return p.map(({dataId:c,dtype:m})=>({dataId:c,dtype:m,shape:l}))}var Qme={kernelName:Iu,backendName:"wasm",kernelFunc:Yme};function efe(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(0),r}var tfe={kernelName:Su,backendName:"wasm",kernelFunc:efe},nfe=[Lle,zle,Ple,Ble,Vle,Hle,Qle,nue,rue,aue,sue,iue,oue,lue,uue,hue,wue,fue,bue,Nue,Aue,Due,Oue,zue,Pue,Bue,Uue,Gue,que,Zue,Que,npe,spe,ipe,ope,ppe,cpe,gpe,xpe,kpe,Npe,_pe,Ape,Dpe,Lpe,zpe,Wpe,Upe,Gpe,Hpe,jpe,qpe,Kpe,Jpe,Ype,ede,rde,ide,ude,hde,fde,yde,xde,jle,vde,wde,kde,Nde,Cde,Ede,Fde,Dde,Rde,Ode,Lde,Pde,Wde,Gde,qde,Zde,Yde,the,ahe,ohe,phe,che,ghe,xhe,whe,She,Ehe,$he,Fhe,Rhe,Ohe,Phe,Vhe,Ghe,qhe,Xhe,Jhe,RA,tce,ace,oce,uce,dce,hce,cce,mce,kue,yce,vce,Ice,Tce,Ece,Fce,Rce,Dce,Lce,Bce,Uce,Gce,qce,Kce,Xce,Zce,Eue,The,Jce,Qce,nme,sme,ome,ume,hme,mme,fme,gme,bme,wme,Sme,Tme,_me,$me,Fme,Mme,Ome,Lme,Bme,Ume,jme,Xme,Zle,Jme,Qme,tfe];for(let e of nfe)md(e);var cx=G();cx.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch{return!1}});cx.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(cx.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}});var jI=ss(ND()),rfe=ss(TD()),qI=ss(CD()),KI=jI.default||jI,afe=qI.default||qI,sF=class extends Hp{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(iF),mx=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new _c(this,cr())}write(e,t,n){let r={id:this.dataIdNextNumber++};return this.move(r,e,t,n,1),r}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=w.now();return e(),{kernelMs:w.now()-t}}move(e,t,n,r,a){let s=this.dataIdNextNumber++;if(r==="string"){let u=t;this.dataIdMap.set(e,{id:s,stringBytes:u,shape:n,dtype:r,memoryOffset:null,refCount:a});return}let i=w.sizeFromShape(n),o=i*w.bytesPerElement(r),l=this.wasm._malloc(o)>>>0;this.dataIdMap.set(e,{id:s,memoryOffset:l,shape:n,dtype:r,refCount:a}),this.wasm.tfjs.registerTensor(s,i,l),t!=null&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),l)}async read(e){return this.readSync(e)}readSync(e,t,n){let{memoryOffset:r,dtype:a,shape:s,stringBytes:i}=this.dataIdMap.get(e);if(a==="string")return(t==null||t===0)&&(n==null||n>=i.length)?i:i.slice(t,n);t=t||0,n=n||w.sizeFromShape(s);let o=w.bytesPerElement(a),l=this.wasm.HEAPU8.slice(r+t*o,r+n*o);return ofe(l.buffer,a)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);t!=null&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n,r){let a;if(n==null)a=this.write(r!=null?r:null,e,t);else{let s=this.dataIdNextNumber++;a={id:s},this.dataIdMap.set(a,{id:s,memoryOffset:n,shape:e,dtype:t,refCount:1});let i=w.sizeFromShape(e);this.wasm.tfjs.registerTensor(s,i,n)}return{dataId:a,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){let r=this.wasm.HEAPU8.buffer,{memoryOffset:a}=this.dataIdMap.get(n),s=w.sizeFromShape(e);switch(t){case"float32":return new Float32Array(r,a,s);case"int32":return new Int32Array(r,a,s);case"bool":return new Uint8Array(r,a,s);default:throw new Error(`Unknown dtype ${t}`)}}};function sfe(e){return(t,n)=>(w.fetch(e,{credentials:"same-origin"}).then(r=>{r.ok||t.env.a(`failed to load wasm binary file at '${e}'`),r.arrayBuffer().then(a=>{WebAssembly.instantiate(a,t).then(s=>{n(s.instance,s.module)})})}),{})}function XI(e,t,n){if(Nc!=null)return Nc;let r="tfjs-backend-wasm.wasm";return e&&t?r="tfjs-backend-wasm-threaded-simd.wasm":e&&(r="tfjs-backend-wasm-simd.wasm"),wp!=null&&wp[r]!=null?wp[r]:n+r}async function ife(){let[e,t]=await Promise.all([G().getAsync("WASM_HAS_SIMD_SUPPORT"),G().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((n,r)=>{let a={};a.locateFile=(o,l)=>{if(o.endsWith(".worker.js")){let u=rfe.wasmWorkerContents.replace(/\n/g,"\\n"),p=new Blob([u],{type:"application/javascript"});return URL.createObjectURL(p)}return o.endsWith(".wasm")?XI(e,t,yp!=null?yp:l):l+o},g1&&(a.instantiateWasm=sfe(XI(e,t,yp!=null?yp:"")));let s=!1;a.onAbort=()=>{s||kp||(kp=!0,r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))};let i;t&&e&&Nc==null?(a.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+KI.toString()],{type:"text/javascript"}),i=KI(a)):i=afe(a),i.then(o=>{s=!0,kp=!1;let l=null;o.tfjs={init:o.cwrap("init",null,[]),initWithThreadsCount:o.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:o.cwrap("get_threads_count","number",[]),registerTensor:o.cwrap("register_tensor",null,["number","number","number"]),disposeData:o.cwrap("dispose_data",l,["number"]),dispose:o.cwrap("dispose",l,[])},n({wasm:o})}).catch(r)})}function ofe(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}var lfe=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],Nc=null,yp=null,wp={},kp=!1,g1=!1;function ufe(e,t=!1){if(Dx("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),kp)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");Nc=e,g1=t}function pfe(e,t=!1){if(kp)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof e=="string")yp=e;else{wp=e;let n=lfe.filter(r=>wp[r]==null);if(n.length>0)throw new Error(`There were no entries found for the following binaries: ${n.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}g1=t}var iF=-1,mx=-1;function dfe(e){iF=e}function hfe(){if(mx===-1)throw new Error("WASM backend not initialized.");return mx}var cfe="4.22.0",mfe=2;jc("wasm",async()=>{let{wasm:e}=await ife();return new sF(e)},mfe);var ZI="4.22.0",ffe="4.22.0",gfe="4.22.0",yfe="4.22.0",bfe="4.22.0",xfe={tfjs:ZI,"tfjs-core":ZI,"tfjs-converter":ffe,"tfjs-backend-cpu":gfe,"tfjs-backend-webgl":yfe,"tfjs-backend-wasm":bfe},oF={};Ix(oF,{AnchorPosition:()=>SF,DrawBox:()=>CF,DrawBoxOptions:()=>TF,DrawFaceLandmarks:()=>jF,DrawFaceLandmarksOptions:()=>HF,DrawTextField:()=>S1,DrawTextFieldOptions:()=>I1,drawContour:()=>Fa,drawDetections:()=>$fe,drawFaceExpressions:()=>Bfe,drawFaceLandmarks:()=>Vfe});function Fa(e,t,n=!1){if(e.beginPath(),t.slice(1).forEach(({x:r,y:a},s)=>{let i=t[s];e.moveTo(i.x,i.y),e.lineTo(r,a)}),n){let r=t[t.length-1],a=t[0];if(!r||!a)return;e.moveTo(r.x,r.y),e.lineTo(a.x,a.y)}e.stroke()}var lF={};Ix(lF,{computeReshapedDimensions:()=>hF,getCenterPoint:()=>nf,isDimensions:()=>gx,isEven:()=>fx,isFloat:()=>dF,isTensor:()=>ju,isTensor1D:()=>vfe,isTensor2D:()=>pF,isTensor3D:()=>qd,isTensor4D:()=>da,isValidNumber:()=>Ga,isValidProbablitiy:()=>Tc,range:()=>wl,round:()=>tf});var Ua=class uF{constructor(t,n){if(!Ga(t)||!Ga(n))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:t,height:n})}`);this._width=t,this._height=n}get width(){return this._width}get height(){return this._height}reverse(){return new uF(1/this.width,1/this.height)}};function ju(e,t){return e instanceof Re&&e.shape.length===t}function vfe(e){return ju(e,1)}function pF(e){return ju(e,2)}function qd(e){return ju(e,3)}function da(e){return ju(e,4)}function dF(e){return e%1!==0}function fx(e){return e%2===0}function tf(e,t=2){let n=10**t;return Math.floor(e*n)/n}function gx(e){return e&&e.width&&e.height}function hF({width:e,height:t},n){let r=n/Math.max(t,e);return new Ua(Math.round(e*r),Math.round(t*r))}function nf(e){return e.reduce((t,n)=>t.add(n),new tt(0,0)).div(new tt(e.length,e.length))}function wl(e,t,n){return Array(e).fill(0).map((r,a)=>t+a*n)}function Ga(e){return!!e&&e!==1/0&&e!==-1/0&&!Number.isNaN(e)||e===0}function Tc(e){return Ga(e)&&e>=0&&e<=1}var tt=class Es{constructor(t,n){this._x=t,this._y=n}get x(){return this._x}get y(){return this._y}add(t){return new Es(this.x+t.x,this.y+t.y)}sub(t){return new Es(this.x-t.x,this.y-t.y)}mul(t){return new Es(this.x*t.x,this.y*t.y)}div(t){return new Es(this.x/t.x,this.y/t.y)}abs(){return new Es(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new Es(Math.floor(this.x),Math.floor(this.y))}},Zr=class kr{static isRect(t){return!!t&&[t.x,t.y,t.width,t.height].every(Ga)}static assertIsValidBox(t,n,r=!1){if(!kr.isRect(t))throw new Error(`${n} - invalid box: ${JSON.stringify(t)}, expected object with properties x, y, width, height`);if(!r&&(t.width<0||t.height<0))throw new Error(`${n} - width (${t.width}) and height (${t.height}) must be positive numbers`)}constructor(t,n=!0){let r=t||{},a=[r.left,r.top,r.right,r.bottom].every(Ga),s=[r.x,r.y,r.width,r.height].every(Ga);if(!s&&!a)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(r)}`);let[i,o,l,u]=s?[r.x,r.y,r.width,r.height]:[r.left,r.top,r.right-r.left,r.bottom-r.top];kr.assertIsValidBox({x:i,y:o,width:l,height:u},"Box.constructor",n),this._x=i,this._y=o,this._width=l,this._height=u}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new tt(this.left,this.top)}get topRight(){return new tt(this.right,this.top)}get bottomLeft(){return new tt(this.left,this.bottom)}get bottomRight(){return new tt(this.right,this.bottom)}round(){let[t,n,r,a]=[this.x,this.y,this.width,this.height].map(s=>Math.round(s));return new kr({x:t,y:n,width:r,height:a})}floor(){let[t,n,r,a]=[this.x,this.y,this.width,this.height].map(s=>Math.floor(s));return new kr({x:t,y:n,width:r,height:a})}toSquare(){let{x:t,y:n,width:r,height:a}=this,s=Math.abs(r-a);return r<a&&(t-=s/2,r+=s),a<r&&(n-=s/2,a+=s),new kr({x:t,y:n,width:r,height:a})}rescale(t){let n=gx(t)?t.width:t,r=gx(t)?t.height:t;return new kr({x:this.x*n,y:this.y*r,width:this.width*n,height:this.height*r})}pad(t,n){let[r,a,s,i]=[this.x-t/2,this.y-n/2,this.width+t,this.height+n];return new kr({x:r,y:a,width:s,height:i})}clipAtImageBorders(t,n){let{x:r,y:a,right:s,bottom:i}=this,o=Math.max(r,0),l=Math.max(a,0),u=s-o,p=i-l,h=Math.min(u,t-o),d=Math.min(p,n-l);return new kr({x:o,y:l,width:h,height:d}).floor()}shift(t,n){let{width:r,height:a}=this,s=this.x+t,i=this.y+n;return new kr({x:s,y:i,width:r,height:a})}padAtBorders(t,n){let r=this.width+1,a=this.height+1,s=1,i=1,o=r,l=a,u=this.left,p=this.top,h=this.right,d=this.bottom;return h>n&&(o=-h+n+r,h=n),d>t&&(l=-d+t+a,d=t),u<1&&(l=2-u,u=1),p<1&&(l=2-p,p=1),{dy:i,edy:l,dx:s,edx:o,y:p,ey:d,x:u,ex:h,w:r,h:a}}calibrate(t){return new kr({left:this.left+t.left*this.width,top:this.top+t.top*this.height,right:this.right+t.right*this.width,bottom:this.bottom+t.bottom*this.height}).toSquare().round()}},y1=class extends Zr{constructor(e,t,n,r,a=!1){super({left:e,top:t,right:n,bottom:r},a)}},b1=class cF{constructor(t,n,r,a,s){this._imageDims=new Ua(s.width,s.height),this._score=t,this._classScore=n,this._className=r,this._box=new Zr(a).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new Zr(this._box).rescale(this.imageDims.reverse())}forSize(t,n){return new cF(this.score,this.classScore,this.className,this.relativeBox,{width:t,height:n})}},lr=class mF extends b1{constructor(t,n,r){super(t,t,"",n,r)}forSize(t,n){let{score:r,relativeBox:a,imageDims:s}=super.forSize(t,n);return new mF(r,a,s)}};function fF(e,t,n=!0){let r=Math.max(0,Math.min(e.right,t.right)-Math.max(e.left,t.left)),a=Math.max(0,Math.min(e.bottom,t.bottom)-Math.max(e.top,t.top)),s=r*a;return n?s/(e.area+t.area-s):s/Math.min(e.area,t.area)}function gF(e){let t=e.map(o=>o.x),n=e.map(o=>o.y),r=t.reduce((o,l)=>l<o?l:o,1/0),a=n.reduce((o,l)=>l<o?l:o,1/0),s=t.reduce((o,l)=>o<l?l:o,0),i=n.reduce((o,l)=>o<l?l:o,0);return new y1(r,a,s,i)}function yF(e,t,n,r=!0){let a=t.map((i,o)=>({score:i,boxIndex:o})).sort((i,o)=>i.score-o.score).map(i=>i.boxIndex),s=[];for(;a.length>0;){let i=a.pop();s.push(i);let o=a,l=[];for(let u=0;u<o.length;u++){let p=o[u],h=e[i],d=e[p];l.push(fF(h,d,r))}a=a.filter((u,p)=>l[p]<=n)}return s}function qu(e,t){return B(()=>{let[n,r,a]=t,s=Un([...e.shape.slice(0,3),1],n,"float32"),i=Un([...e.shape.slice(0,3),1],r,"float32"),o=Un([...e.shape.slice(0,3),1],a,"float32"),l=ot([s,i,o],3);return he(e,l)})}function bF(e,t=!1){return B(()=>{let[n,r]=e.shape.slice(1);if(n===r)return e;let a=Math.abs(n-r),s=Math.round(a*(t?.5:1)),i=n>r?2:1,o=h=>{let d=e.shape.slice();return d[i]=h,Un(d,0,"float32")},l=o(s),u=a-l.shape[i],p=[t&&u?o(u):null,e,l].filter(h=>!!h).map(h=>oe(h,"float32"));return ot(p,i)})}function wfe(e){let t=e.slice();for(let n=t.length-1;n>0;n--){let r=Math.floor(Math.random()*(n+1)),a=t[n];t[n]=t[r],t[r]=a}return t}function Zh(e){return 1/(1+Math.exp(-e))}function kfe(e){return Math.log(e/(1-e))}var x1=class extends Zr{constructor(e,t,n,r,a=!1){super({x:e,y:t,width:n,height:r},a)}},Ife=.5,Sfe=.43,Nfe=.45,si=class{constructor(e,t,n=new tt(0,0)){let{width:r,height:a}=t;this._imgDims=new Ua(r,a),this._shift=n,this._positions=e.map(s=>s.mul(new tt(r,a)).add(n))}get shift(){return new tt(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map(e=>e.sub(this._shift).div(new tt(this.imageWidth,this.imageHeight)))}forSize(e,t){return new this.constructor(this.relativePositions,{width:e,height:t})}shiftBy(e,t){return new this.constructor(this.relativePositions,this._imgDims,new tt(e,t))}shiftByPoint(e){return this.shiftBy(e.x,e.y)}align(e,t={}){if(e){let a=e instanceof lr?e.box.floor():new Zr(e);return this.shiftBy(a.x,a.y).align(null,t)}let{useDlibAlignment:n,minBoxPadding:r}={useDlibAlignment:!1,minBoxPadding:.2,...t};return n?this.alignDlib():this.alignMinBbox(r)}alignDlib(){let e=this.getRefPointsForAlignment(),[t,n,r]=e,a=p=>r.sub(p).magnitude(),s=(a(t)+a(n))/2,i=Math.floor(s/Nfe),o=nf(e),l=Math.floor(Math.max(0,o.x-Ife*i)),u=Math.floor(Math.max(0,o.y-Sfe*i));return new x1(l,u,Math.min(i,this.imageWidth+l),Math.min(i,this.imageHeight+u))}alignMinBbox(e){let t=gF(this.positions);return t.pad(t.width*e,t.height*e)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}},Tfe=class extends si{getRefPointsForAlignment(){let e=this.positions;return[e[0],e[1],nf([e[3],e[4]])]}},v1=class extends si{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(nf)}},yx=class{constructor(e,t){this._label=e,this._distance=t}get label(){return this._label}get distance(){return this._distance}toString(e=!0){return`${this.label}${e?` (${tf(this.distance)})`:""}`}},bx=class extends Zr{static assertIsValidLabeledBox(e,t){if(Zr.assertIsValidBox(e,t),!Ga(e.label))throw new Error(`${t} - expected property label (${e.label}) to be a number`)}constructor(e,t){super(e),this._label=t}get label(){return this._label}},bp=class xF{constructor(t,n){if(typeof t!="string")throw new Error("LabeledFaceDescriptors - constructor expected label to be a string");if(!Array.isArray(n)||n.some(r=>!(r instanceof Float32Array)))throw new Error("LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array");this._label=t,this._descriptors=n}get label(){return this._label}get descriptors(){return this._descriptors}toJSON(){return{label:this.label,descriptors:this.descriptors.map(t=>Array.from(t))}}static fromJSON(t){let n=t.descriptors.map(r=>new Float32Array(r));return new xF(t.label,n)}},Cfe=class extends bx{static assertIsValidPredictedBox(e,t){if(bx.assertIsValidLabeledBox(e,t),!Tc(e.score)||!Tc(e.classScore))throw new Error(`${t} - expected properties score (${e.score}) and (${e.classScore}) to be a number between [0, 1]`)}constructor(e,t,n,r){super(e,t),this._score=n,this._classScore=r}get score(){return this._score}get classScore(){return this._classScore}};function kl(e){return e.detection instanceof lr}function Vp(e,t){return{...e,detection:t}}function vF(){let e=window.fetch;if(!e)throw new Error("fetch - missing fetch implementation for browser environment");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D,Image:HTMLImageElement,ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),createVideoElement:()=>document.createElement("video"),fetch:e,readFile:()=>{throw new Error("readFile - filesystem not available for browser environment")}}}function w1(){return typeof global=="object"&&typeof process!="undefined"&&process.versions!=null&&process.versions.node!=null}function wF(e){let t="";if(!e&&w1())try{e=aD("fs")}catch(n){t=n.toString()}return{readFile:e?n=>new Promise((r,a)=>{e.readFile(n,(s,i)=>s?a(s):r(i))}):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${t}`)}}}function kF(){let e=global.Canvas||global.HTMLCanvasElement,t=global.Image||global.HTMLImageElement,n=global.Video||global.HTMLVideoElement,r=()=>{if(e)return new e;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},a=()=>{if(t)return new t;throw new Error("createImageElement - missing Image implementation for nodejs environment")},s=()=>{if(n)return new n;throw new Error("createVideoElement - missing Video implementation for nodejs environment")},i=global.fetch,o=wF();return{Canvas:e||class{},CanvasRenderingContext2D:global.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:global.ImageData||class{},Video:global.HTMLVideoElement||class{},createCanvasElement:r,createImageElement:a,createVideoElement:s,fetch:i,...o}}function IF(){return typeof window=="object"&&typeof document!="undefined"&&typeof HTMLImageElement!="undefined"&&typeof HTMLCanvasElement!="undefined"&&typeof HTMLVideoElement!="undefined"&&typeof ImageData!="undefined"&&typeof CanvasRenderingContext2D!="undefined"}var Ht;function _fe(){if(!Ht)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return Ht}function xx(e){Ht=e}function k1(){return IF()?xx(vF()):w1()?xx(kF()):null}function Efe(e){if(Ht||k1(),!Ht)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:t=Ht.Canvas,Image:n=Ht.Image}=e;Ht.Canvas=t,Ht.Image=n,Ht.createCanvasElement=e.createCanvasElement||(()=>new t),Ht.createImageElement=e.createImageElement||(()=>new n),Ht.ImageData=e.ImageData||Ht.ImageData,Ht.Video=e.Video||Ht.Video,Ht.fetch=e.fetch||Ht.fetch,Ht.readFile=e.readFile||Ht.readFile}var sn={getEnv:_fe,setEnv:xx,initialize:k1,createBrowserEnv:vF,createFileSystem:wF,createNodejsEnv:kF,monkeyPatch:Efe,isBrowser:IF,isNodejs:w1};k1();function rf(e){return!sn.isNodejs()&&typeof e=="string"?document.getElementById(e):e}function ma(e){let{Canvas:t,CanvasRenderingContext2D:n}=sn.getEnv();if(e instanceof n)return e;let r=rf(e);if(!(r instanceof t))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let a=r.getContext("2d",{willReadFrequently:!0});if(!a)throw new Error("resolveContext2d - canvas 2d context is null");return a}var SF=(e=>(e.TOP_LEFT="TOP_LEFT",e.TOP_RIGHT="TOP_RIGHT",e.BOTTOM_LEFT="BOTTOM_LEFT",e.BOTTOM_RIGHT="BOTTOM_RIGHT",e))(SF||{}),I1=class{constructor(e={}){let{anchorPosition:t,backgroundColor:n,fontColor:r,fontSize:a,fontStyle:s,padding:i}=e;this.anchorPosition=t||"TOP_LEFT",this.backgroundColor=n||"rgba(0, 0, 0, 0.5)",this.fontColor=r||"rgba(255, 255, 255, 1)",this.fontSize=a||14,this.fontStyle=s||"Georgia",this.padding=i||4}},S1=class NF{constructor(t,n,r={}){this.text=typeof t=="string"?[t]:t instanceof NF?t.text:t,this.anchor=n,this.options=new I1(r)}measureWidth(t){let{padding:n}=this.options;return this.text.map(r=>t.measureText(r).width).reduce((r,a)=>r<a?a:r,0)+2*n}measureHeight(){let{fontSize:t,padding:n}=this.options;return this.text.length*t+2*n}getUpperLeft(t,n){let{anchorPosition:r}=this.options,a=r==="BOTTOM_RIGHT"||r==="TOP_RIGHT",s=r==="BOTTOM_LEFT"||r==="BOTTOM_RIGHT",i=this.measureWidth(t),o=this.measureHeight(),l=a?this.anchor.x-i:this.anchor.x,u=s?this.anchor.y-o:this.anchor.y;if(n){let{width:p,height:h}=n,d=Math.max(Math.min(l,p-i),0),c=Math.max(Math.min(u,h-o),0);return{x:d,y:c}}return{x:l,y:u}}draw(t){let n=rf(t),r=ma(n),{backgroundColor:a,fontColor:s,fontSize:i,fontStyle:o,padding:l}=this.options;r.font=`${i}px ${o}`;let u=this.measureWidth(r),p=this.measureHeight();r.fillStyle=a;let h=this.getUpperLeft(r,n);r.fillRect(h.x,h.y,u,p),r.fillStyle=s,this.text.forEach((d,c)=>{let m=l+h.x,f=l+h.y+(c+1)*i;r.fillText(d,m,f)})}},TF=class{constructor(e={}){let{boxColor:t,lineWidth:n,label:r,drawLabelOptions:a}=e;this.boxColor=t||"rgba(0, 0, 255, 1)",this.lineWidth=n||2,this.label=r;let s={anchorPosition:"BOTTOM_LEFT",backgroundColor:this.boxColor};this.drawLabelOptions=new I1({...s,...a})}},CF=class{constructor(e,t={}){this.box=new Zr(e),this.options=new TF(t)}draw(e){let t=ma(e),{boxColor:n,lineWidth:r}=this.options,{x:a,y:s,width:i,height:o}=this.box;t.strokeStyle=n,t.lineWidth=r,t.strokeRect(a,s,i,o);let{label:l}=this.options;l&&new S1([l],{x:a-r/2,y:s},this.options.drawLabelOptions).draw(e)}};function $fe(e,t){(Array.isArray(t)?t:[t]).forEach(n=>{let r=n instanceof lr?n.score:kl(n)?n.detection.score:void 0,a=n instanceof lr?n.box:kl(n)?n.detection.box:new Zr(n),s=r?`${tf(r)}`:void 0;new CF(a,{label:s}).draw(e)})}function N1(e){let{Image:t,Video:n}=sn.getEnv();return e instanceof t&&e.complete||e instanceof n&&e.readyState>=3}function _F(e){return new Promise((t,n)=>{if(e instanceof sn.getEnv().Canvas||N1(e)){t(null);return}function r(s){s.currentTarget&&(s.currentTarget.removeEventListener("load",a),s.currentTarget.removeEventListener("error",r),n(s))}function a(s){s.currentTarget&&(s.currentTarget.removeEventListener("load",a),s.currentTarget.removeEventListener("error",r),t(s))}e.addEventListener("load",a),e.addEventListener("error",r)})}function EF(e){return new Promise((t,n)=>{e instanceof Blob||n(new Error("bufferToImage - expected buf to be of type: Blob"));let r=new FileReader;r.onload=()=>{typeof r.result!="string"&&n(new Error("bufferToImage - expected reader.result to be a string, in onload"));let a=sn.getEnv().createImageElement();a.onload=()=>t(a),a.onerror=n,a.src=r.result},r.onerror=n,r.readAsDataURL(e)})}function af(e){let{Image:t,Video:n}=sn.getEnv();return e instanceof t?new Ua(e.naturalWidth,e.naturalHeight):e instanceof n?new Ua(e.videoWidth,e.videoHeight):new Ua(e.width,e.height)}function Up({width:e,height:t}){let{createCanvasElement:n}=sn.getEnv(),r=n();return r.width=e,r.height=t,r}function T1(e,t){let{ImageData:n}=sn.getEnv();if(!(e instanceof n)&&!N1(e))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:r,height:a}=t||af(e),s=Up({width:r,height:a});return e instanceof n?ma(s).putImageData(e,0,0):ma(s).drawImage(e,0,0,r,a),s}async function $F(e,t){let n=t||sn.getEnv().createCanvasElement(),[r,a,s]=e.shape.slice(da(e)?1:0),i=B(()=>e.as3D(r,a,s).toInt());return await Rd.toPixels(i,n),i.dispose(),n}function vx(e){let{Image:t,Canvas:n,Video:r}=sn.getEnv();return e instanceof t||e instanceof n||e instanceof r}function AF(e,t,n=!1){let{Image:r,Canvas:a}=sn.getEnv();if(!(e instanceof r||e instanceof a))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");if(t<=0)return Up({width:1,height:1});let s=af(e),i=t/Math.max(s.height,s.width),o=i*s.width,l=i*s.height,u=Up({width:t,height:t}),p=e instanceof a?e:T1(e),h=Math.abs(o-l)/2,d=n&&o<l?h:0,c=n&&l<o?h:0;return p.width>0&&p.height>0&&ma(u).drawImage(p,d,c,o,l),u}var Gp=class{constructor(e,t=!1){if(this._imageTensors=[],this._canvases=[],this._treatAsBatchInput=!1,this._inputDimensions=[],this._inputSize=0,!Array.isArray(e))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${e}`);this._treatAsBatchInput=t,this._batchSize=e.length,e.forEach((n,r)=>{if(qd(n)){this._imageTensors[r]=n,this._inputDimensions[r]=n.shape;return}if(da(n)){let s=n.shape[0];if(s!==1)throw new Error(`NetInput - tf.Tensor4D with batchSize ${s} passed, but not supported in input array`);this._imageTensors[r]=n,this._inputDimensions[r]=n.shape.slice(1);return}let a=n instanceof sn.getEnv().Canvas?n:T1(n);this._canvases[r]=a,this._inputDimensions[r]=[a.height,a.width,3]})}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return wl(this.batchSize,0,1).map((e,t)=>this.getReshapedInputDimensions(t))}getInput(e){return this.canvases[e]||this.imageTensors[e]}getInputDimensions(e){return this._inputDimensions[e]}getInputHeight(e){return this._inputDimensions[e][0]}getInputWidth(e){return this._inputDimensions[e][1]}getReshapedInputDimensions(e){if(typeof this.inputSize!="number")throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");let t=this.getInputWidth(e),n=this.getInputHeight(e);return hF({width:t,height:n},this.inputSize)}toBatchTensor(e,t=!0){return this._inputSize=e,B(()=>{let n=wl(this.batchSize,0,1).map(r=>{let a=this.getInput(r);if(a instanceof Re){let s=da(a)?a:Xt(a);return s=bF(s,t),(s.shape[1]!==e||s.shape[2]!==e)&&(s=er.resizeBilinear(s,[e,e],!1,!1)),s.as3D(e,e,3)}if(a instanceof sn.getEnv().Canvas)return Rd.fromPixels(AF(a,e,t));throw new Error(`toBatchTensor - at batchIdx ${r}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${a}`)});return Dt(n.map(r=>oe(r,"float32"))).as4D(this.batchSize,e,e,3)})}};async function dn(e){if(e instanceof Gp)return e;let t=Array.isArray(e)?e:[e];if(!t.length)throw new Error("toNetInput - empty array passed as input");let n=a=>Array.isArray(e)?` at input index ${a}:`:"",r=t.map(rf);return r.forEach((a,s)=>{if(!vx(a)&&!qd(a)&&!da(a))throw typeof t[s]=="string"?new Error(`toNetInput -${n(s)} string passed, but could not resolve HTMLElement for element id ${t[s]}`):new Error(`toNetInput -${n(s)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(da(a)){let i=a.shape[0];if(i!==1)throw new Error(`toNetInput -${n(s)} tf.Tensor4D with batchSize ${i} passed, but not supported in input array`)}}),await Promise.all(r.map(a=>vx(a)&&_F(a))),new Gp(r,Array.isArray(e))}async function sf(e,t){let{Canvas:n}=sn.getEnv(),r=e;if(!(e instanceof n)){let s=await dn(e);if(s.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let i=s.getInput(0);r=i instanceof n?i:await $F(i)}let a=ma(r);return t.map(s=>s instanceof lr?s.forSize(r.width,r.height).box.floor():s).map(s=>s.clipAtImageBorders(r.width,r.height)).map(({x:s,y:i,width:o,height:l})=>{let u=Up({width:o,height:l});return o>0&&l>0&&ma(u).putImageData(a.getImageData(s,i,o,l),0,0),u})}async function of(e,t){if(!qd(e)&&!da(e))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(da(e)&&e.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return B(()=>{let[n,r,a]=e.shape.slice(da(e)?1:0);return t.map(s=>s instanceof lr?s.forSize(r,n).box:s).map(s=>s.clipAtImageBorders(r,n)).filter(s=>s.width>0&&s.height>0).map(({x:s,y:i,width:o,height:l})=>Fu(e.as3D(n,r,a),[i,s,0],[l,o,a]))})}async function Kd(e,t){let{fetch:n}=sn.getEnv(),r=await n(e,t);if(!(r.status<400))throw new Error(`failed to fetch: (${r.status}) ${r.statusText}, from url: ${r.url}`);return r}async function Afe(e){let t=await Kd(e),n=await t.blob();if(!n.type.startsWith("image/"))throw new Error(`fetchImage - expected blob type to be of type image/*, instead have: ${n.type}, for url: ${t.url}`);return EF(n)}async function FF(e){return(await Kd(e)).json()}async function Ffe(e){return new Float32Array(await(await Kd(e)).arrayBuffer())}function Rfe(e){return new Promise((t,n)=>{e instanceof Blob||n(new Error("bufferToVideo - expected buf to be of type: Blob"));let r=sn.getEnv().createVideoElement();r.oncanplay=()=>t(r),r.onerror=n,r.playsInline=!0,r.muted=!0,r.src=URL.createObjectURL(e),r.play()})}async function Dfe(e){let t=await Kd(e),n=await t.blob();if(!n.type.startsWith("video/"))throw new Error(`fetchVideo - expected blob type to be of type video/*, instead have: ${n.type}, for url: ${t.url}`);return Rfe(n)}function RF(e,t){let n=`${t}-weights_manifest.json`;if(!e)return{modelBaseUri:"",manifestUri:n};if(e==="/")return{modelBaseUri:"/",manifestUri:`/${n}`};let r=e.startsWith("http://")?"http://":e.startsWith("https://")?"https://":"";e=e.replace(r,"");let a=e.split("/").filter(o=>o),s=e.endsWith(".json")?a[a.length-1]:n,i=r+(e.endsWith(".json")?a.slice(0,a.length-1):a).join("/");return i=e.startsWith("/")?`/${i}`:i,{modelBaseUri:i,manifestUri:i==="/"?`/${s}`:`${i}/${s}`}}async function DF(e,t){let{manifestUri:n,modelBaseUri:r}=RF(e,t),a=await FF(n);return an.loadWeights(a,r)}function Mfe(e,t,n=!1){let{width:r,height:a}=n?af(t):t;return e.width=r,e.height=a,{width:r,height:a}}var Ia=class{constructor(e){this._params=void 0,this._paramMappings=[],this._name=e}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(e){let{obj:t,objProp:n}=this.traversePropertyPath(e);return t[n]}reassignParamFromPath(e,t){let{obj:n,objProp:r}=this.traversePropertyPath(e);n[r].dispose(),n[r]=t}getParamList(){return this._paramMappings.map(({paramPath:e})=>({path:e,tensor:this.getParamFromPath(e)}))}getTrainableParams(){return this.getParamList().filter(e=>e.tensor instanceof Us)}getFrozenParams(){return this.getParamList().filter(e=>!(e.tensor instanceof Us))}variable(){this.getFrozenParams().forEach(({path:e,tensor:t})=>{this.reassignParamFromPath(e,t.variable())})}freeze(){this.getTrainableParams().forEach(({path:e,tensor:t})=>{let n=yn(t.dataSync());t.dispose(),this.reassignParamFromPath(e,n)})}dispose(e=!0){this.getParamList().forEach(t=>{if(e&&t.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${t.path}`);t.tensor.dispose()}),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map(({tensor:e})=>Array.from(e.dataSync())).reduce((e,t)=>e.concat(t)))}async load(e){if(e instanceof Float32Array){this.extractWeights(e);return}await this.loadFromUri(e)}async loadFromUri(e){if(e&&typeof e!="string")throw new Error(`${this._name}.loadFromUri - expected model uri`);let t=await DF(e,this.getDefaultModelName());this.loadFromWeightMap(t)}async loadFromDisk(e){if(e&&typeof e!="string")throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:t}=sn.getEnv(),{manifestUri:n,modelBaseUri:r}=RF(e,this.getDefaultModelName()),a=l=>Promise.all(l.map(u=>t(u).then(p=>typeof p=="string"?Buffer.from(p):p.buffer))),s=an.weightsLoaderFactory(a),i=JSON.parse((await t(n)).toString()),o=await s(i,r);this.loadFromWeightMap(o)}loadFromWeightMap(e){let{paramMappings:t,params:n}=this.extractParamsFromWeightMap(e);this._paramMappings=t,this._params=n}extractWeights(e){let{paramMappings:t,params:n}=this.extractParams(e);this._paramMappings=t,this._params=n}traversePropertyPath(e){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let t=e.split("/").reduce((a,s)=>{if(!a.nextObj.hasOwnProperty(s))throw new Error(`traversePropertyPath - object does not have property ${s}, for path ${e}`);return{obj:a.nextObj,objProp:s,nextObj:a.nextObj[s]}},{nextObj:this.params}),{obj:n,objProp:r}=t;if(!n||!r||!(n[r]instanceof Re))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${e}`);return{obj:n,objProp:r}}};function rr(e,t,n){return B(()=>{let r=Au(e,t.depthwise_filter,t.pointwise_filter,n,"same");return r=Z(r,t.bias),r})}function db(e,t,n=!1){return B(()=>{let r=nt(n?Z(bn(e,t.conv0.filters,[2,2],"same"),t.conv0.bias):rr(e,t.conv0,[2,2])),a=rr(r,t.conv1,[1,1]),s=nt(Z(r,a)),i=rr(s,t.conv2,[1,1]);return nt(Z(r,Z(a,i)))})}function zh(e,t,n=!1,r=!0){return B(()=>{let a=nt(n?Z(bn(e,t.conv0.filters,r?[2,2]:[1,1],"same"),t.conv0.bias):rr(e,t.conv0,r?[2,2]:[1,1])),s=rr(a,t.conv1,[1,1]),i=nt(Z(a,s)),o=rr(i,t.conv2,[1,1]),l=nt(Z(a,Z(s,o))),u=rr(l,t.conv3,[1,1]);return nt(Z(a,Z(s,Z(o,u))))})}function Ip(e,t,n="same",r=!1){return B(()=>{let a=Z(bn(e,t.filters,[1,1],n),t.bias);return r?nt(a):a})}function xs(e,t){Object.keys(e).forEach(n=>{t.some(r=>r.originalPath===n)||e[n].dispose()})}function C1(e,t){return(n,r,a,s)=>{let i=Ya(e(n*r*a*a),[a,a,n,r]),o=Qe(e(r));return t.push({paramPath:`${s}/filters`},{paramPath:`${s}/bias`}),{filters:i,bias:o}}}function MF(e,t){return(n,r,a)=>{let s=Gr(e(n*r),[n,r]),i=Qe(e(r));return t.push({paramPath:`${a}/weights`},{paramPath:`${a}/bias`}),{weights:s,bias:i}}}var OF=class{constructor(e,t,n){this.depthwise_filter=e,this.pointwise_filter=t,this.bias=n}};function _1(e,t){return(n,r,a)=>{let s=Ya(e(9*n),[3,3,n,1]),i=Ya(e(n*r),[1,1,n,r]),o=Qe(e(r));return t.push({paramPath:`${a}/depthwise_filter`},{paramPath:`${a}/pointwise_filter`},{paramPath:`${a}/bias`}),new OF(s,i,o)}}function E1(e){return t=>{let n=e(`${t}/depthwise_filter`,4),r=e(`${t}/pointwise_filter`,4),a=e(`${t}/bias`,1);return new OF(n,r,a)}}function Lo(e,t){return(n,r,a)=>{let s=e[n];if(!ju(s,r))throw new Error(`expected weightMap[${n}] to be a Tensor${r}D, instead have ${s}`);return t.push({originalPath:n,paramPath:a||n}),s}}function vs(e){let t=e;function n(a){let s=t.slice(0,a);return t=t.slice(a),s}function r(){return t}return{extractWeights:n,getRemainingWeights:r}}function LF(e,t){let n=C1(e,t),r=_1(e,t);function a(i,o,l,u=!1){let p=u?n(i,o,3,`${l}/conv0`):r(i,o,`${l}/conv0`),h=r(o,o,`${l}/conv1`),d=r(o,o,`${l}/conv2`);return{conv0:p,conv1:h,conv2:d}}function s(i,o,l,u=!1){let{conv0:p,conv1:h,conv2:d}=a(i,o,l,u),c=r(o,o,`${l}/conv3`);return{conv0:p,conv1:h,conv2:d,conv3:c}}return{extractDenseBlock3Params:a,extractDenseBlock4Params:s}}function Ofe(e){let t=[],{extractWeights:n,getRemainingWeights:r}=vs(e),{extractDenseBlock4Params:a}=LF(n,t),s=a(3,32,"dense0",!0),i=a(32,64,"dense1"),o=a(64,128,"dense2"),l=a(128,256,"dense3");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o,dense3:l}}}function zF(e){return t=>{let n=e(`${t}/filters`,4),r=e(`${t}/bias`,1);return{filters:n,bias:r}}}function PF(e,t){let n=Lo(e,t),r=zF(n),a=E1(n);function s(o,l=!1){let u=l?r(`${o}/conv0`):a(`${o}/conv0`),p=a(`${o}/conv1`),h=a(`${o}/conv2`);return{conv0:u,conv1:p,conv2:h}}function i(o,l=!1){let u=l?r(`${o}/conv0`):a(`${o}/conv0`),p=a(`${o}/conv1`),h=a(`${o}/conv2`),d=a(`${o}/conv3`);return{conv0:u,conv1:p,conv2:h,conv3:d}}return{extractDenseBlock3Params:s,extractDenseBlock4Params:i}}function Lfe(e){let t=[],{extractDenseBlock4Params:n}=PF(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2"),dense3:n("dense3")};return xs(e,t),{params:r,paramMappings:t}}var BF=class extends Ia{constructor(){super("FaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceFeatureExtractor - load model before inference");return B(()=>{let n=oe(e.toBatchTensor(112,!0),"float32"),r=qu(n,[122.782,117.001,104.298]).div(255),a=zh(r,t.dense0,!0);return a=zh(a,t.dense1),a=zh(a,t.dense2),a=zh(a,t.dense3),a=ya(a,[7,7],[2,2],"valid"),a})}async forward(e){return this.forwardInput(await dn(e))}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeightMap(e){return Lfe(e)}extractParams(e){return Ofe(e)}};function wx(e,t){return B(()=>Z(De(e,t.weights),t.bias))}function zfe(e,t,n){let r=[],{extractWeights:a,getRemainingWeights:s}=vs(e),i=MF(a,r)(t,n,"fc");if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{paramMappings:r,params:{fc:i}}}function Pfe(e){let t=[],n=Lo(e,t);function r(s){let i=n(`${s}/weights`,2),o=n(`${s}/bias`,1);return{weights:i,bias:o}}let a={fc:r("fc")};return xs(e,t),{params:a,paramMappings:t}}function WF(e){let t={},n={};return Object.keys(e).forEach(r=>{let a=r.startsWith("fc")?n:t;a[r]=e[r]}),{featureExtractorMap:t,classifierMap:n}}var VF=class extends Ia{constructor(e,t){super(e),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return B(()=>{let n=e instanceof Gp?this.faceFeatureExtractor.forwardInput(e):e;return wx(n.as2D(n.shape[0],-1),t.fc)})}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return zfe(e,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=WF(e);return this.faceFeatureExtractor.loadFromWeightMap(t),Pfe(n)}extractParams(e){let t=this.getClassifierChannelsIn(),n=this.getClassifierChannelsOut(),r=n*t+n,a=e.slice(0,e.length-r),s=e.slice(e.length-r);return this.faceFeatureExtractor.extractWeights(a),this.extractClassifierParams(s)}},kx=["neutral","happy","sad","angry","fearful","disgusted","surprised"],lf=class{constructor(e){if(this.neutral=0,this.happy=0,this.sad=0,this.angry=0,this.fearful=0,this.disgusted=0,this.surprised=0,e.length!==7)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${e.length}`);kx.forEach((t,n)=>{this[t]=e[n]})}asSortedArray(){return kx.map(e=>({expression:e,probability:this[e]})).sort((e,t)=>t.probability-e.probability)}},UF=class extends VF{constructor(e=new BF){super("FaceExpressionNet",e)}forwardInput(e){return B(()=>cs(this.runNet(e)))}async forward(e){return this.forwardInput(await dn(e))}async predictExpressions(e){let t=await dn(e),n=await this.forwardInput(t),r=await Promise.all(Tt(n).map(async s=>{let i=s.dataSync();return s.dispose(),i}));n.dispose();let a=r.map(s=>new lf(s));return t.isBatchInput?a:a[0]}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}};function GF(e){return e.expressions instanceof lf}function $1(e,t){return{...e,expressions:t}}function Bfe(e,t,n=.1,r){(Array.isArray(t)?t:[t]).forEach(a=>{let s=a instanceof lf?a:GF(a)?a.expressions:void 0;if(!s)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let i=s.asSortedArray().filter(l=>l.probability>n),o=kl(a)?a.detection.box.bottomLeft:r||new tt(0,0);new S1(i.map(l=>`${l.expression} (${tf(l.probability)})`),o).draw(e)})}function uf(e){return kl(e)&&e.landmarks instanceof si&&e.unshiftedLandmarks instanceof si&&e.alignedRect instanceof lr}function Wfe(e){let t=l=>l*180/Math.PI,n=(l,u)=>Math.sqrt((l.x-u.x)**2+(l.y-u.y)**2),r={roll:void 0,pitch:void 0,yaw:void 0},a=(l,u,p)=>{let h=Math.floor(l.x-u.x),d=Math.floor(u.x-p.x);return h-d},s=(l,u)=>{let p=Math.hypot(u.x-l.x,u.y-l.y),h=u.y-l.y,d=Math.asin(h/p),c=t(d),m=Math.floor(90-c),f=u.x-l.x<0?-1:1;return m*f},i=(l,u,p)=>{let h=n(l,p),d=new tt((l.x+p.x)/2,(l.y+p.y)/2),c=n(u,d),m=Math.atan(c/h),f=Math.floor(t(m)),g=d.y-u.y<0?-1:1;return f*g};if(!e||!e.positions||e.positions.length!==68)return r;let o=e.positions;return r.roll=s(o[27],o[66]),r.pitch=i(o[14],o[30],o[2]),r.yaw=a(o[14],o[33],o[2]),r}function pf(e,t){let{box:n}=e.detection,r=t.shiftBy(n.x,n.y),a=r.align(),{imageDims:s}=e.detection,i=new lr(e.detection.score,a.rescale(s.reverse()),s),o=Wfe(t);return{...e,landmarks:r,unshiftedLandmarks:t,alignedRect:i,angle:o}}var HF=class{constructor(e={}){let{drawLines:t=!0,drawPoints:n=!0,lineWidth:r,lineColor:a,pointSize:s,pointColor:i}=e;this.drawLines=t,this.drawPoints=n,this.lineWidth=r||1,this.pointSize=s||2,this.lineColor=a||"rgba(0, 255, 255, 1)",this.pointColor=i||"rgba(255, 0, 255, 1)"}},jF=class{constructor(e,t={}){this.faceLandmarks=e,this.options=new HF(t)}draw(e){let t=ma(e),{drawLines:n,drawPoints:r,lineWidth:a,lineColor:s,pointSize:i,pointColor:o}=this.options;if(n&&this.faceLandmarks instanceof v1&&(t.strokeStyle=s,t.lineWidth=a,Fa(t,this.faceLandmarks.getJawOutline()),Fa(t,this.faceLandmarks.getLeftEyeBrow()),Fa(t,this.faceLandmarks.getRightEyeBrow()),Fa(t,this.faceLandmarks.getNose()),Fa(t,this.faceLandmarks.getLeftEye(),!0),Fa(t,this.faceLandmarks.getRightEye(),!0),Fa(t,this.faceLandmarks.getMouth(),!0)),r){t.strokeStyle=o,t.fillStyle=o;let l=u=>{t.beginPath(),t.arc(u.x,u.y,i,0,2*Math.PI),t.fill()};this.faceLandmarks.positions.forEach(l)}}};function Vfe(e,t){(Array.isArray(t)?t:[t]).forEach(n=>{let r=n instanceof si?n:uf(n)?n.landmarks:void 0;if(!r)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new jF(r).draw(e)})}var Ufe="1.7.15";function Gfe(e,t){let n=C1(e,t),r=_1(e,t);function a(i,o,l){let u=r(i,o,`${l}/separable_conv0`),p=r(o,o,`${l}/separable_conv1`),h=n(i,o,1,`${l}/expansion_conv`);return{separable_conv0:u,separable_conv1:p,expansion_conv:h}}function s(i,o){let l=r(i,i,`${o}/separable_conv0`),u=r(i,i,`${o}/separable_conv1`),p=r(i,i,`${o}/separable_conv2`);return{separable_conv0:l,separable_conv1:u,separable_conv2:p}}return{extractConvParams:n,extractSeparableConvParams:r,extractReductionBlockParams:a,extractMainBlockParams:s}}function Hfe(e,t){let n=[],{extractWeights:r,getRemainingWeights:a}=vs(e),{extractConvParams:s,extractSeparableConvParams:i,extractReductionBlockParams:o,extractMainBlockParams:l}=Gfe(r,n),u=s(3,32,3,"entry_flow/conv_in"),p=o(32,64,"entry_flow/reduction_block_0"),h=o(64,128,"entry_flow/reduction_block_1"),d={conv_in:u,reduction_block_0:p,reduction_block_1:h},c={};wl(t,0,1).forEach(y=>{c[`main_block_${y}`]=l(128,`middle_flow/main_block_${y}`)});let m=o(128,256,"exit_flow/reduction_block"),f=i(256,512,"exit_flow/separable_conv"),g={reduction_block:m,separable_conv:f};if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:n,params:{entry_flow:d,middle_flow:c,exit_flow:g}}}function jfe(e,t){let n=Lo(e,t),r=zF(n),a=E1(n);function s(o){let l=a(`${o}/separable_conv0`),u=a(`${o}/separable_conv1`),p=r(`${o}/expansion_conv`);return{separable_conv0:l,separable_conv1:u,expansion_conv:p}}function i(o){let l=a(`${o}/separable_conv0`),u=a(`${o}/separable_conv1`),p=a(`${o}/separable_conv2`);return{separable_conv0:l,separable_conv1:u,separable_conv2:p}}return{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:s,extractMainBlockParams:i}}function qfe(e,t){let n=[],{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:s,extractMainBlockParams:i}=jfe(e,n),o=r("entry_flow/conv_in"),l=s("entry_flow/reduction_block_0"),u=s("entry_flow/reduction_block_1"),p={conv_in:o,reduction_block_0:l,reduction_block_1:u},h={};wl(t,0,1).forEach(f=>{h[`main_block_${f}`]=i(`middle_flow/main_block_${f}`)});let d=s("exit_flow/reduction_block"),c=a("exit_flow/separable_conv"),m={reduction_block:d,separable_conv:c};return xs(e,n),{params:{entry_flow:p,middle_flow:h,exit_flow:m},paramMappings:n}}function qF(e,t,n){return Z(bn(e,t.filters,n,"same"),t.bias)}function hb(e,t,n=!0){let r=n?nt(e):e;return r=rr(r,t.separable_conv0,[1,1]),r=rr(nt(r),t.separable_conv1,[1,1]),r=jt(r,[3,3],[2,2],"same"),r=Z(r,qF(e,t.expansion_conv,[2,2])),r}function Kfe(e,t){let n=rr(nt(e),t.separable_conv0,[1,1]);return n=rr(nt(n),t.separable_conv1,[1,1]),n=rr(nt(n),t.separable_conv2,[1,1]),n=Z(n,e),n}var Xfe=class extends Ia{constructor(e){super("TinyXception"),this._numMainBlocks=e}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyXception - load model before inference");return B(()=>{let n=oe(e.toBatchTensor(112,!0),"float32"),r=qu(n,[122.782,117.001,104.298]).div(255),a=nt(qF(r,t.entry_flow.conv_in,[2,2]));return a=hb(a,t.entry_flow.reduction_block_0,!1),a=hb(a,t.entry_flow.reduction_block_1),wl(this._numMainBlocks,0,1).forEach(s=>{a=Kfe(a,t.middle_flow[`main_block_${s}`])}),a=hb(a,t.exit_flow.reduction_block),a=nt(rr(a,t.exit_flow.separable_conv,[1,1])),a})}async forward(e){return this.forwardInput(await dn(e))}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeightMap(e){return qfe(e,this._numMainBlocks)}extractParams(e){return Hfe(e,this._numMainBlocks)}};function Zfe(e){let t=[],{extractWeights:n,getRemainingWeights:r}=vs(e),a=MF(n,t),s=a(512,1,"fc/age"),i=a(512,2,"fc/gender");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{fc:{age:s,gender:i}}}}function Jfe(e){let t=[],n=Lo(e,t);function r(s){let i=n(`${s}/weights`,2),o=n(`${s}/bias`,1);return{weights:i,bias:o}}let a={fc:{age:r("fc/age"),gender:r("fc/gender")}};return xs(e,t),{params:a,paramMappings:t}}var KF=(e=>(e.FEMALE="female",e.MALE="male",e))(KF||{}),XF=class extends Ia{constructor(e=new Xfe(2)){super("AgeGenderNet"),this._faceFeatureExtractor=e}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return B(()=>{let n=e instanceof Gp?this.faceFeatureExtractor.forwardInput(e):e,r=ya(n,[7,7],[2,2],"valid").as2D(n.shape[0],-1),a=wx(r,t.fc.age).as1D(),s=wx(r,t.fc.gender);return{age:a,gender:s}})}forwardInput(e){return B(()=>{let{age:t,gender:n}=this.runNet(e);return{age:t,gender:cs(n)}})}async forward(e){return this.forwardInput(await dn(e))}async predictAgeAndGender(e){let t=await dn(e),n=await this.forwardInput(t),r=Tt(n.age),a=Tt(n.gender),s=r.map((o,l)=>({ageTensor:o,genderTensor:a[l]})),i=await Promise.all(s.map(async({ageTensor:o,genderTensor:l})=>{let u=o.dataSync()[0],p=l.dataSync()[0],h=p>.5,d=h?"male":"female",c=h?p:1-p;return o.dispose(),l.dispose(),{age:u,gender:d,genderProbability:c}}));return n.age.dispose(),n.gender.dispose(),t.isBatchInput?i:i[0]}getDefaultModelName(){return"age_gender_model"}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return Zfe(e)}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=WF(e);return this.faceFeatureExtractor.loadFromWeightMap(t),Jfe(n)}extractParams(e){let t=e.slice(0,e.length-1539),n=e.slice(e.length-1539);return this.faceFeatureExtractor.extractWeights(t),this.extractClassifierParams(n)}},ZF=class extends VF{postProcess(e,t,n){let r=n.map(({width:s,height:i})=>{let o=t/Math.max(i,s);return{width:s*o,height:i*o}}),a=r.length;return B(()=>{let s=(u,p)=>Dt([Un([68],u,"float32"),Un([68],p,"float32")],1).as2D(1,136).as1D(),i=(u,p)=>{let{width:h,height:d}=r[u];return p(h,d)?Math.abs(h-d)/2:0},o=u=>i(u,(p,h)=>p<h),l=u=>i(u,(p,h)=>h<p);return e.mul(Un([a,136],t,"float32")).sub(Dt(Array.from(Array(a),(u,p)=>s(o(p),l(p))))).div(Dt(Array.from(Array(a),(u,p)=>s(r[p].width,r[p].height))))})}forwardInput(e){return B(()=>{let t=this.runNet(e);return this.postProcess(t,e.inputSize,e.inputDimensions.map(([n,r])=>({height:n,width:r})))})}async forward(e){return this.forwardInput(await dn(e))}async detectLandmarks(e){let t=await dn(e),n=B(()=>Tt(this.forwardInput(t))),r=await Promise.all(n.map(async(a,s)=>{let i=Array.from(a.dataSync()),o=i.filter((u,p)=>fx(p)),l=i.filter((u,p)=>!fx(p));return new v1(Array(68).fill(0).map((u,p)=>new tt(o[p],l[p])),{height:t.getInputHeight(s),width:t.getInputWidth(s)})}));return n.forEach(a=>a.dispose()),t.isBatchInput?r:r[0]}getClassifierChannelsOut(){return 136}},A1=class extends ZF{constructor(e=new BF){super("FaceLandmark68Net",e)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}};function Yfe(e){let t=[],{extractDenseBlock3Params:n}=PF(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2")};return xs(e,t),{params:r,paramMappings:t}}function Qfe(e){let t=[],{extractWeights:n,getRemainingWeights:r}=vs(e),{extractDenseBlock3Params:a}=LF(n,t),s=a(3,32,"dense0",!0),i=a(32,64,"dense1"),o=a(64,128,"dense2");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o}}}var ege=class extends Ia{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyFaceFeatureExtractor - load model before inference");return B(()=>{let n=oe(e.toBatchTensor(112,!0),"float32"),r=qu(n,[122.782,117.001,104.298]).div(255),a=db(r,t.dense0,!0);return a=db(a,t.dense1),a=db(a,t.dense2),a=ya(a,[14,14],[2,2],"valid"),a})}async forward(e){return this.forwardInput(await dn(e))}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeightMap(e){return Yfe(e)}extractParams(e){return Qfe(e)}},JF=class extends ZF{constructor(e=new ege){super("FaceLandmark68TinyNet",e)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}},tge=class extends A1{};function nge(e,t){return Z(z(e,t.weights),t.biases)}function F1(e,t,n,r,a="same"){let{filters:s,bias:i}=t.conv,o=bn(e,s,n,a);return o=Z(o,i),o=nge(o,t.scale),r?nt(o):o}function rge(e,t){return F1(e,t,[1,1],!0)}function YF(e,t){return F1(e,t,[1,1],!1)}function QF(e,t){return F1(e,t,[2,2],!0,"valid")}function age(e,t){function n(o,l,u){let p=e(o),h=p.length/(l*u*u);if(dF(h))throw new Error(`depth has to be an integer: ${h}, weights.length: ${p.length}, numFilters: ${l}, filterSize: ${u}`);return B(()=>Me(Ya(p,[l,h,u,u]),[2,3,1,0]))}function r(o,l,u,p){let h=n(o,l,u),d=Qe(e(l));return t.push({paramPath:`${p}/filters`},{paramPath:`${p}/bias`}),{filters:h,bias:d}}function a(o,l){let u=Qe(e(o)),p=Qe(e(o));return t.push({paramPath:`${l}/weights`},{paramPath:`${l}/biases`}),{weights:u,biases:p}}function s(o,l,u,p){let h=r(o,l,u,`${p}/conv`),d=a(l,`${p}/scale`);return{conv:h,scale:d}}function i(o,l,u,p,h=!1){let d=s((h?.5:1)*o,l,u,`${p}/conv1`),c=s(o,l,u,`${p}/conv2`);return{conv1:d,conv2:c}}return{extractConvLayerParams:s,extractResidualLayerParams:i}}function sge(e){let{extractWeights:t,getRemainingWeights:n}=vs(e),r=[],{extractConvLayerParams:a,extractResidualLayerParams:s}=age(t,r),i=a(4704,32,7,"conv32_down"),o=s(9216,32,3,"conv32_1"),l=s(9216,32,3,"conv32_2"),u=s(9216,32,3,"conv32_3"),p=s(36864,64,3,"conv64_down",!0),h=s(36864,64,3,"conv64_1"),d=s(36864,64,3,"conv64_2"),c=s(36864,64,3,"conv64_3"),m=s(147456,128,3,"conv128_down",!0),f=s(147456,128,3,"conv128_1"),g=s(147456,128,3,"conv128_2"),y=s(589824,256,3,"conv256_down",!0),b=s(589824,256,3,"conv256_1"),x=s(589824,256,3,"conv256_2"),v=s(589824,256,3,"conv256_down_out"),I=B(()=>Me(Gr(t(256*128),[128,256]),[1,0]));if(r.push({paramPath:"fc"}),n().length!==0)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{conv32_down:i,conv32_1:o,conv32_2:l,conv32_3:u,conv64_down:p,conv64_1:h,conv64_2:d,conv64_3:c,conv128_down:m,conv128_1:f,conv128_2:g,conv256_down:y,conv256_1:b,conv256_2:x,conv256_down_out:v,fc:I},paramMappings:r}}function ige(e,t){let n=Lo(e,t);function r(i){let o=n(`${i}/scale/weights`,1),l=n(`${i}/scale/biases`,1);return{weights:o,biases:l}}function a(i){let o=n(`${i}/conv/filters`,4),l=n(`${i}/conv/bias`,1),u=r(i);return{conv:{filters:o,bias:l},scale:u}}function s(i){return{conv1:a(`${i}/conv1`),conv2:a(`${i}/conv2`)}}return{extractConvLayerParams:a,extractResidualLayerParams:s}}function oge(e){let t=[],{extractConvLayerParams:n,extractResidualLayerParams:r}=ige(e,t),a=n("conv32_down"),s=r("conv32_1"),i=r("conv32_2"),o=r("conv32_3"),l=r("conv64_down"),u=r("conv64_1"),p=r("conv64_2"),h=r("conv64_3"),d=r("conv128_down"),c=r("conv128_1"),m=r("conv128_2"),f=r("conv256_down"),g=r("conv256_1"),y=r("conv256_2"),b=r("conv256_down_out"),{fc:x}=e;if(t.push({originalPath:"fc",paramPath:"fc"}),!pF(x))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${x}`);let v={conv32_down:a,conv32_1:s,conv32_2:i,conv32_3:o,conv64_down:l,conv64_1:u,conv64_2:p,conv64_3:h,conv128_down:d,conv128_1:c,conv128_2:m,conv256_down:f,conv256_1:g,conv256_2:y,conv256_down_out:b,fc:x};return xs(e,t),{params:v,paramMappings:t}}function Dr(e,t){let n=rge(e,t.conv1);return n=YF(n,t.conv2),n=Z(n,e),n=nt(n),n}function Ph(e,t){let n=QF(e,t.conv1);n=YF(n,t.conv2);let r=ya(e,2,2,"valid"),a=It(r.shape),s=r.shape[3]!==n.shape[3];if(r.shape[1]!==n.shape[1]||r.shape[2]!==n.shape[2]){let i=[...n.shape];i[1]=1;let o=It(i);n=ot([n,o],1);let l=[...n.shape];l[2]=1;let u=It(l);n=ot([n,u],2)}return r=s?ot([r,a],3):r,n=Z(r,n),n=nt(n),n}var R1=class extends Ia{constructor(){super("FaceRecognitionNet")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceRecognitionNet - load model before inference");return B(()=>{let n=oe(e.toBatchTensor(150,!0),"float32"),r=qu(n,[122.782,117.001,104.298]).div(255),a=QF(r,t.conv32_down);a=jt(a,3,2,"valid"),a=Dr(a,t.conv32_1),a=Dr(a,t.conv32_2),a=Dr(a,t.conv32_3),a=Ph(a,t.conv64_down),a=Dr(a,t.conv64_1),a=Dr(a,t.conv64_2),a=Dr(a,t.conv64_3),a=Ph(a,t.conv128_down),a=Dr(a,t.conv128_1),a=Dr(a,t.conv128_2),a=Ph(a,t.conv256_down),a=Dr(a,t.conv256_1),a=Dr(a,t.conv256_2),a=Ph(a,t.conv256_down_out);let s=a.mean([1,2]);return De(s,t.fc)})}async forward(e){return this.forwardInput(await dn(e))}async computeFaceDescriptor(e){var t;if((t=e==null?void 0:e.shape)!=null&&t.some(s=>s<=0))return new Float32Array(128);let n=await dn(e),r=B(()=>Tt(this.forwardInput(n))),a=await Promise.all(r.map(s=>s.data()));return r.forEach(s=>s.dispose()),n.isBatchInput?a:a[0]}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeightMap(e){return oge(e)}extractParams(e){return sge(e)}};function lge(e){let t=new R1;return t.extractWeights(e),t}function D1(e,t){return{...e,descriptor:t}}function uge(e){return typeof e.age=="number"}function M1(e,t){return{...e,age:t}}function pge(e){return(e.gender==="male"||e.gender==="female")&&Tc(e.genderProbability)}function O1(e,t,n){return{...e,gender:t,genderProbability:n}}function dge(e,t){function n(l,u){let p=Ya(e(9*l),[3,3,l,1]),h=Qe(e(l)),d=Qe(e(l)),c=Qe(e(l)),m=Qe(e(l));return t.push({paramPath:`${u}/filters`},{paramPath:`${u}/batch_norm_scale`},{paramPath:`${u}/batch_norm_offset`},{paramPath:`${u}/batch_norm_mean`},{paramPath:`${u}/batch_norm_variance`}),{filters:p,batch_norm_scale:h,batch_norm_offset:d,batch_norm_mean:c,batch_norm_variance:m}}function r(l,u,p,h,d){let c=Ya(e(l*u*p*p),[p,p,l,u]),m=Qe(e(u));return t.push({paramPath:`${h}/filters`},{paramPath:`${h}/${d?"batch_norm_offset":"bias"}`}),{filters:c,bias:m}}function a(l,u,p,h){let{filters:d,bias:c}=r(l,u,p,h,!0);return{filters:d,batch_norm_offset:c}}function s(l,u,p){let h=n(l,`${p}/depthwise_conv`),d=a(l,u,1,`${p}/pointwise_conv`);return{depthwise_conv:h,pointwise_conv:d}}function i(){let l=a(3,32,3,"mobilenetv1/conv_0"),u=s(32,64,"mobilenetv1/conv_1"),p=s(64,128,"mobilenetv1/conv_2"),h=s(128,128,"mobilenetv1/conv_3"),d=s(128,256,"mobilenetv1/conv_4"),c=s(256,256,"mobilenetv1/conv_5"),m=s(256,512,"mobilenetv1/conv_6"),f=s(512,512,"mobilenetv1/conv_7"),g=s(512,512,"mobilenetv1/conv_8"),y=s(512,512,"mobilenetv1/conv_9"),b=s(512,512,"mobilenetv1/conv_10"),x=s(512,512,"mobilenetv1/conv_11"),v=s(512,1024,"mobilenetv1/conv_12"),I=s(1024,1024,"mobilenetv1/conv_13");return{conv_0:l,conv_1:u,conv_2:p,conv_3:h,conv_4:d,conv_5:c,conv_6:m,conv_7:f,conv_8:g,conv_9:y,conv_10:b,conv_11:x,conv_12:v,conv_13:I}}function o(){let l=a(1024,256,1,"prediction_layer/conv_0"),u=a(256,512,3,"prediction_layer/conv_1"),p=a(512,128,1,"prediction_layer/conv_2"),h=a(128,256,3,"prediction_layer/conv_3"),d=a(256,128,1,"prediction_layer/conv_4"),c=a(128,256,3,"prediction_layer/conv_5"),m=a(256,64,1,"prediction_layer/conv_6"),f=a(64,128,3,"prediction_layer/conv_7"),g=r(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),y=r(512,9,1,"prediction_layer/box_predictor_0/class_predictor"),b=r(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),x=r(1024,18,1,"prediction_layer/box_predictor_1/class_predictor"),v=r(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),I=r(512,18,1,"prediction_layer/box_predictor_2/class_predictor"),N=r(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),C=r(256,18,1,"prediction_layer/box_predictor_3/class_predictor"),E=r(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),A=r(256,18,1,"prediction_layer/box_predictor_4/class_predictor"),R=r(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),F=r(128,18,1,"prediction_layer/box_predictor_5/class_predictor");return{conv_0:l,conv_1:u,conv_2:p,conv_3:h,conv_4:d,conv_5:c,conv_6:m,conv_7:f,box_predictor_0:{box_encoding_predictor:g,class_predictor:y},box_predictor_1:{box_encoding_predictor:b,class_predictor:x},box_predictor_2:{box_encoding_predictor:v,class_predictor:I},box_predictor_3:{box_encoding_predictor:N,class_predictor:C},box_predictor_4:{box_encoding_predictor:E,class_predictor:A},box_predictor_5:{box_encoding_predictor:R,class_predictor:F}}}return{extractMobilenetV1Params:i,extractPredictionLayerParams:o}}function hge(e){let t=[],{extractWeights:n,getRemainingWeights:r}=vs(e),{extractMobilenetV1Params:a,extractPredictionLayerParams:s}=dge(n,t),i=a(),o=s(),l={extra_dim:fm(n(5118*4),[1,5118,4])};if(t.push({paramPath:"output_layer/extra_dim"}),r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{params:{mobilenetv1:i,prediction_layer:o,output_layer:l},paramMappings:t}}function cge(e,t){let n=Lo(e,t);function r(u,p,h){let d=n(`${u}/Conv2d_${p}_pointwise/weights`,4,`${h}/filters`),c=n(`${u}/Conv2d_${p}_pointwise/convolution_bn_offset`,1,`${h}/batch_norm_offset`);return{filters:d,batch_norm_offset:c}}function a(u){let p=`mobilenetv1/conv_${u}`,h=`MobilenetV1/Conv2d_${u}_depthwise`,d=`${p}/depthwise_conv`,c=`${p}/pointwise_conv`,m=n(`${h}/depthwise_weights`,4,`${d}/filters`),f=n(`${h}/BatchNorm/gamma`,1,`${d}/batch_norm_scale`),g=n(`${h}/BatchNorm/beta`,1,`${d}/batch_norm_offset`),y=n(`${h}/BatchNorm/moving_mean`,1,`${d}/batch_norm_mean`),b=n(`${h}/BatchNorm/moving_variance`,1,`${d}/batch_norm_variance`);return{depthwise_conv:{filters:m,batch_norm_scale:f,batch_norm_offset:g,batch_norm_mean:y,batch_norm_variance:b},pointwise_conv:r("MobilenetV1",u,c)}}function s(){return{conv_0:r("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:a(1),conv_2:a(2),conv_3:a(3),conv_4:a(4),conv_5:a(5),conv_6:a(6),conv_7:a(7),conv_8:a(8),conv_9:a(9),conv_10:a(10),conv_11:a(11),conv_12:a(12),conv_13:a(13)}}function i(u,p){let h=n(`${u}/weights`,4,`${p}/filters`),d=n(`${u}/biases`,1,`${p}/bias`);return{filters:h,bias:d}}function o(u){let p=i(`Prediction/BoxPredictor_${u}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${u}/box_encoding_predictor`),h=i(`Prediction/BoxPredictor_${u}/ClassPredictor`,`prediction_layer/box_predictor_${u}/class_predictor`);return{box_encoding_predictor:p,class_predictor:h}}function l(){return{conv_0:r("Prediction",0,"prediction_layer/conv_0"),conv_1:r("Prediction",1,"prediction_layer/conv_1"),conv_2:r("Prediction",2,"prediction_layer/conv_2"),conv_3:r("Prediction",3,"prediction_layer/conv_3"),conv_4:r("Prediction",4,"prediction_layer/conv_4"),conv_5:r("Prediction",5,"prediction_layer/conv_5"),conv_6:r("Prediction",6,"prediction_layer/conv_6"),conv_7:r("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:o(0),box_predictor_1:o(1),box_predictor_2:o(2),box_predictor_3:o(3),box_predictor_4:o(4),box_predictor_5:o(5)}}return{extractMobilenetV1Params:s,extractPredictionLayerParams:l}}function mge(e){let t=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:r}=cge(e,t),a=e["Output/extra_dim"];if(t.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!qd(a))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${a}`);let s={mobilenetv1:n(),prediction_layer:r(),output_layer:{extra_dim:a}};return xs(e,t),{params:s,paramMappings:t}}function Lr(e,t,n){return B(()=>{let r=bn(e,t.filters,n,"same");return r=Z(r,t.batch_norm_offset),un(r,0,6)})}var fge=.0010000000474974513;function gge(e,t,n){return B(()=>{let r=Co(e,t.filters,n,"same");return r=To(r,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,fge),un(r,0,6)})}function yge(e){return[2,4,6,12].some(t=>t===e)?[2,2]:[1,1]}function bge(e,t){return B(()=>{let n,r=Lr(e,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach((a,s)=>{let i=s+1,o=yge(i);r=gge(r,a.depthwise_conv,o),r=Lr(r,a.pointwise_conv,[1,1]),i===11&&(n=r)}),n===null)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:r,conv11:n}})}function xge(e,t,n){let r=e.arraySync(),a=Math.min(r[t][0],r[t][2]),s=Math.min(r[t][1],r[t][3]),i=Math.max(r[t][0],r[t][2]),o=Math.max(r[t][1],r[t][3]),l=Math.min(r[n][0],r[n][2]),u=Math.min(r[n][1],r[n][3]),p=Math.max(r[n][0],r[n][2]),h=Math.max(r[n][1],r[n][3]),d=(i-a)*(o-s),c=(p-l)*(h-u);if(d<=0||c<=0)return 0;let m=Math.max(a,l),f=Math.max(s,u),g=Math.min(i,p),y=Math.min(o,h),b=Math.max(g-m,0)*Math.max(y-f,0);return b/(d+c-b)}function vge(e,t,n,r,a){let s=e.shape[0],i=Math.min(n,s),o=t.map((p,h)=>({score:p,boxIndex:h})).filter(p=>p.score>a).sort((p,h)=>h.score-p.score),l=p=>p<=r?1:0,u=[];return o.forEach(p=>{if(u.length>=i)return;let h=p.score;for(let d=u.length-1;d>=0;--d){let c=xge(e,p.boxIndex,u[d]);if(c!==0&&(p.score*=l(c),p.score<=a))break}h===p.score&&u.push(p.boxIndex)}),u}function wge(e){let t=Tt(Me(e,[1,0])),n=[he(t[2],t[0]),he(t[3],t[1])],r=[Z(t[0],ce(n[0],2)),Z(t[1],ce(n[1],2))];return{sizes:n,centers:r}}function kge(e,t){let{sizes:n,centers:r}=wge(e),a=Tt(Me(t,[1,0])),s=ce(z(pn(ce(a[2],5)),n[0]),2),i=Z(z(ce(a[0],10),n[0]),r[0]),o=ce(z(pn(ce(a[3],5)),n[1]),2),l=Z(z(ce(a[1],10),n[1]),r[1]);return Me(Dt([he(i,s),he(l,o),Z(i,s),Z(l,o)]),[1,0])}function Ige(e,t,n){return B(()=>{let r=e.shape[0],a=kge(P(Vn(n.extra_dim,[r,1,1]),[-1,4]),P(e,[-1,4]));a=P(a,[r,a.shape[0]/r,4]);let s=fr(Ue(t,[0,0,1],[-1,-1,-1])),i=Ue(s,[0,0,0],[-1,-1,1]);i=P(i,[r,i.shape[1]]);let o=Tt(a),l=Tt(i);return{boxes:o,scores:l}})}function Xo(e,t){return B(()=>{let n=e.shape[0],r=P(Ip(e,t.box_encoding_predictor),[n,-1,1,4]),a=P(Ip(e,t.class_predictor),[n,-1,3]);return{boxPredictionEncoding:r,classPrediction:a}})}function Sge(e,t,n){return B(()=>{let r=Lr(e,n.conv_0,[1,1]),a=Lr(r,n.conv_1,[2,2]),s=Lr(a,n.conv_2,[1,1]),i=Lr(s,n.conv_3,[2,2]),o=Lr(i,n.conv_4,[1,1]),l=Lr(o,n.conv_5,[2,2]),u=Lr(l,n.conv_6,[1,1]),p=Lr(u,n.conv_7,[2,2]),h=Xo(t,n.box_predictor_0),d=Xo(e,n.box_predictor_1),c=Xo(a,n.box_predictor_2),m=Xo(i,n.box_predictor_3),f=Xo(l,n.box_predictor_4),g=Xo(p,n.box_predictor_5),y=ot([h.boxPredictionEncoding,d.boxPredictionEncoding,c.boxPredictionEncoding,m.boxPredictionEncoding,f.boxPredictionEncoding,g.boxPredictionEncoding],1),b=ot([h.classPrediction,d.classPrediction,c.classPrediction,m.classPrediction,f.classPrediction,g.classPrediction],1);return{boxPredictions:y,classPredictions:b}})}var zo=class{constructor({minConfidence:e,maxResults:t}={}){if(this._name="SsdMobilenetv1Options",this._minConfidence=e||.5,this._maxResults=t||100,typeof this._minConfidence!="number"||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if(typeof this._maxResults!="number")throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}},df=class extends Ia{constructor(){super("SsdMobilenetv1")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("SsdMobilenetv1 - load model before inference");return B(()=>{let n=oe(e.toBatchTensor(512,!1),"float32"),r=he(ce(n,127.5),1),a=bge(r,t.mobilenetv1),{boxPredictions:s,classPredictions:i}=Sge(a.out,a.conv11,t.prediction_layer);return Ige(s,i,t.output_layer)})}async forward(e){return this.forwardInput(await dn(e))}async locateFaces(e,t={}){let{maxResults:n,minConfidence:r}=new zo(t),a=await dn(e),{boxes:s,scores:i}=this.forwardInput(a),o=s[0],l=i[0];for(let y=1;y<s.length;y++)s[y].dispose(),i[y].dispose();let u=Array.from(l.dataSync()),p=vge(o,u,n,.5,r),h=a.getReshapedInputDimensions(0),d=a.inputSize,c=d/h.width,m=d/h.height,f=o.arraySync(),g=p.map(y=>{let[b,x]=[Math.max(0,f[y][0]),Math.min(1,f[y][2])].map(N=>N*m),[v,I]=[Math.max(0,f[y][1]),Math.min(1,f[y][3])].map(N=>N*c);return new lr(u[y],new x1(v,b,I-v,x-b),{height:a.getInputHeight(0),width:a.getInputWidth(0)})});return o.dispose(),l.dispose(),g}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeightMap(e){return mge(e)}extractParams(e){return hge(e)}};function eR(e){let t=new df;return t.extractWeights(e),t}function Nge(e){return eR(e)}var Tge=class extends df{},Cge=.4,_ge=[new tt(.738768,.874946),new tt(2.42204,2.65704),new tt(4.30971,7.04493),new tt(10.246,4.59428),new tt(12.6868,11.8741)],Ege=[new tt(1.603231,2.094468),new tt(6.041143,7.080126),new tt(2.882459,3.518061),new tt(4.266906,5.178857),new tt(9.041765,10.66308)],$ge=[117.001,114.697,97.404],Age="tiny_yolov2_model",Fge="tiny_yolov2_separable_conv_model",Bh=e=>typeof e=="number";function tR(e){if(!e)throw new Error(`invalid config: ${e}`);if(typeof e.withSeparableConvs!="boolean")throw new Error(`config.withSeparableConvs has to be a boolean, have: ${e.withSeparableConvs}`);if(!Bh(e.iouThreshold)||e.iouThreshold<0||e.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${e.iouThreshold}`);if(!Array.isArray(e.classes)||!e.classes.length||!e.classes.every(t=>typeof t=="string"))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(e.classes)}`);if(!Array.isArray(e.anchors)||!e.anchors.length||!e.anchors.map(t=>t||{}).every(t=>Bh(t.x)&&Bh(t.y)))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(e.anchors)}`);if(e.meanRgb&&(!Array.isArray(e.meanRgb)||e.meanRgb.length!==3||!e.meanRgb.every(Bh)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(e.meanRgb)}`)}function L1(e){return B(()=>{let t=z(e,ve(.10000000149011612));return Z(nt(he(e,t)),t)})}function _a(e,t){return B(()=>{let n=Ar(e,[[0,0],[1,1],[1,1],[0,0]]);return n=bn(n,t.conv.filters,[1,1],"valid"),n=he(n,t.bn.sub),n=z(n,t.bn.truediv),n=Z(n,t.conv.bias),L1(n)})}function Ea(e,t){return B(()=>{let n=Ar(e,[[0,0],[1,1],[1,1],[0,0]]);return n=Au(n,t.depthwise_filter,t.pointwise_filter,[1,1],"valid"),n=Z(n,t.bias),L1(n)})}function Rge(e,t){let n=C1(e,t);function r(i,o){let l=Qe(e(i)),u=Qe(e(i));return t.push({paramPath:`${o}/sub`},{paramPath:`${o}/truediv`}),{sub:l,truediv:u}}function a(i,o,l){let u=n(i,o,3,`${l}/conv`),p=r(o,`${l}/bn`);return{conv:u,bn:p}}let s=_1(e,t);return{extractConvParams:n,extractConvWithBatchNormParams:a,extractSeparableConvParams:s}}function Dge(e,t,n,r){let{extractWeights:a,getRemainingWeights:s}=vs(e),i=[],{extractConvParams:o,extractConvWithBatchNormParams:l,extractSeparableConvParams:u}=Rge(a,i),p;if(t.withSeparableConvs){let[h,d,c,m,f,g,y,b,x]=r,v=t.isFirstLayerConv2d?o(h,d,3,"conv0"):u(h,d,"conv0"),I=u(d,c,"conv1"),N=u(c,m,"conv2"),C=u(m,f,"conv3"),E=u(f,g,"conv4"),A=u(g,y,"conv5"),R=b?u(y,b,"conv6"):void 0,F=x?u(b,x,"conv7"):void 0,S=o(x||b||y,5*n,1,"conv8");p={conv0:v,conv1:I,conv2:N,conv3:C,conv4:E,conv5:A,conv6:R,conv7:F,conv8:S}}else{let[h,d,c,m,f,g,y,b,x]=r,v=l(h,d,"conv0"),I=l(d,c,"conv1"),N=l(c,m,"conv2"),C=l(m,f,"conv3"),E=l(f,g,"conv4"),A=l(g,y,"conv5"),R=l(y,b,"conv6"),F=l(b,x,"conv7"),S=o(x,5*n,1,"conv8");p={conv0:v,conv1:I,conv2:N,conv3:C,conv4:E,conv5:A,conv6:R,conv7:F,conv8:S}}if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{params:p,paramMappings:i}}function Mge(e,t){let n=Lo(e,t);function r(o){let l=n(`${o}/sub`,1),u=n(`${o}/truediv`,1);return{sub:l,truediv:u}}function a(o){let l=n(`${o}/filters`,4),u=n(`${o}/bias`,1);return{filters:l,bias:u}}function s(o){let l=a(`${o}/conv`),u=r(`${o}/bn`);return{conv:l,bn:u}}let i=E1(n);return{extractConvParams:a,extractConvWithBatchNormParams:s,extractSeparableConvParams:i}}function Oge(e,t){let n=[],{extractConvParams:r,extractConvWithBatchNormParams:a,extractSeparableConvParams:s}=Mge(e,n),i;if(t.withSeparableConvs){let o=t.filterSizes&&t.filterSizes.length||9;i={conv0:t.isFirstLayerConv2d?r("conv0"):s("conv0"),conv1:s("conv1"),conv2:s("conv2"),conv3:s("conv3"),conv4:s("conv4"),conv5:s("conv5"),conv6:o>7?s("conv6"):void 0,conv7:o>8?s("conv7"):void 0,conv8:r("conv8")}}else i={conv0:a("conv0"),conv1:a("conv1"),conv2:a("conv2"),conv3:a("conv3"),conv4:a("conv4"),conv5:a("conv5"),conv6:a("conv6"),conv7:a("conv7"),conv8:r("conv8")};return xs(e,n),{params:i,paramMappings:n}}var Xd=class{constructor({inputSize:e,scoreThreshold:t}={}){if(this._name="TinyYolov2Options",this._inputSize=e||416,this._scoreThreshold=t||.5,typeof this._inputSize!="number"||this._inputSize%32!==0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if(typeof this._scoreThreshold!="number"||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}},nR=class rR extends Ia{constructor(t){super("TinyYolov2"),tR(t),this._config=t}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(t,n){let r=_a(t,n.conv0);return r=jt(r,[2,2],[2,2],"same"),r=_a(r,n.conv1),r=jt(r,[2,2],[2,2],"same"),r=_a(r,n.conv2),r=jt(r,[2,2],[2,2],"same"),r=_a(r,n.conv3),r=jt(r,[2,2],[2,2],"same"),r=_a(r,n.conv4),r=jt(r,[2,2],[2,2],"same"),r=_a(r,n.conv5),r=jt(r,[2,2],[1,1],"same"),r=_a(r,n.conv6),r=_a(r,n.conv7),Ip(r,n.conv8,"valid",!1)}runMobilenet(t,n){let r=this.config.isFirstLayerConv2d?L1(Ip(t,n.conv0,"valid",!1)):Ea(t,n.conv0);return r=jt(r,[2,2],[2,2],"same"),r=Ea(r,n.conv1),r=jt(r,[2,2],[2,2],"same"),r=Ea(r,n.conv2),r=jt(r,[2,2],[2,2],"same"),r=Ea(r,n.conv3),r=jt(r,[2,2],[2,2],"same"),r=Ea(r,n.conv4),r=jt(r,[2,2],[2,2],"same"),r=Ea(r,n.conv5),r=jt(r,[2,2],[1,1],"same"),r=n.conv6?Ea(r,n.conv6):r,r=n.conv7?Ea(r,n.conv7):r,Ip(r,n.conv8,"valid",!1)}forwardInput(t,n){let{params:r}=this;if(!r)throw new Error("TinyYolov2 - load model before inference");return B(()=>{let a=oe(t.toBatchTensor(n,!1),"float32");return a=this.config.meanRgb?qu(a,this.config.meanRgb):a,a=a.div(255),this.config.withSeparableConvs?this.runMobilenet(a,r):this.runTinyYolov2(a,r)})}async forward(t,n){return this.forwardInput(await dn(t),n)}async detect(t,n={}){let{inputSize:r,scoreThreshold:a}=new Xd(n),s=await dn(t),i=await this.forwardInput(s,r),o=B(()=>Tt(i)[0].expandDims()),l={width:s.getInputWidth(0),height:s.getInputHeight(0)},u=await this.extractBoxes(o,s.getReshapedInputDimensions(0),a);i.dispose(),o.dispose();let p=u.map(m=>m.box),h=u.map(m=>m.score),d=u.map(m=>m.classScore),c=u.map(m=>this.config.classes[m.label]);return yF(p.map(m=>m.rescale(r)),h,this.config.iouThreshold,!0).map(m=>new b1(h[m],d[m],c[m],p[m],l))}getDefaultModelName(){return""}extractParamsFromWeightMap(t){return Oge(t,this.config)}extractParams(t){let n=this.config.filterSizes||rR.DEFAULT_FILTER_SIZES,r=n?n.length:void 0;if(r!==7&&r!==8&&r!==9)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${r} filterSizes in config`);return Dge(t,this.config,this.boxEncodingSize,n)}async extractBoxes(t,n,r){let{width:a,height:s}=n,i=Math.max(a,s),o=i/a,l=i/s,u=t.shape[1],p=this.config.anchors.length,[h,d,c]=B(()=>{let y=t.reshape([u,u,p,this.boxEncodingSize]),b=y.slice([0,0,0,0],[u,u,p,4]),x=y.slice([0,0,0,4],[u,u,p,1]),v=this.withClassScores?cs(y.slice([0,0,0,5],[u,u,p,this.config.classes.length]),3):ve(0);return[b,x,v]}),m=[],f=await d.array(),g=await h.array();for(let y=0;y<u;y++)for(let b=0;b<u;b++)for(let x=0;x<p;x++){let v=Zh(f[y][b][x][0]);if(!r||v>r){let I=(b+Zh(g[y][b][x][0]))/u*o,N=(y+Zh(g[y][b][x][1]))/u*l,C=Math.exp(g[y][b][x][2])*this.config.anchors[x].x/u*o,E=Math.exp(g[y][b][x][3])*this.config.anchors[x].y/u*l,A=I-C/2,R=N-E/2,F={row:y,col:b,anchor:x},{classScore:S,label:M}=this.withClassScores?await this.extractPredictedClass(c,F):{classScore:1,label:0};m.push({box:new y1(A,R,A+C,R+E),score:v,classScore:v*S,label:M,...F})}}return h.dispose(),d.dispose(),c.dispose(),m}async extractPredictedClass(t,n){let{row:r,col:a,anchor:s}=n,i=await t.array();return Array(this.config.classes.length).fill(0).map((o,l)=>i[r][a][s][l]).map((o,l)=>({classScore:o,label:l})).reduce((o,l)=>o.classScore>l.classScore?o:l)}};nR.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var aR=nR,z1=class extends aR{constructor(e=!0){let t={withSeparableConvs:e,iouThreshold:Cge,classes:["face"],...e?{anchors:Ege,meanRgb:$ge}:{anchors:_ge,withClassScores:!0}};super(t)}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(n=>new lr(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return this.withSeparableConvs?Fge:Age}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}};function Lge(e,t=!0){let n=new z1(t);return n.extractWeights(e),n}var sR=class extends Xd{constructor(){super(...arguments),this._name="TinyFaceDetectorOptions"}},Ku=class{async then(e){return e(await this.run())}async run(){throw new Error("ComposableTask - run is not implemented")}};async function hf(e,t,n,r,a=({alignedRect:s})=>s){let s=e.map(l=>uf(l)?a(l):l.detection),i=r||(t instanceof Re?await of(t,s):await sf(t,s)),o=await n(i);return i.forEach(l=>l instanceof Re&&l.dispose()),o}async function P1(e,t,n,r,a){return hf([e],t,async s=>n(s[0]),r,a)}var zge=.4,Pge=[new tt(1.603231,2.094468),new tt(6.041143,7.080126),new tt(2.882459,3.518061),new tt(4.266906,5.178857),new tt(9.041765,10.66308)],Bge=[117.001,114.697,97.404],B1=class extends aR{constructor(){let e={withSeparableConvs:!0,iouThreshold:zge,classes:["face"],anchors:Pge,meanRgb:Bge,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]};super(e)}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(n=>new lr(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},ht={ssdMobilenetv1:new df,tinyFaceDetector:new B1,tinyYolov2:new z1,faceLandmark68Net:new A1,faceLandmark68TinyNet:new JF,faceRecognitionNet:new R1,faceExpressionNet:new UF,ageGenderNet:new XF},iR=(e,t)=>ht.ssdMobilenetv1.locateFaces(e,t),Wge=(e,t)=>ht.tinyFaceDetector.locateFaces(e,t),Vge=(e,t)=>ht.tinyYolov2.locateFaces(e,t),oR=e=>ht.faceLandmark68Net.detectLandmarks(e),Uge=e=>ht.faceLandmark68TinyNet.detectLandmarks(e),Gge=e=>ht.faceRecognitionNet.computeFaceDescriptor(e),Hge=e=>ht.faceExpressionNet.predictExpressions(e),jge=e=>ht.ageGenderNet.predictAgeAndGender(e),lR=e=>ht.ssdMobilenetv1.load(e),qge=e=>ht.tinyFaceDetector.load(e),Kge=e=>ht.tinyYolov2.load(e),Xge=e=>ht.faceLandmark68Net.load(e),Zge=e=>ht.faceLandmark68TinyNet.load(e),Jge=e=>ht.faceRecognitionNet.load(e),Yge=e=>ht.faceExpressionNet.load(e),Qge=e=>ht.ageGenderNet.load(e),eye=lR,tye=iR,nye=oR,uR=class extends Ku{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},W1=class extends uR{async run(){let e=await this.parentTask,t=await hf(e,this.input,async n=>Promise.all(n.map(r=>ht.faceExpressionNet.predictExpressions(r))),this.extractedFaces);return e.map((n,r)=>$1(n,t[r]))}withAgeAndGender(){return new H1(this,this.input)}},V1=class extends uR{async run(){let e=await this.parentTask;if(!e)return;let t=await P1(e,this.input,n=>ht.faceExpressionNet.predictExpressions(n),this.extractedFaces);return $1(e,t)}withAgeAndGender(){return new j1(this,this.input)}},U1=class extends W1{withAgeAndGender(){return new q1(this,this.input)}withFaceDescriptors(){return new cf(this,this.input)}},G1=class extends V1{withAgeAndGender(){return new K1(this,this.input)}withFaceDescriptor(){return new mf(this,this.input)}},pR=class extends Ku{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},H1=class extends pR{async run(){let e=await this.parentTask,t=await hf(e,this.input,async n=>Promise.all(n.map(r=>ht.ageGenderNet.predictAgeAndGender(r))),this.extractedFaces);return e.map((n,r)=>{let{age:a,gender:s,genderProbability:i}=t[r];return M1(O1(n,s,i),a)})}withFaceExpressions(){return new W1(this,this.input)}},j1=class extends pR{async run(){let e=await this.parentTask;if(!e)return;let{age:t,gender:n,genderProbability:r}=await P1(e,this.input,a=>ht.ageGenderNet.predictAgeAndGender(a),this.extractedFaces);return M1(O1(e,n,r),t)}withFaceExpressions(){return new V1(this,this.input)}},q1=class extends H1{withFaceExpressions(){return new U1(this,this.input)}withFaceDescriptors(){return new cf(this,this.input)}},K1=class extends j1{withFaceExpressions(){return new G1(this,this.input)}withFaceDescriptor(){return new mf(this,this.input)}},X1=class extends Ku{constructor(e,t){super(),this.parentTask=e,this.input=t}},cf=class extends X1{async run(){let e=await this.parentTask;return(await hf(e,this.input,t=>Promise.all(t.map(n=>ht.faceRecognitionNet.computeFaceDescriptor(n))),null,t=>t.landmarks.align(null,{useDlibAlignment:!0}))).map((t,n)=>D1(e[n],t))}withFaceExpressions(){return new U1(this,this.input)}withAgeAndGender(){return new q1(this,this.input)}},mf=class extends X1{async run(){let e=await this.parentTask;if(!e)return;let t=await P1(e,this.input,n=>ht.faceRecognitionNet.computeFaceDescriptor(n),null,n=>n.landmarks.align(null,{useDlibAlignment:!0}));return D1(e,t)}withFaceExpressions(){return new G1(this,this.input)}withAgeAndGender(){return new K1(this,this.input)}},Z1=class extends Ku{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.useTinyLandmarkNet=n}get landmarkNet(){return this.useTinyLandmarkNet?ht.faceLandmark68TinyNet:ht.faceLandmark68Net}},dR=class extends Z1{async run(){let e=await this.parentTask,t=e.map(a=>a.detection),n=this.input instanceof Re?await of(this.input,t):await sf(this.input,t),r=await Promise.all(n.map(a=>this.landmarkNet.detectLandmarks(a)));return n.forEach(a=>a instanceof Re&&a.dispose()),e.filter((a,s)=>r[s]).map((a,s)=>pf(a,r[s]))}withFaceExpressions(){return new U1(this,this.input)}withAgeAndGender(){return new q1(this,this.input)}withFaceDescriptors(){return new cf(this,this.input)}},hR=class extends Z1{async run(){let e=await this.parentTask;if(!e)return;let{detection:t}=e,n=this.input instanceof Re?await of(this.input,[t]):await sf(this.input,[t]),r=await this.landmarkNet.detectLandmarks(n[0]);return n.forEach(a=>a instanceof Re&&a.dispose()),pf(e,r)}withFaceExpressions(){return new G1(this,this.input)}withAgeAndGender(){return new K1(this,this.input)}withFaceDescriptor(){return new mf(this,this.input)}},J1=class extends Ku{constructor(e,t=new zo){super(),this.input=e,this.options=t}},Y1=class extends J1{async run(){let{input:e,options:t}=this,n;if(t instanceof sR)n=ht.tinyFaceDetector.locateFaces(e,t);else if(t instanceof zo)n=ht.ssdMobilenetv1.locateFaces(e,t);else if(t instanceof Xd)n=ht.tinyYolov2.locateFaces(e,t);else throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options");return n}runAndExtendWithFaceDetections(){return new Promise((e,t)=>{this.run().then(n=>e(n.map(r=>Vp({},r)))).catch(n=>t(n))})}withFaceLandmarks(e=!1){return new dR(this.runAndExtendWithFaceDetections(),this.input,e)}withFaceExpressions(){return new W1(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new H1(this.runAndExtendWithFaceDetections(),this.input)}},cR=class extends J1{async run(){let e=await new Y1(this.input,this.options),t=e[0];return e.forEach(n=>{n.score>t.score&&(t=n)}),t}runAndExtendWithFaceDetection(){return new Promise(async e=>{let t=await this.run();e(t?Vp({},t):void 0)})}withFaceLandmarks(e=!1){return new hR(this.runAndExtendWithFaceDetection(),this.input,e)}withFaceExpressions(){return new V1(this.runAndExtendWithFaceDetection(),this.input)}withAgeAndGender(){return new j1(this.runAndExtendWithFaceDetection(),this.input)}};function rye(e,t=new zo){return new cR(e,t)}function Q1(e,t=new zo){return new Y1(e,t)}async function mR(e,t){return Q1(e,new zo(t?{minConfidence:t}:{})).withFaceLandmarks().withFaceDescriptors()}async function aye(e,t={}){return Q1(e,new Xd(t)).withFaceLandmarks().withFaceDescriptors()}var sye=mR;function fR(e,t){if(e.length!==t.length)throw new Error("euclideanDistance: arr1.length !== arr2.length");let n=Array.from(e),r=Array.from(t);return Math.sqrt(n.map((a,s)=>a-r[s]).reduce((a,s)=>a+s*s,0))}var iye=class gR{constructor(t,n=.6){this._distanceThreshold=n;let r=Array.isArray(t)?t:[t];if(!r.length)throw new Error("FaceRecognizer.constructor - expected atleast one input");let a=1,s=()=>`person ${a++}`;this._labeledDescriptors=r.map(i=>{if(i instanceof bp)return i;if(i instanceof Float32Array)return new bp(s(),[i]);if(i.descriptor&&i.descriptor instanceof Float32Array)return new bp(s(),[i.descriptor]);throw new Error("FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>")})}get labeledDescriptors(){return this._labeledDescriptors}get distanceThreshold(){return this._distanceThreshold}computeMeanDistance(t,n){return n.map(r=>fR(r,t)).reduce((r,a)=>r+a,0)/(n.length||1)}matchDescriptor(t){return this.labeledDescriptors.map(({descriptors:n,label:r})=>new yx(r,this.computeMeanDistance(t,n))).reduce((n,r)=>n.distance<r.distance?n:r)}findBestMatch(t){let n=this.matchDescriptor(t);return n.distance<this._distanceThreshold?n:new yx("unknown",n.distance)}toJSON(){return{distanceThreshold:this._distanceThreshold,labeledDescriptors:this._labeledDescriptors.map(t=>t.toJSON())}}static fromJSON(t){let n=t.labeledDescriptors.map(r=>bp.fromJSON(r));return new gR(n,t.distanceThreshold)}};function oye(e){let t=new B1;return t.extractWeights(e),t}function yR(e,t){let{width:n,height:r}=new Ua(t.width,t.height);if(n<=0||r<=0)throw new Error(`resizeResults - invalid dimensions: ${JSON.stringify({width:n,height:r})}`);if(Array.isArray(e))return e.map(a=>yR(a,{width:n,height:r}));if(uf(e)){let a=e.detection.forSize(n,r),s=e.unshiftedLandmarks.forSize(a.box.width,a.box.height);return pf(Vp(e,a),s)}return kl(e)?Vp(e,e.detection.forSize(n,r)):e instanceof si||e instanceof lr?e.forSize(n,r):e}var lye=Ufe;return nD(uye);})();
